(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
const Parser = require("binary-parser").Parser;

const
	BHD_VERSION_BABYZ = 14,
	BHD_VERSION_PETZ = 15;

const
	BHDHeader = new Parser()
		.endianess("little")
		.uint16("framesOffset")
		.uint16("unknown")
		.uint16("version")
		.uint16("numBalls")
		.array("unknown2", {
			type: "uint8",
			length: 30
		})
		.array("ballSizes", {
			type: "uint16le",
			length: "numBalls"
		})
		
		.array("unknown3", {
			type: "uint8",
			length: function() {
				// Babyz has an additional block of data we'll skip
				return this.version === 14 /* BHD_VERSION_BABYZ */ ? 160 : 0;
			}
		})
		
		.uint16("animationCount")
		.array("animationEndOffset", {
			type: "uint16le",
			length: "animationCount"
		}),
	
	BHTBallPosition = new Parser()
		.endianess("little")
		.int16("x")
		.int16("y")
		.int16("z")
		.uint16("q1") //Ball size delta? Fuzz value? Who knows?
		.uint16("q2");

	BHTFrameHeader = numBalls => new Parser()
		.int16("minx")
		.int16("miny")
		.int16("minz")
		.int16("maxx")
		.int16("maxy")
		.int16("maxz")
		.uint16("tag")
		.array("balls", {
			type: BHTBallPosition,
			length: numBalls
		});

class PetzBHT {
	constructor(bhd, animIndex, bhtRaw) {
		this.frames = [];
		
		let
			decoder = BHTFrameHeader(bhd.numBalls);
		
		for (let frameOffset of bhd.animationFrameOffsets[animIndex]) {
			this.frames.push(decoder.parse(bhtRaw.slice(frameOffset)));
		}
	}
}

class PetzBHD {
	constructor(bhdRaw) {
		const
			header = BHDHeader.parse(bhdRaw),
			frameData = bhdRaw.slice(header.framesOffset);
		
		// Bring the decoded fields of the header out as fields of this object
		for (let fieldName in header) {
			if (header.hasOwnProperty(fieldName)) {
				this[fieldName] = header[fieldName];
			}
		}
		
		this.animations = [];
		
		for (let i = 0; i < header.animationCount; i++) {
			let
				animationStartOffset, /* Index into the 4-byte entries */
				animationLength,
				animFrameOffsets;
			
			if (i === 0) {
				animationStartOffset = 0;
			} else {
				animationStartOffset = header.animationEndOffset[i - 1];
			}
			
			animationLength = header.animationEndOffset[i] - animationStartOffset;
			
			animFrameOffsets = new Parser()
				.endianess("little")
				.array("frameOffsets", {
					type: "uint32le",
					length: animationLength
				});
			
			animFrameOffsets = animFrameOffsets.parse(frameData.slice(animationStartOffset * 4));
			
			this.animations.push(animFrameOffsets.frameOffsets);
		}
	}
}

class PetzAnimationDecoder {

	constructor(bhdRaw) {
		let
			parsed = new PetzBHD(bhdRaw);
		
		this.numBalls = parsed.numBalls;
		this.ballSizes = parsed.ballSizes;
		this.animationFrameOffsets = parsed.animations;
		this.animations = [];
	}
	
	addAnimation(animIndex, bhtRaw) {
		this.animations[animIndex] = new PetzBHT(this, animIndex, bhtRaw);
	}
}

module.exports = PetzAnimationDecoder;
},{"binary-parser":4}],2:[function(require,module,exports){
(function (Buffer){
require("buffer"); // Load the Buffer polyfill

const
	AnimationDecoder = require("./animation-decoder"),
	
	THREE = require("three");

const
	dogBHD = Buffer("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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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AAAaSQAAVAAAAAoDAADABQAAdggAACwLAADiDQAAmBAAAE4TAAAEFgAAuhgAAHAbAAAmHgAA3CAAAJIjAABIJgAA/igAALQrAABqLgAAIDEAANYzAACMNgAAQjkAAPg7AACuPgAAZEEAABpEAADQRgAAhkkAADxMAABUAAAABgMAALgFAABqCAAAHAsAAM4NAACAEAAAMhMAAOQVAACWGAAASBsAAPodAACsIAAAXiMAABQmAADKKAAAfCsAADIuAADsMAAArjMAAHQ2AAA6OQAAADwAAMY+AACIQQAAPkQAAPBGAACmSQAAXEwAABJPAADIUQAAelQAAFQAAAAGAwAAwAUAAIYIAABMCwAAEg4AANAQAACOEwAASBYAAP4YAACwGwAAah4AACghAADuIwAAtCYAAHopAAA8LAAAVAAAAAYDAAC4BQAAaggAABwLAADODQAAgBAAADITAADkFQAAlhgAAEgbAAD6HQAArCAAAF4jAAAQJgAAVAAAAAYDAAC4BQAAaggAABwLAADODQAAgBAAADITAADkFQAAlhgAAEgbAAD6HQAAVAAAAAYDAADABQAAeggAADQLAADuDQAAoBAAAFoTAAAUFgAAzhgAAIgbAABCHgAA/CAAALYjAABwJgAAKikAAFQAAAAGAwAAuAUAAGoIAAAcCwAAzg0AAIAQAAAyEwAA5BUAAJYYAABIGwAA+h0AAKwgAABeIwAAECYAAMIoAABUAAAABgMAAMgFAACSCAAAXAsAABYOAADIEAAAehMAAFQAAAAGAwAAuAUAAGoIAAAgCwAA0g0AAIQQAABCEwAAABYAAL4YAAB8GwAAOh4AAPggAAC2IwAAdCYAADIpAADwKwAAri4AAGwxAAAqNAAA6DYAAKY5AABkPAAAIj8AAOBBAACeRAAAXEcAABpKAADYTAAAlk8AAFRSAAASVQAA0FcAAIZaAABUAAAAEgMAANAFAACOCAAATAsAAAoOAADIEAAAhhMAAEQWAAACGQAAwBsAAH4eAAA8IQAA+iMAALgmAAB2KQAANCwAAPIuAACwMQAAbjQAACw3AADqOQAAqDwAAGY/AABUAAAAEgMAANAFAACOCAAATAsAAAoOAADIEAAAhhMAAEQWAAACGQAAwBsAAH4eAAA8IQAA+iMAALgmAABUAAAAEgMAANAFAACOCAAATAsAAAoO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AABUAAAABgMAALgFAABqCAAAHAsAAM4NAACAEAAAMhMAAOQVAACWGAAASBsAAPodAACsIAAAXiMAABAmAADCKAAAdCsAAFQAAAAOAwAAyAUAAIIIAAA8CwAA9g0AALAQAABqEwAAJBYAAN4YAACYGwAAUh4AAAwhAADGIwAAgCYAADopAAD0KwAAri4AAGgxAABUAAAABgMAALgFAABqCAAAHAsAAM4NAACAEAAAMhMAAOQVAABUAAAABgMAAMAFAAB6CAAANAsAAO4NAACgEAAAUhMAAAQWAAC2GAAAaBsAABoeAADMIAAAfiMAAFQAAAAGAwAAwAUAAHoIAAA0CwAA7g0AAKgQAABiEwAAFBYAAM4YAACAGwAAMh4AAOQgAACWIwAASCYAAPooAABUAAAABgMAAMAFAAB6CAAANAsAAO4NAACgEAAAUhMAAAQWAAC2GAAAaBsAABoeAADMIAAAfiMAAFQAAAAGAwAAwAUAAHoIAAA0CwAA7g0AAKgQAABiEwAAFBYAAM4YAACAGwAAMh4AAOQgAACWIwAASCYAAPooAABUAAAABgMAAMAFAAB6CAAANAsAAO4NAACoEAAAYhMAABwWAADWGAAAiBsAADoeAADsIAAAniMAAFAmAABUAAAABgMAALgFAABqCAAAHAsAAM4NAACAEAAAMhMAAOQVAACWGAAASBsAAPodAABUAAAABgMAALgFAABqCAAAHAsAAM4NAACAEAAAMhMAAOQVAACWGAAASBsAAPodAACsIAAAXiMAABAmAABUAAAABgMAALgFAABqCAAAHAsAAM4NAACAEAAAMhMAAOQVAACWGAAASBsAAPodAACsIAAAXiMAABAmAADCKAAAdCsAACYuAADYMAAAijMAADw2AADuOAAAoDsAAFI+AAAEQQAAtkMAAGhGAAAaSQAAzEsAAH5OAAAwUQAA4lMAAJRWAABGWQAA+FsAAKpeAABUAAAABgMAALgFAABqCAAAHAsAAM4NAACAEAAAMhMAAOQVAACWGAAASBsAAPodAACsIAAAVAAAAA4DAADIBQAAgggAADwLAAD2DQAAsBAAAGoTAAAkFgAA3hgAAJgbAABSHgAADCEAAMYjAABUAAAABgMAALgFAABqCAAAHAsAAM4NAACAEAAAMhMAAOQVAACWGAAASBsAAPodAACsIAAAXiMAABAm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AAAukAAA5JIAAJqVAABQmAAABpsAALydAAByoAAAKKMAAN6lAACUqAAARqsAAPitAACqsAAAXLMAAA62AADAuAAAcrsAACS+AABUAAAACgMAAMAFAAB2CAAALAsAAOINAACYEAAAThMAAAQWAAC6GAAAcBsAACYeAADcIAAAkiMAAEgmAAD+KAAAtCsAAGouAAAgMQAA1jMAAIw2AABCOQAA9DsAAKY+AABcQQAAEkQAAMhGAAB+SQAANEwAAOpOAACgUQAAVlQAAAxXAADCWQAAeFwAAC5fAADkYQAAmmQAAFBnAAAGagAAvGwAAHJvAAAocgAA3nQAAJR3AABKegAAAH0AALZ/AABsggAAIoUAANSHAABUAAAABgMAALgFAABqCAAAHAsAAM4NAACAEAAAMhMAAOQVAACWGAAASBsAAPodAACsIAAAXiMAABAmAADCKAAAdCsAACYuAADYMAAAijMAADw2AADuOAAAoDsAAFI+AAAEQQAAtkMAAGhGAAAaSQAAzEsAAH5OAABUAAAABgMAALgFAABqCAAAHAsAAM4NAACAEAAAMhMAAOQVAACWGAAASBsAAPodAACsIAAAXiMAABAmAADCKAAAdCsAACYuAADYMAAAijMAADw2AADuOAAAoDsAAFI+AAAEQQAAVAAAAAYDAAC4BQAAaggAABwLAADODQAAgBAAADITAADkFQAAlhgAAEgbAAD6HQAArCAAAF4jAAAQJgAAwigAAHQrAAAmLgAA2DAAAIozAAA8NgAA7jgAAFQAAAAGAwAAuAUAAGoIAAAcCwAAzg0AAIAQAAAyEwAA5BUAAJYYAABIGwAA+h0AAKwgAABeIwAAECYAAMIoAAB0KwAAJi4AANgwAACKMwAAPDYAAO44AABUAAAABgMAALgFAABqCAAAHAsAAM4NAACAEAAAMhMAAOQVAACWGAAASBsAAPodAACsIAAAXiMAABAmAADCKAAAdCsAACYuAABUAAAABgMAALgFAABqCAAAHAsAAM4NAACAEAAAMhMAAOQVAACWGAAASBsAAPodAACsIAAAXiMAABAmAADCKAAAdCsAACYuAADYMAAAijMAADw2AADuOAAAoDsAAFI+AAAEQQAAtkMAAGhGAAAaSQAAzEsAAH5OAAAwUQAA4lMAAJRWAABGWQAA+FsAAKpeAABcYQAADmQAAMBm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","base64"),
	
	// Have to write these out explicitly so that brfs's static transformation can catch them for us
	BHTs = [
		Buffer("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","base64"),
		Buffer("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","base64"),
		Buffer("MDIAAA8AUEZNX1tWNC4wMTVdIChjKSAxOTk5IFRoZSBMZWFybmluZyBDb21wYW55IFByb3BlcnRpZXMsIEluYy4gKEhpIE1vbSwgaW5kZWVkISkAtv8d/7j+TAACAJYABQAkANf/VwAAAAAADABC/4D/AAAAABoARf96/wAAAAAlAFP/hv8AAAAAMwBD/63/AAAAACIAPP+f/wAAAAAZAEP/mv8AAAAALACq/9v/AAAAABMAWP9z/wAAAAAuAPH/x/8AAAAAPAD1/8n/AAAAAEEA8v/V/wAAAAApAO3/UAAAAAAAMADs/9n/AAAAABIAXP9n/wAAAAANAIr/Zv8AAAAAKAC0/z8AAAAAAAUAgP9Q/wAAAAAjAIX/xP8AAAAAGQCM/0YAAAAAACMA9f8+AAAAAAAxAPP/PAAAAAAAOgDz/0YAAAAAACkA0P/e/wAAAADV/9f/SQAAAAAA8/9D/4H/AAAAAOT/Rv97/wAAAADa/1T/hv8AAAAAy/9H/6z/AAAAANv/PP+g/wAAAADl/0P/nP8AAAAA2P+t/9f/AAAAAO3/W/9y/wAAAADV//P/sv8AAAAAxv/2/7T/AAAAAMH/9P/A/wAAAADS/+7/QAAAAAAA0//u/8T/AAAAAO3/X/9m/wAAAAD1/4r/Zv8AAAAA1v+w/z8AAAAAAPv/gP9Q/wAAAADf/4j/w/8AAAAA4/+I/0EAAAAAANf/9f8uAAAAAADK//T/LAAAAAAAwf/0/zYAAAAAAN3/1f/S/wAAAAD+/5L///8AAAAA/f+G/zgAAAAAAAAAi//L/wAAAAAAAJf/d/8AAAAA/v9k/5X/AAAAAAIAd/+Y/wAAAAD//3T/sv8AAAAAAQCH/1T/AAAAAAAAfP9u/wAAAAABAG3/YAAAAAAAAABi/3kAAAAAAP//Uv+KAAAAAAAAAD7/jgAAAAAAAAAu/4IAAAAAAAAAJP9vAAAAAAABAIP/e/8AAAAAAACJ/3H/AAAAAAAA7P/M/gAAAAAAAN7/+f4AAAAAAQA2AAMAtv8W/7j+TAACAJEAAAAkANX/UgAJ/gEADABI/4X/AgAAABoASv9//wIAAAAlAFr/iv8CAAAANQBW/7D/EwH8ACUASP+o/xIC/QAbAEz/n/8DA/4ALQCq/+P/+wABABMAXf93/wIAAAAuAPH/x/8AAAAAPAD1/8n/AAAAAEEA8v/V/wAAAAApAO3/UAAAAAAAMADs/9n/AAAAABIAYf9r/wIAAAAOAIv/Z/8EAAQAKACv/0QA//4AAAUAgP9S/wQABAAjAIr/x/8AAAQAFQCI/0sA+QL5ACMA9f8+AAAAAAAxAPP/PAAAAAAAOgDz/0YAAAAAACkA0f/h/wUA/wDV/9f/SAAGAAAA8/9J/4b/AgAAAOT/TP+A/wIAAADa/1r/iv8CAAAAyf9U/6v/B/oEANn/Rv+j/wv7AgDk/0v/nv8D+gIA1/+x/97//QL+AO3/YP92/wIAAADV//P/sv8AAAAAxv/2/7T/AAAAAMH/9P/A/wAAAADS/+7/QAAAAAAA0//u/8T/AAAAAO3/ZP9p/wIAAAD2/43/Zv8EAAQA1v+w/0UA/AAAAPv/gf9S/wQABADe/47/x//+APwA6P+I/0cA8fsJANf/9f8uAAAAAADK//T/LAAAAAAAwf/0/zYAAAAAANz/2P/V/wMCAQD+/5P/AgAAAAAA/f+B/zwA/AAAAAAAkv/P//wAAAAAAJ7/ev//AAAA/v9r/5j/AgAAAAIAfv+a/wQAAAD//3z/tP8CAAAAAgCI/1X/BAAEAAAAf/9v/wQAAAABAGT/YAD8AAAAAABX/3gA/AAAAP//Rf+HAPwAAAAAADD/iQD6AAAA//8j/3oA+AAAAAAAHf9kAPcAAAABAIv/ff//AAAAAACR/3T//wAAAAAA7P/M/gAAAAAAAN7/+f4AAAAAAQA2AAMAtv8R/7j+TAACAIkAAAAkANP/TgAQAAAADABP/4r/BAAAABoAUf+E/wQAAAAlAGH/j/8EAAAANQBq/63/KQD3ACcAWf+u/ycA+AAcAFX/o/8HBvsALQCs/+n/9/8CABMAZP98/wQAAAAuAPH/x/8AAAAAPAD1/8n/AAAAAEEA8v/V/wAAAAApAO3/UAAAAAAAMADs/9n/AAAAABIAZ/9v/wQAAAAPAIz/Z/8IAQgAKACu/0cA/AABAAUAgP9U/wgBCAAjAJD/yv8AAAgAEgCF/1EA6gjzACMA9f8+AAAAAAAxAPP/PAAAAAAAOgDz/0YAAAAAACkA0f/h/wz//wDU/9b/RgAE9wAA8/9Q/4v/BAAAAOT/U/+F/wQAAADa/2H/j/8EAAAAyP9i/6f/DfQKANj/Uf+l/xb2BwDk/1T/of8H8wMA1/+1/+T/+wX9AO3/Zv96/wQAAADV//P/sv8AAAAAxv/2/7T/AAAAAMH/9P/A/wAAAADS/+7/QAAAAAAA0//u/8T/AAAAAOz/af9t/wQAAAD3/5H/Zv8IAQgA1/+v/0MA+/f+APv/gv9T/wgBCADe/5T/yv/9AfkA7P+E/1AA2vIKANf/9f8uAAAAAADK//T/LAAAAAAAwf/0/zYAAAAAANz/2//W/wgFAQD+/5T/BAAAAAAA/f98/z0A9wAAAAAAmv/T//cAAAD//6f/ff/+AAAA/v9z/5z/BAAAAAIAhf+c/wcAAAD//4b/t/8EAAAAAgCI/1b/CAEIAAAAgv9x/wcAAAABAFr/XgD3AAAAAABL/3QA9wAAAP//N/+BAPcAAAAAACL/fwD0AAAA//8Y/24A7/8BAAAAGP9YAO3/AQABAJT/f//+AAAAAACZ/3b//gAAAAAA7P/M/gAAAAAAAN7/+f4AAAAABQAwAP//MgD//zYAAwA/AAcAQAAIALb/C/+4/kwAAgCEAAAAJADT/04AEf8BAAwAVv+R/wYAAAAaAFf/i/8GAAAAJQBo/5X/BgAAADQAeP+q/zr79AAoAGf/sv83/fUAHQBe/6n/CQn5AC0Ar//w//X+AwATAGr/gf8GAAAALgDx/8f/AAAAADwA9f/J/wAAAABBAPL/1f8AAAAAKQDt/1AAAAAAADAA7P/Z/wAAAAASAGz/df8GAAAAEACO/2v/DAEMACgArf9JAPz/AQAFAID/WP8MAQwAIwCW/87/AAAMABIAhf9RAOoL8wAjAPX/PgAAAAAAMQDz/zwAAAAAADoA8/9GAAAAAAApANL/4/8R//8A1f/U/0gAA/MBAPP/Vv+S/wYAAADk/1n/jP8GAAAA2v9o/5X/BgAAAMn/bP+l/xHuDwDX/1r/qP8f8wsA5P9b/6T/Ce0FANj/u//p//oH/ADt/2z/f/8GAAAA1f/z/7L/AAAAAMb/9v+0/wAAAADB//T/wP8AAAAA0v/u/0AAAAAAANP/7v/E/wAAAADs/2//c/8GAAAA+f+U/2n/DAEMANf/rf9DAPnz/QD7/4P/WP8MAQwA3f+a/8///AH2AOv/gv9QANjuBgDX//X/LgAAAAAAyv/0/ywAAAAAAMH/9P82AAAAAADd/9//2P8MCAEA/v+W/wcAAAAAAP3/eP8/APMAAAAAAKD/2f/zAAAA//+u/4H//QAAAP7/ev+h/wYAAAACAIz/n/8LAAAA//+O/7v/BgAAAAMAif9Z/wwBDAAAAIb/df8LAAAAAQBU/10A8wAAAAAAQv9yAPQAAAD//y7/fADzAAAAAAAZ/3gA7wAAAP//Ev9mAOj/AQAAABb/UADl/wEAAACc/4P//QAAAAAAof97//0AAAAAAOz/zP4AAAAAAADe//n+AAAAAAUAMAD//zIA//82AAMAPwAOAEAAEQC2/wn/uP5MAAIAgwAAACQA0v9OABH/AQAMAFj/lf8GAAAAGgBZ/4//BgAAACUAav+Z/wYAAAAzAHz/qf9C+fMAKABt/7X/Pvv0AB4AYP+s/woK+AAtALD/8//0/gMAEwBr/4b/BgAAAC4A8f/H/wAAAAA8APX/yf8AAAAAQQDy/9X/AAAAACkA7f9QAAAAAAAwAOz/2f8AAAAAEgBu/3n/BgAAABAAjf9u/w4CDgAoAK3/SAD8/wEABQB//1z/DgIOACMAmP/R/wD/DQASAIT/UQDqDfMAIwD1/z4AAAAAADEA8/88AAAAAAA6APP/RgAAAAAAKQDS/+T/FP//ANX/0/9HAAP1AADz/1j/lv8GAAAA5P9b/5D/BgAAANr/av+Z/wYAAADK/2//pf8T6xEA1/9d/6v/IvIOAOX/Xf+o/wrrBQDZ/73/7P/6CPwA7f9u/4P/BgAAANX/8/+y/wAAAADG//b/tP8AAAAAwf/0/8D/AAAAANL/7v9AAAAAAADT/+7/xP8AAAAA7f9w/3f/BgAAAPn/lP9s/w4CDgDY/6z/QwD69f0A+/+D/1v/DgIOAN3/nP/R//wB9QDs/4H/UADY7AYA1//1/y4AAAAAAMr/9P8sAAAAAADB//T/NgAAAAAA3f/f/9j/EAkBAP7/l/8JAAAAAAD9/3b/QADxAAAAAACj/9z/8QAAAAAAsf+F//0AAAD+/3z/pf8GAAAAAgCO/6L/DAAAAP//kf+//wYAAAADAIj/Xf8OAg4AAACH/3j/DAAAAAEAUf9cAPIAAAAAAD//cQDzAAAA//8q/3sA8gAAAAAAFv92AO0AAAAAABD/YwDmAAAAAAAW/04A4QAAAAAAn/+H//0AAAAAAKT/fv/9AAAAAADs/8z+AAAAAAAA3v/5/gAAAAADADYAAwA/ABQAQAAXALb/DP+4/kwAAgCKAAAAJADT/08AEQEAAAwAVf+b/wcAAAAaAFf/lf8HAAAAJQBo/57/BwAAADMAef+y/zv68QAoAGj/vP84/fQAHQBe/7L/Cwn5ACwAsf/1//X+AwATAGn/i/8HAAAALgDx/8f/AAAAADwA9f/J/wAAAABBAPL/1f8AAAAAKQDt/1AAAAAAADAA7P/Z/wAAAAASAGv/fv8HAAAAEACL/3P/DwIOACcArv9JAPwCAQAFAHz/Yf8PAg4AIwCX/9T///8OABIAhf9TAOkP9AAjAPX/PgAAAAAAMQDz/zwAAAAAADoA8/9GAAAAAAApANT/5f8T//8A1f/U/0gABfYAAPP/Vv+c/wcAAADk/1n/lv8HAAAA2v9o/57/BwAAAMn/bf+v/xPvDgDX/1v/s/8f8wsA5P9c/6//C+4EANj/vv/t//sI/ADt/2z/if8HAAAA1f/z/7L/AAAAAMb/9v+0/wAAAADB//T/wP8AAAAA0v/u/0AAAAAAANP/7v/E/wAAAADt/27/fP8HAAAA+f+S/3D/DwIOANj/rf9FAPv3/QD7/4D/YP8PAg4A3f+c/9P//QH1AO3/g/9SANrsBwDX//X/LgAAAAAAyv/0/ywAAAAAAMH/9P82AAAAAADd/+D/2P8QCAEA/v+a/wwAAAAAAP3/eP9DAPIAAAAAAKP/3v/yAAAAAACv/4r//AAAAP7/e/+q/wcAAAACAI3/p/8MAAAA//+P/8P/BwAAAAMAhv9i/w8CDgAAAIX/ff8MAAAAAQBU/2AA9QAAAAAARP92APYAAAAAADD/ggD1AP8AAgAb/38A8QH+AAEAE/9tAOoD/gAAABr/WADgBf0AAACd/4v//AAAAAAAov+D//wAAAAAAOz/zP4AAAAAAADe//n+AAAAAAUAMAABADIAAQA2AAMAPwAWAEAAGQC2/xP/uP5MAAIAlAAAACQA0/9QABIE/wAMAFD/of8IAAAAGgBR/5v/CAAAACUAYv+k/wgAAAA0AG//wf8p//EAJwBc/8P/KAH3ABwAWP+5/wsH+wAsALL/9P/3/gMAEwBj/5H/CAAAAC4A8f/H/wAAAAA8APX/yf8AAAAAQQDy/9X/AAAAACkA7f9QAAAAAAAwAOz/2f8AAAAAEwBk/4T/CAAAABAAhf94/xECDQAnAK7/SQD9BAEABQB2/2f/EQINACMAlP/U//z+DwASAIb/VQDpEfYAIwD1/z4AAAAAADEA8/88AAAAAAA6APP/RgAAAAAAKQDV/+f/EP4AANX/1v9IAAb6/wDz/1H/ov8IAAAA5f9T/5z/CAAAANr/Yv+k/wgAAADI/2T/v/8R9ggA2P9U/77/GPcFAOT/V/+5/wz1AwDY/73/7P/9B/wA7f9l/47/CAAAANX/8/+y/wAAAADG//b/tP8AAAAAwf/0/8D/AAAAANL/7v9AAAAAAADT/+7/xP8AAAAA7f9n/4L/CAAAAPn/jP91/xECDQDY/6//RgD8+v4A+/95/2b/EQINAN3/mv/T//8A9QDu/4T/VADc6wgA1//1/y4AAAAAAMr/9P8sAAAAAADB//T/NgAAAAAA3f/f/9f/EAgBAP7/nf8OAAAAAAD9/3v/RQD0AAAAAACh/97/9AAAAAAAqv+P//wAAAD//3X/r/8IAAAAAgCH/63/DAAAAP//i//I/wgAAAADAH//Z/8RAg0AAACA/4P/DAAAAAEAWP9lAPsAAAABAEz/fQD+Af8AAQA7/4wA/AH/AAQAJf+MAPgC+wAEABr/fQDyCPkA//8f/2cA4g37AAAAmP+R//wAAAAAAJ3/iP/8AAAAAADs/8z+AAAAAAAA3v/5/gAAAAAFADAAAwAyAAMANgADAD8AFQBAABkAtv8b/7j+TAACAKEAAAAkANP/UAASBv4ADABJ/6j/CQAAABoAS/+h/wkAAAAlAFz/qv8JAAAAMwBh/9D/FAHzACYAUP/K/xgC+gAbAFL/wf8MBP0ALACx//P/+v0DABMAXP+W/wkAAAAuAPH/x/8AAAAAPAD1/8n/AAAAAEEA8v/V/wAAAAApAO3/UAAAAAAAMADs/9n/AAAAABMAXf+K/wkAAAAQAID/ff8TAg0AJgCu/0sA/QYCAAUAcP9t/xMCDQAjAJD/1f/6/g8AEgCG/1gA6RP3ACMA9f8+AAAAAAAxAPP/PAAAAAAAOgDz/0YAAAAAACkA1v/o/w7+AADV/9b/SAAI+/8A8/9K/6j/CQAAAOX/Tf+i/wkAAADa/1z/qv8JAAAAyv9c/8//Dv0CANr/TP/I/xD9AQDl/1H/w/8M/QEA1/+6/+v//gX8AO3/Xv+U/wkAAADV//P/sv8AAAAAxv/2/7T/AAAAAMH/9P/A/wAAAADS/+7/QAAAAAAA0//u/8T/AAAAAO3/YP+H/wkAAAD5/4b/ev8TAg0A2P+v/0gA/vv+APv/c/9s/xMCDQDd/5f/1P8BAPUA7v+G/1YA3esIANf/9f8uAAAAAADK//T/LAAAAAAAwf/0/zYAAAAAAN3/3P/X/xAGAgD+/5//EAAAAAAA/f98/0cA9QAAAAAAnv/e//UAAAAAAKX/lf/8AAAA//9v/7T/CQAAAAIAgv+y/wwAAAD//4b/zf8JAAAAAwB5/2z/EwINAAAAev+I/wwAAAABAFz/aQACAAAAAQBV/4MABQH/AAIARv+VAAIC/gAGADH/mQAAA/kABwAi/40A/Az1AP//I/94AOYW+wAAAJP/lv/8AAAAAACY/43//AAAAAAA7P/M/gAAAAAAAN7/+f4AAAAABQAwAAUAMgAEADYAAwA/ABQAQAAXALb/Hv+4/kwAAgCpAAAAJADU/1EAEgb/AAwASP+r/woAAAAaAEn/pP8KAAAAJQBa/63/CgAAADIAWP/b/wMA9AAkAEz/zv8N/vwAGgBR/8b/DP/+ACwAsv/z//r+AgATAFr/mf8KAAAALgDx/8f/AAAAADwA9f/J/wAAAABBAPL/1f8AAAAAKQDt/1AAAAAAADAA7P/Z/wAAAAATAFv/jf8KAAAAEAB+/3//EwIMACYAr/9LAP0GAgAFAG7/b/8TAgwAIwCR/9b/+f4NABEAh/9ZAOoT9wAjAPX/PgAAAAAAMQDz/zwAAAAAADoA8/9GAAAAAAAqANf/6f8N/gAA1f/Y/0gACPv/APP/Sf+r/woAAADl/0v/pf8KAAAA2v9b/6z/CgAAAMv/Wf/V/wwAAADb/0r/zf8MAAAA5f9Q/8f/DAAAANj/uv/r//4F/ADt/13/l/8KAAAA1f/z/7L/AAAAAMb/9v+0/wAAAADB//T/wP8AAAAA0v/u/0AAAAAAANP/7v/E/wAAAADt/17/iv8KAAAA+f+F/33/EwIMANj/sf9IAP78/gD7/3H/bv8TAgwA3f+W/9T/AQD2AO7/h/9XAN7rCQDX//X/LgAAAAAAyv/0/ywAAAAAAMH/9P82AAAAAADd/9z/1/8QBgIA/v+h/xEAAAAAAP3/fv9IAPYAAAAAAJ3/3//2AAAAAACj/5f//AAAAP//bv+3/woAAAACAIH/tf8MAAAA//+F/8//CgAAAAMAd/9v/xMCDAAAAHn/iv8MAAAAAQBg/2sABwAAAAEAW/+GAAkB/wACAE7/mQAHAf0ABwA7/6EACAP4AAgAKf+ZAAgN8gD+/yX/hQDtGvsAAACR/5n//AAAAAAAlv+Q//wAAAAAAOz/zP4AAAAAAADe//n+AAAAAAUAMAAGADIABQA2AAMAPwAUAEAAFwC2/yn/uP5MAAMArQAAACUA0P9XAPcAAQAMAEn/jv8QAAAAGgBJ/4f/EAAAACUAW/+N/xAAAAAwAFn/yf/k//UAIwBY/7b/EPL7ABsAXP+s/xTy/QAtAKv/4P/3/wEAEwBa/3j/EAAAAC4A8f/H//8AAAA8APX/yf//AAAAQQDz/9b//wAAACkA5v9RAPEAAAAwAOz/2f//AAAAEwBa/2v/EAAAAA0Aff9X/xj/AAAoALH/NgABAAEABgBo/0r/GP8AACMAjv/A//v/BwAXAIr/QQD6B/4AIwD0/0IA8QAAADEA8/9AAPEAAAA6AO//SQDxAAAAKQDR/+H/Av8AANb/1f9GAPcCAADz/0r/jv8QAAAA5f9L/4f/EAAAANr/XP+N/xAAAADO/1//wP/7Av8A3f9T/7L/FQP+AOf/V/+q/xMD/gDa/6//3P/4B/4A7f9c/3X/EAAAANX/9P+0//wAAADG//f/tv/8AAAAwf/0/8L//AAAANL/7P9BAPwAAADT/+3/xf/8AAAA7f9c/2j/EAAAAPX/e/9X/xj/AADW/7D/MQAEAQAA/P9o/0r/GP8AAN3/j//A//4B9gDo/4r/PQDz+QUA1//2/y8A/AAAAMr/9f8tAPwAAADB//P/NwD8AAAA3v/W/9P/AwgBAP7/nf/7/wAAAAD9/4X/NAD7AAAAAACX/8j/+wAAAAAAp/9w//wAAAD//3L/kv8QAAAAAgCE/43/EwAAAP//hP+s/xAAAAACAHD/Sf8Y/wAAAAB1/2X/EwAAAAEAav9aAA0AAAABAGj/dQANAQAAAQBg/4sAEAD9AAQAVP+cAB8A+wAGAET/pgAzB/UA//8w/54AGRP5AAAAk/9x//wAAAAAAJv/Z//8AAAAAADs/8z+AAAAAAAA3v/5/gAAAAAFADAABAAyAAMANgADAD8AFABAABcAtv89/7j+TAADALkAAAAnAMb/VQDhAAIADABI/3D/FgAAABoAR/9p/xYAAAAlAFr/bP8WAAAALABh/6j/ygPvACAAZ/+W/xjp+AAaAGj/i/8g5/wAKwCt/8b/+QH/ABMAVf9R/xYAAAAuAPP/x//+AAAAPAD2/8n//gAAAEEA8//W//4AAAApAN3/UQDhAAAAMADt/9n//gAAABMAUv9F/xYAAAAIAHL/Kv8e/vIAKgC5/ycA/gABAAUAW/8i/x7+8gAiAI7/qf/9APwAGwCR/yoAAgEGACMA7/9JAOEAAAAxAPD/RwDhAAAAOgDo/04A4QAAACkA0f/U//QBAADV/9D/RQDn/v8A8/9J/3D/FgAAAOT/Sf9p/xYAAADa/1r/bP8WAAAA0/9l/6P/6wUDAOH/XP+S/yAG+wDp/17/iP8bBvsA3f+o/8f/9gn/AOz/V/9P/xYAAADV//T/tv/3AAAAxv/3/7j/9wAAAMH/8v/E//cAAADS/+n/QgD3AAAA0//r/8b/9wAAAOz/VP9C/xYAAADx/2v/L/8e/vIA2f+1/yAAAv0BAPv/WP8k/x7+8gDd/4r/qf/8AfgA4v+N/yUAAf/8ANf/9f8yAPcAAADK//T/MAD3AAAAwf/x/zkA9wAAAOD/0P/L//UJ/wD+/5n/4f8AAAAA/f+P/xsAAAAAAAAAkP+u/wAAAAAAAKb/Q//9AAAA/v90/2n/FgAAAAIAhP9g/xwAAAD//4L/iP8WAAAA/v9h/yH/Hv7yAAAAav87/xwAAAABAHj/RgATAAAAAAB5/2IAEQABAP//d/94ABr+/gAAAHX/jAA1AQAAAABz/58AWQn4AP3/aP+yAFQM9wAAAI//RP/9AAAAAACa/zX//QAAAAAA7P/M/gAAAAAAAN7/+f4AAAAADQABAAIAAgACAAMAAgAIAAEADgABABkAAgAaAAIAGwACACAAAQAmAAEANgADAD8AFABAABcAtv9A/7j+TAACALoAAAAmAMj/VQDl/wEADABL/3L/FQAAABoASv9r/xUAAAAlAF3/b/8VAAAAKwBp/63/2vzxACEAa/+Z/x7r/AAbAGr/jf8f6/sALACs/8r/9wEAABMAWf9V/xUAAAAuAPP/xv/+AAAAPAD2/8j//gAAAEEA8//V//4AAAApAN7/UADkAAAAMADt/9j//gAAABMAVv9H/xUAAAAJAHb/L/8d//QAKgC2/ygA/v8BAAUAX/8l/x3/9AAiAJD/q//+AP4AGgCP/ywAAAAEACMA8P9HAOQAAAAxAPD/RQDkAAAAOgDp/0wA5AAAACkA0f/V//cBAADV/9H/RADp/v8A8/9M/3L/FQAAAOT/TP9s/xUAAADa/13/b/8VAAAA0P9q/6L/8gIAAN//X/+T/yUC/ADo/2D/iv8bA/wA3f+p/8v/9Qn/AOz/W/9S/xUAAADV//T/tf/4AAAAxv/2/7f/+AAAAMH/8v/D//gAAADS/+n/QQD4AAAA0//r/8X/+AAAAOz/WP9F/xUAAADx/3D/Mv8d//QA2P+0/yIAAv4BAPv/XP8n/x3/9ADd/4z/q//7AfcA4/+M/ycA/v/+ANf/9P8xAPgAAADK//T/LwD4AAAAwf/x/zgA+AAAAN//0f/N//cK/wD+/5j/4/8AAAAA/f+N/x4A/gAAAAAAk/+w//4AAAD//6n/R//9AAAA/v93/23/FQAAAAIAh/9k/xsAAAD//4X/i/8VAAAA/v9l/yT/Hf/0AP//bf8//xsAAAABAHT/SAAPAAAAAABy/2MADQABAP//bf95ABb+/wD//2j/jAAtAQEA/v9h/54ATgr7AP3/WP+zAFwG+QAAAJL/SP/9AAAAAACd/zr//QAAAAAA7P/M/gAAAAAAAN7/+f4AAAAADwABAAIAAgACAAMAAgAIAAEADgABABkAAgAaAAIAGwACACAAAQAmAAEAMAD//zIA//82AAMAPwAUAEAAFwC2/xH/uP5MAAIAmQAAACQAzf9VAPX9AAAMAFL/gf8QAAAAGgBS/3r/EAAAACUAZP+A/xAAAAAyAHr/t/8E+f0AJQBu/6j/LPX/AB4Aaf+c/xj3+QAtAKv/3P/zAAEAEwBj/2j/EAAAAC4A8v/H//4AAAA8APb/yf/+AAAAQQDz/9b//gAAACkA4/9RAO4AAAAwAO3/2f/+AAAAEwBi/1v/EAAAAAwAgv9H/xgA/gApAK//NAD//QEABQBu/zr/GAD+ACMAk/+5//4ABQAXAIn/OwD5A/wAIwDy/0MA7gAAADEA8v9BAO4AAAA6AO3/SgDuAAAAKQDR/9z/AwD/ANX/0/9HAPP+/wDz/1P/gf8QAAAA5P9U/3v/EAAAANr/Zf+A/xAAAADI/27/pf8B9v4A2v9g/5//J/oCAOb/Yf+Y/xb5AADc/67/2//zC/4A7P9l/2X/EAAAANX/9P+0//sAAADG//b/tv/7AAAAwf/z/8P/+wAAANL/6/9BAPsAAADT/+z/xf/7AAAA7P9k/1j/EAAAAPT/gf9I/xgA/gDX/7D/LgAA/gAA+v9t/zv/GAD+AN3/k/+6//kC9QDn/4n/OADw+gYA1//1/zAA+wAAAMr/9P8uAPsAAADB//L/OAD7AAAA4P/V/9L/AwsAAP7/mP/y/wAAAAD9/4X/LAD5AAAAAACa/8H/+QAAAP//sP9h//wAAAD+/33/hP8QAAAAAgCN/33/FgAAAP//jP+g/xAAAAAAAHb/Ov8YAP4AAAB6/1X/FgAAAAEAZv9SAAMAAAAAAF3/awACAAEA//9R/34ACP//AP//Qf+MABQAAQD9/y7/kAAlBwAA+/8Y/5IAMAX/AAAAm/9h//wAAAAAAKX/Vf/8AAAAAADs/8z+AAAAAAAA3v/5/gAAAAAPAAEAAQACAAEAAwABAAgAAQAOAAEAGQABABoAAQAbAAEAIAABACYAAQAwAP//MgD//zYAAwA/ABUAQAAZALb/Bf+4/kwAAgCHAAAAJADQ/04ADgABAAwAV/+Q/woAAAAaAFj/if8KAAAAJQBq/5L/CgAAADYAgf+u/y/++AAoAG//sv86+vgAHgBl/6j/DwT4AC0Arv/t//P+AwATAGv/ff8KAAAALgDx/8f//wAAADwA9f/J//8AAABBAPP/1v//AAAAKQDp/1EA+gAAADAA7P/Z//8AAAATAGz/cP8KAAAADwCL/2L/EgEJACcAq/9FAPsAAQAFAHv/Uf8SAQkAIwCX/8r///8LABEAg/9NAOgM9AAjAPT/PwD6AAAAMQDz/z0A+gAAADoA8f9HAPoAAAApANL/4f8P//8A1P/V/0cAAvMAAPP/WP+R/woAAADk/1r/iv8KAAAA2v9q/5L/CgAAAMj/cP+m/w3sCQDY/1//qP8l9AoA5f9g/6T/D+8EANr/uf/n//cJ/ADs/23/ev8KAAAA1f/z/7P//gAAAMb/9v+1//4AAADB//T/wf/+AAAA0v/s/0EA/gAAANP/7f/F//4AAADs/27/bv8KAAAA9/+Q/2D/EgEJANf/rv9BAPn0/QD7/33/Uf8SAQkA3f+a/8r/+wL1AOz/g/9NANfvBgDX//X/LwD+AAAAyv/0/y0A/gAAAMH/8/83AP4AAADe/97/2P8KCgAA/v+Y/wIAAAAAAP3/e/86APMAAAAAAKH/0//zAAAA//+0/3v/+wAAAP7/f/+b/woAAAACAJD/l/8QAAAA//+R/7X/CgAAAAIAhP9S/xIBCQAAAIT/bf8QAAAAAQBX/1oA9wAAAAAASP9wAPgAAAD//zb/fgD5AAAAAAAh/38A+gAAAP//E/9xAPoCAQD+/wz/XAD6AgEAAACh/3z/+wAAAAAAqP9y//sAAAAAAOz/zP4AAAAAAADe//n+AAAAAAkAAgABAAMAAQAaAAEAGwABADAA//8yAP//NgADAD8AFgBAABkAtv8J/7j+TAABAIMAAAAkANL/TgAR/wEADABY/5X/BgAAABoAWf+P/wYAAAAlAGr/mf8GAAAAMwB8/6n/QvnzACgAbf+1/z779AAeAGD/rP8KCvgALQCw//P/9P4DABMAa/+G/wYAAAAuAPH/x/8AAAAAPAD0/8n/AAAAAEEA8v/V/wAAAAApAO3/UAAAAAAAMADs/9n/AAAAABIAbv95/wYAAAAQAI3/bv8OAg4AKACt/0gA/P8BAAUAf/9c/w4CDgAjAJj/0f8A/w0AEgCE/1EA6g3zACMA9P8+AAAAAAAxAPP/PAAAAAAAOgDz/0YAAAAAACkA0v/k/xT//wDV/9P/RwAD9QAA8/9Y/5b/BgAAAOT/W/+Q/wYAAADa/2r/mf8GAAAAyv9v/6X/E+sRANf/Xf+r/yLyDgDl/13/qP8K6wUA2f+9/+z/+gj8AO3/bv+D/wYAAADV//L/sv8AAAAAxv/1/7T/AAAAAMH/9P/A/wAAAADS/+3/QAAAAAAA0//t/8T/AAAAAO3/cP93/wYAAAD5/5T/bP8OAg4A2P+s/0MA+vX9APv/g/9b/w4CDgDd/5z/0f/8AfUA7P+B/1AA2OwGANf/9f8uAAAAAADK//T/LAAAAAAAwf/z/zYAAAAAAN3/3//Y/xAJAQD+/5f/CQAAAAAA/f92/0AA8QAAAAAAo//c//EAAAAAALH/hf/9AAAA/v98/6X/BgAAAAIAjv+i/wwAAAD//5H/v/8GAAAAAwCI/13/DgIOAAAAh/94/wwAAAABAFH/XADyAAAAAAA//3EA8wAAAP//Kv97APIAAAAAABb/dgDtAAAAAAAQ/2MA5gAAAAAAFv9OAOEAAAAAAJ//h//9AAAAAACk/37//QAAAAAA7P/M/gAAAAAAAN7/+f4AAAAAAwA2AAMAPwAUAEAAFwC2/w3/uP5MAAIAhwAAACQA0/9OABEAAAAMAFP/kP8FAAAAGgBV/4r/BQAAACUAZf+U/wUAAAA0AHP/rf80/fUAJwBh/7P/Mf/2AB0AWv+o/wgI+gAtAK7/7v/2/wMAEwBn/4H/BQAAAC4A8f/H/wAAAAA8APX/yf8AAAAAQQDz/9X/AAAAACkA7v9QAAAAAAAwAOz/2f8AAAAAEgBq/3X/BQAAABAAjf9r/wsBCwAoAK7/SAD8AAEABQCA/1j/CwELACMAlP/O/wAACwASAIb/UQDqC/MAIwD1/z4AAAAAADEA9P88AAAAAAA6APT/RgAAAAAAKQDS/+P/D///ANX/1f9HAAT1AADz/1T/kf8FAAAA5P9X/4v/BQAAANr/Zf+U/wUAAADJ/2j/p/8S8Q4A1/9W/6n/HPQKAOT/WP+l/wjvBADX/7r/6P/6BvwA7f9q/3//BQAAANX/8/+y/wAAAADG//b/s/8AAAAAwf/0/8D/AAAAANL/7v9AAAAAAADT/+7/xP8AAAAA7f9s/3P/BQAAAPj/kv9q/wsBCwDX/67/QwD69v4A+/+C/1j/CwELAN3/mP/O//0B9wDs/4P/UQDZ7wgA1//1/y0AAAAAAMr/9P8rAAAAAADB//T/NgAAAAAA3f/e/9f/CwcBAP7/lv8HAAAAAAD9/3n/PwD0AAAAAACe/9j/9AAAAAAAqv+A//8AAAD+/3f/of8FAAAAAgCJ/6D/CQAAAP//i/+7/wUAAAADAIn/Wv8LAQsAAACE/3X/CQAAAAEAVv9eAPQAAAAAAEX/dAD1AAAA//8x/38A9QAAAAAAHP98APEAAAAAABT/agDrAAAAAAAY/1QA5wAAAAAAmP+D//8AAAAAAJ3/ev//AAAAAADs/8z+AAAAAAAA3v/5/gAAAAAFAAEA//8ZAP//NgADAD8ADgBAABEAtv8V/7j+TAACAI4AAAAkANX/TwAMAAEADABK/4f/AwAAABoATf+B/wMAAAAlAFz/jP8DAAAANQBd/7D/GgH6ACUATf+r/xkC+wAbAE//of8EBP0ALQCr/+X/+gABABMAYP95/wMAAAAuAPH/x/8AAAAAPAD1/8n/AAAAAEEA8//V/wAAAAApAO3/UAAAAAAAMADs/9n/AAAAABIAY/9t/wMAAAAPAIz/Z/8FAAUAJwCv/0MA/wABAAUAgP9T/wUABQAjAIz/yP8AAAYAEgCI/00A9AXzACMA9f8+AAAAAAAxAPT/PAAAAAAAOgDz/0YAAAAAACkA0f/h/wgA/wDU/9f/RgAG/gAA8/9L/4j/AwAAAOT/Tv+C/wMAAADa/1z/jP8DAAAAyf9Z/6r/CvkGANj/Sf+k/w75AwDk/07/oP8E+AIA1/+z/+D//QP+AO3/Yv94/wMAAADV//P/sv8AAAAAxv/2/7T/AAAAAMH/9P/A/wAAAADS/+7/QAAAAAAA0//u/8T/AAAAAO3/Zv9r/wMAAAD2/47/Z/8FAAUA1v+w/0QA/P7/APv/gf9T/wUABQDe/5D/yP/+APsA6/+I/0kA7PgMANf/9f8tAAAAAADK//T/LAAAAAAAwf/0/zYAAAAAANz/2f/V/wUDAQD+/5T/AwAAAAAA/f+A/zwA+gAAAAAAlf/R//oAAAAAAKH/e///AAAA/v9t/5r/AwAAAAIAgP+b/wUAAAD//4D/tv8DAAAAAgCI/1b/BQAFAAAAgP9w/wUAAAABAGH/YAD6AAAAAABT/3gA+wAAAP//Qf+GAPoAAAAAACz/hgD4AAAAAAAg/3cA9gAAAAAAHP9hAPMAAAABAI7/fv//AAAAAACT/3X//wAAAAAA7P/M/gAAAAAAAN7/+f4AAAAAAwA2AAMAPwAHAEAACAC2/x3/uP5MAAIAlgAGACQA1/9XAAAAAAAMAEL/gP8AAAAAGgBF/3r/AAAAACUAU/+G/wAAAAAzAEP/rf8AAAAAIgA8/5//AAAAABkAQ/+a/wAAAAAsAKr/2/8AAAAAEwBY/3P/AAAAAC4A8f/H/wAAAAA8APX/yf8AAAAAQQDy/9X/AAAAACkA7f9QAAAAAAAwAOz/2f8AAAAAEgBc/2f/AAAAAA0Aiv9m/wAAAAAoALT/PwAAAAAABQCA/1D/AAAAACMAhf/E/wAAAAAZAIz/RgAAAAAAIwD1/z4AAAAAADEA8/88AAAAAAA6APP/RgAAAAAAKQDQ/97/AAAAANX/1/9JAAAAAADz/0P/gf8AAAAA5P9G/3v/AAAAANr/VP+G/wAAAADL/0f/rP8AAAAA2/88/6D/AAAAAOX/Q/+c/wAAAADY/63/1/8AAAAA7f9b/3L/AAAAANX/8/+y/wAAAADG//b/tP8AAAAAwf/0/8D/AAAAANL/7v9AAAAAAADT/+7/xP8AAAAA7f9f/2b/AAAAAPX/iv9m/wAAAADW/7D/PwAAAAAA+/+A/1D/AAAAAN//iP/D/wAAAADj/4j/QQAAAAAA1//1/y4AAAAAAMr/9P8sAAAAAADB//T/NgAAAAAA3f/V/9L/AAAAAP7/kv///wAAAAD9/4b/OAAAAAAAAACL/8v/AAAAAAAAl/93/wAAAAD+/2T/lf8AAAAAAgB3/5j/AAAAAP//dP+y/wAAAAABAIf/VP8AAAAAAAB8/27/AAAAAAEAbf9gAAAAAAAAAGL/eQAAAAAA//9S/4oAAAAAAAAAPv+OAAAAAAAAAC7/ggAAAAAAAAAk/28AAAAAAAEAg/97/wAAAAAAAIn/cf8AAAAAAADs/8z+AAAAAAAA3v/5/gAAAAABADYAAwA=","base64"),
		Buffer("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","base64"),
		Buffer("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","base64"),
		Buffer("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","base64"),
		Buffer("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","base64"),
		Buffer("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","base64"),
		Buffer("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","base64"),
		Buffer("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","base64"),
		Buffer("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","base64"),
		Buffer("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","base64"),
		Buffer("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TQD6AP8ACAAS/3////8FABcAE/95////BQAjACH/hv///wUALgAM/6z///8FAB0ACv+g////BQAVABT/m////wUAKwB4/+L/+QD/ABQAKf91////BQAqAMH/y//5AP8AOADF/83/+QD/AD4Awf/Z//kA/wAnAL3/TAD8AP8ALQC6/9z/+QD/ABQALv9o////BQATAFz/af///wUAJwCC/y8ADAD/AAoAVP9T////BQAiAFr/xP/5AP8AGQBf/0IACwAAACEAxv87APwA/wAuAMb/OQD8AP8ANwDF/0MA/AD/ACYAnv/h/wQA/wDX/6T/PwD5/wEA8P8W/4D///8FAOL/G/96////BQDZ/yr/hf///wUAx/8c/6r///8FANb/E/+f////BQDi/xn/nP///wUA2f97/+H/9wABAOv/Mf9y////BQDY/8L/uP/6AAEAyf/G/7v/+gABAMX/w//H//oAAQDU/7v/OwD9/wEA1v+7/8n/+gABAOv/Nv9l////BQD7/1//aP///wUA2P98/ysAEQABAAAAVf9T////BQDf/1v/xf/3AAEA4/9Y/z0ADgAAANv/xP8pAP3/AQDN/8P/JgD9/wEAxP/C/zAA/f8BAN//o//X/wUAAQD+/2T///8AAAAA/f9b/zgAAAAAAAAAYP/L/wAAAAAHAGz/fP/8/wUA//83/5b///8FAAQASf+a////BQD//0j/sv8DAAAABwBb/1f///8FAAQAT/9w////BQABAEL/YAAAAAAAAABB/3sAEAAAAP//R/+QACcAAAAAAE3/owBFAAAAAABR/7cAZwAAAAAAV//MAHgAAAAGAFn/fv/8/wUABgBf/3b//P8FAAAA7P/M/gAAAAAAAN7/+f4AAAAABQAIAAQADgACACAABAAmAAIANgADAL3/xP64/kAAAQDUAHgAHgB9/z0ACgD9AAUA0f6V/xIABwATAM7+j/8SAAcAIADf/pX/EgAHACoA2P7A/xIABwAaANr+t/8SAAcAEwDj/q//EgAHACcAUf/c//8A+wASAOX+g/8SAAcAIACh/9T/5gP8AC4ApP/Y/+YD/AA0AJv/4f/mA/wAIgCW/zoA8AL+ACQAkv/g/+YD/AASAOT+df8SAAcAEwAO/2L/EgAHACQAVf8uAA0A/QAKAPz+Uv8SAAcAIgAu/8P//wD7ABkAMf9CAAkA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","base64"),
		Buffer("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","base64"),
		Buffer("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","base64"),
		Buffer("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","base64"),
		Buffer("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","base64"),
		Buffer("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","base64"),
		Buffer("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","base64"),
		Buffer("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","base64"),
		Buffer("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","base64"),
	],

	decoder = new AnimationDecoder(dogBHD);

for (let i = 0; i < BHTs.length; i++) {
	decoder.addAnimation(i, BHTs[i]);
}

let
	CAMERA_DISTANCE = 750,
	
	camera, scene, renderer, petGroup,
	mouseX = 0, mouseY = 0,
	displayHalfX = window.innerWidth / 2,
	displayHalfY = window.innerHeight / 2,
	
	ballMeshes = [],
	
	animationStart = Date.now(),
	
	animationIndex = 0,
	animationFrameIndex = 0;

function initScene() {
	camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
	camera.position.z = CAMERA_DISTANCE;
	scene = new THREE.Scene();
	scene.background = new THREE.Color(0xffffff);
	scene.fog = new THREE.Fog(0xffffff, 1, 100000);
	
	let
		material = new THREE.MeshNormalMaterial();
	
	petGroup = new THREE.Group();
	
	animationFrameIndex = 0;
	
	for (let i = 0; i < decoder.numBalls; i++) {
		let
			geometry = new THREE.SphereBufferGeometry(decoder.ballSizes[i] / 2, 16, 16),
			ball = new THREE.Mesh(geometry, material);
		
		ball.position.x = decoder.animations[animationIndex].frames[animationFrameIndex].balls[i].x;
		ball.position.y = -decoder.animations[animationIndex].frames[animationFrameIndex].balls[i].y;
		ball.position.z = decoder.animations[animationIndex].frames[animationFrameIndex].balls[i].z;
		ball.matrixAutoUpdate = false;
		ball.updateMatrix();
		
		ballMeshes.push(ball);
		
		petGroup.add(ball);
	}
	
	scene.add(petGroup);
	
	renderer = new THREE.WebGLRenderer({antialias: true});
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth, window.innerHeight);
	document.getElementById("container").appendChild(renderer.domElement);
	
	document.addEventListener('mousemove', onDocumentMouseMove, false);
	window.addEventListener('resize', onWindowResize, false);
	window.addEventListener('click', e => {
		animationStart = Date.now();
		animationIndex = (animationIndex + 1) % decoder.animations.length;
		animationFrameIndex = -1;
	});
	window.addEventListener("wheel", e => {
		if (e.deltaY > 0) {
			CAMERA_DISTANCE *= 1.2;
		} else {
			CAMERA_DISTANCE /= 1.2;
		}
	});
}

function onWindowResize() {
	let
		displayWidth = renderer.domElement.clientWidth,
		displayHeight = renderer.domElement.clientHeight;
	
	displayHalfX = displayWidth / 2;
	displayHalfY = displayHeight / 2;
	camera.aspect = displayWidth / displayHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(displayWidth, displayHeight);
}

function onDocumentMouseMove(event) {
	mouseX = event.clientX - displayHalfX;
	mouseY = event.clientY - displayHalfY;
}

function animate() {
	requestAnimationFrame(animate);
	render();
}

function render() {
	let
		newFrameIndex = Math.round((Date.now() - animationStart) / 100) % decoder.animations[animationIndex].frames.length;
	
	if (newFrameIndex !== animationFrameIndex) {
		animationFrameIndex = newFrameIndex;
		
		for (let i = 0; i < decoder.numBalls; i++) {
			ballMeshes[i].position.x = decoder.animations[animationIndex].frames[newFrameIndex].balls[i].x;
			ballMeshes[i].position.y = -decoder.animations[animationIndex].frames[newFrameIndex].balls[i].y;
			ballMeshes[i].position.z = decoder.animations[animationIndex].frames[newFrameIndex].balls[i].z;
			
			ballMeshes[i].updateMatrix();
		}
	}
	
	petGroup.rotation.y = mouseX / displayHalfX * Math.PI * 2;
	
	camera.position.y = Math.sin(mouseY / displayHalfY * Math.PI / 2) * CAMERA_DISTANCE;
	camera.position.z = Math.cos(mouseY / displayHalfY * Math.PI / 2) * CAMERA_DISTANCE;
	
	camera.lookAt(scene.position);
	
	renderer.render(scene, camera);
}

initScene();
animate();

}).call(this,require("buffer").Buffer)
},{"./animation-decoder":1,"buffer":6,"three":8}],3:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],4:[function(require,module,exports){
//========================================================================================
// Globals
//========================================================================================

var Context = require("./context").Context;

var PRIMITIVE_TYPES = {
  UInt8: 1,
  UInt16LE: 2,
  UInt16BE: 2,
  UInt32LE: 4,
  UInt32BE: 4,
  Int8: 1,
  Int16LE: 2,
  Int16BE: 2,
  Int32LE: 4,
  Int32BE: 4,
  FloatLE: 4,
  FloatBE: 4,
  DoubleLE: 8,
  DoubleBE: 8
};

var SPECIAL_TYPES = {
  String: null,
  Buffer: null,
  Array: null,
  Skip: null,
  Choice: null,
  Nest: null,
  Bit: null
};

var aliasRegistry = {};
var FUNCTION_PREFIX = "___parser_";

var BIT_RANGE = [];
(function() {
  var i;
  for (i = 1; i <= 32; i++) {
    BIT_RANGE.push(i);
  }
})();

// Converts Parser's method names to internal type names
var NAME_MAP = {};
Object.keys(PRIMITIVE_TYPES)
  .concat(Object.keys(SPECIAL_TYPES))
  .forEach(function(type) {
    NAME_MAP[type.toLowerCase()] = type;
  });

//========================================================================================
// class Parser
//========================================================================================

//----------------------------------------------------------------------------------------
// constructor
//----------------------------------------------------------------------------------------

var Parser = function() {
  this.varName = "";
  this.type = "";
  this.options = {};
  this.next = null;
  this.head = null;
  this.compiled = null;
  this.endian = "be";
  this.constructorFn = null;
  this.alias = null;
};

//----------------------------------------------------------------------------------------
// public methods
//----------------------------------------------------------------------------------------

Parser.start = function() {
  return new Parser();
};

Object.keys(PRIMITIVE_TYPES).forEach(function(type) {
  Parser.prototype[type.toLowerCase()] = function(varName, options) {
    return this.setNextParser(type.toLowerCase(), varName, options);
  };

  var typeWithoutEndian = type.replace(/BE|LE/, "").toLowerCase();
  if (!(typeWithoutEndian in Parser.prototype)) {
    Parser.prototype[typeWithoutEndian] = function(varName, options) {
      return this[typeWithoutEndian + this.endian](varName, options);
    };
  }
});

BIT_RANGE.forEach(function(i) {
  Parser.prototype["bit" + i.toString()] = function(varName, options) {
    if (!options) {
      options = {};
    }
    options.length = i;
    return this.setNextParser("bit", varName, options);
  };
});

Parser.prototype.namely = function(alias) {
  aliasRegistry[alias] = this;
  this.alias = alias;
  return this;
};

Parser.prototype.skip = function(length, options) {
  if (options && options.assert) {
    throw new Error("assert option on skip is not allowed.");
  }

  return this.setNextParser("skip", "", { length: length });
};

Parser.prototype.string = function(varName, options) {
  if (!options.zeroTerminated && !options.length && !options.greedy) {
    throw new Error(
      "Neither length, zeroTerminated, nor greedy is defined for string."
    );
  }
  if ((options.zeroTerminated || options.length) && options.greedy) {
    throw new Error(
      "greedy is mutually exclusive with length and zeroTerminated for string."
    );
  }
  if (options.stripNull && !(options.length || options.greedy)) {
    throw new Error(
      "Length or greedy must be defined if stripNull is defined."
    );
  }
  options.encoding = options.encoding || "utf8";

  return this.setNextParser("string", varName, options);
};

Parser.prototype.buffer = function(varName, options) {
  if (!options.length && !options.readUntil) {
    throw new Error("Length nor readUntil is defined in buffer parser");
  }

  return this.setNextParser("buffer", varName, options);
};

Parser.prototype.array = function(varName, options) {
  if (!options.readUntil && !options.length && !options.lengthInBytes) {
    throw new Error("Length option of array is not defined.");
  }
  if (!options.type) {
    throw new Error("Type option of array is not defined.");
  }
  if (
    typeof options.type === "string" &&
    !aliasRegistry[options.type] &&
    Object.keys(PRIMITIVE_TYPES).indexOf(NAME_MAP[options.type]) < 0
  ) {
    throw new Error(
      'Specified primitive type "' + options.type + '" is not supported.'
    );
  }

  return this.setNextParser("array", varName, options);
};

Parser.prototype.choice = function(varName, options) {
  if (!options.tag) {
    throw new Error("Tag option of array is not defined.");
  }
  if (!options.choices) {
    throw new Error("Choices option of array is not defined.");
  }
  Object.keys(options.choices).forEach(function(key) {
    if (isNaN(parseInt(key, 10))) {
      throw new Error("Key of choices must be a number.");
    }
    if (!options.choices[key]) {
      throw new Error(
        "Choice Case " + key + " of " + varName + " is not valid."
      );
    }

    if (
      typeof options.choices[key] === "string" &&
      !aliasRegistry[options.choices[key]] &&
      Object.keys(PRIMITIVE_TYPES).indexOf(NAME_MAP[options.choices[key]]) < 0
    ) {
      throw new Error(
        'Specified primitive type "' +
          options.choices[key] +
          '" is not supported.'
      );
    }
  }, this);

  return this.setNextParser("choice", varName, options);
};

Parser.prototype.nest = function(varName, options) {
  if (!options.type) {
    throw new Error("Type option of nest is not defined.");
  }

  if (!(options.type instanceof Parser) && !aliasRegistry[options.type]) {
    throw new Error("Type option of nest must be a Parser object.");
  }

  return this.setNextParser("nest", varName, options);
};

Parser.prototype.endianess = function(endianess) {
  switch (endianess.toLowerCase()) {
    case "little":
      this.endian = "le";
      break;
    case "big":
      this.endian = "be";
      break;
    default:
      throw new Error("Invalid endianess: " + endianess);
  }

  return this;
};

Parser.prototype.create = function(constructorFn) {
  if (!(constructorFn instanceof Function)) {
    throw new Error("Constructor must be a Function object.");
  }

  this.constructorFn = constructorFn;

  return this;
};

Parser.prototype.getCode = function() {
  var ctx = new Context();

  if (!this.alias) {
    this.addRawCode(ctx);
  } else {
    this.addAliasedCode(ctx);
  }

  if (this.alias) {
    ctx.pushCode("return {0}(0).result;", FUNCTION_PREFIX + this.alias);
  } else {
    ctx.pushCode("return vars;");
  }

  return ctx.code;
};

Parser.prototype.addRawCode = function(ctx) {
  ctx.pushCode("var offset = 0;");

  if (this.constructorFn) {
    ctx.pushCode("var vars = new constructorFn();");
  } else {
    ctx.pushCode("var vars = {};");
  }

  this.generate(ctx);

  this.resolveReferences(ctx);

  ctx.pushCode("return vars;");
};

Parser.prototype.addAliasedCode = function(ctx) {
  ctx.pushCode("function {0}(offset) {", FUNCTION_PREFIX + this.alias);

  if (this.constructorFn) {
    ctx.pushCode("var vars = new constructorFn();");
  } else {
    ctx.pushCode("var vars = {};");
  }

  this.generate(ctx);

  ctx.markResolved(this.alias);
  this.resolveReferences(ctx);

  ctx.pushCode("return { offset: offset, result: vars };");
  ctx.pushCode("}");

  return ctx;
};

Parser.prototype.resolveReferences = function(ctx) {
  var references = ctx.getUnresolvedReferences();
  ctx.markRequested(references);
  references.forEach(function(alias) {
    var parser = aliasRegistry[alias];
    parser.addAliasedCode(ctx);
  });
};

Parser.prototype.compile = function() {
  this.compiled = new Function(
    "buffer",
    "callback",
    "constructorFn",
    this.getCode()
  );
};

Parser.prototype.sizeOf = function() {
  var size = NaN;

  if (Object.keys(PRIMITIVE_TYPES).indexOf(this.type) >= 0) {
    size = PRIMITIVE_TYPES[this.type];

    // if this is a fixed length string
  } else if (
    this.type === "String" &&
    typeof this.options.length === "number"
  ) {
    size = this.options.length;

    // if this is a fixed length buffer
  } else if (
    this.type === "Buffer" &&
    typeof this.options.length === "number"
  ) {
    size = this.options.length;

    // if this is a fixed length array
  } else if (this.type === "Array" && typeof this.options.length === "number") {
    var elementSize = NaN;
    if (typeof this.options.type === "string") {
      elementSize = PRIMITIVE_TYPES[NAME_MAP[this.options.type]];
    } else if (this.options.type instanceof Parser) {
      elementSize = this.options.type.sizeOf();
    }
    size = this.options.length * elementSize;

    // if this a skip
  } else if (this.type === "Skip") {
    size = this.options.length;

    // if this is a nested parser
  } else if (this.type === "Nest") {
    size = this.options.type.sizeOf();
  } else if (!this.type) {
    size = 0;
  }

  if (this.next) {
    size += this.next.sizeOf();
  }

  return size;
};

// Follow the parser chain till the root and start parsing from there
Parser.prototype.parse = function(buffer, callback) {
  if (!this.compiled) {
    this.compile();
  }

  return this.compiled(buffer, callback, this.constructorFn);
};

//----------------------------------------------------------------------------------------
// private methods
//----------------------------------------------------------------------------------------

Parser.prototype.setNextParser = function(type, varName, options) {
  var parser = new Parser();

  parser.type = NAME_MAP[type];
  parser.varName = varName;
  parser.options = options || parser.options;
  parser.endian = this.endian;

  if (this.head) {
    this.head.next = parser;
  } else {
    this.next = parser;
  }
  this.head = parser;

  return this;
};

// Call code generator for this parser
Parser.prototype.generate = function(ctx) {
  if (this.type) {
    this["generate" + this.type](ctx);
    this.generateAssert(ctx);
  }

  var varName = ctx.generateVariable(this.varName);
  if (this.options.formatter) {
    this.generateFormatter(ctx, varName, this.options.formatter);
  }

  return this.generateNext(ctx);
};

Parser.prototype.generateAssert = function(ctx) {
  if (!this.options.assert) {
    return;
  }

  var varName = ctx.generateVariable(this.varName);

  switch (typeof this.options.assert) {
    case "function":
      ctx.pushCode(
        "if (!({0}).call(vars, {1})) {",
        this.options.assert,
        varName
      );
      break;
    case "number":
      ctx.pushCode("if ({0} !== {1}) {", this.options.assert, varName);
      break;
    case "string":
      ctx.pushCode('if ("{0}" !== {1}) {', this.options.assert, varName);
      break;
    default:
      throw new Error(
        "Assert option supports only strings, numbers and assert functions."
      );
  }
  ctx.generateError('"Assert error: {0} is " + {0}', varName);
  ctx.pushCode("}");
};

// Recursively call code generators and append results
Parser.prototype.generateNext = function(ctx) {
  if (this.next) {
    ctx = this.next.generate(ctx);
  }

  return ctx;
};

Object.keys(PRIMITIVE_TYPES).forEach(function(type) {
  Parser.prototype["generate" + type] = function(ctx) {
    ctx.pushCode(
      "{0} = buffer.read{1}(offset);",
      ctx.generateVariable(this.varName),
      type
    );
    ctx.pushCode("offset += {0};", PRIMITIVE_TYPES[type]);
  };
});

Parser.prototype.generateBit = function(ctx) {
  // TODO find better method to handle nested bit fields
  var parser = JSON.parse(JSON.stringify(this));
  parser.varName = ctx.generateVariable(parser.varName);
  ctx.bitFields.push(parser);

  if (
    !this.next ||
    (this.next && ["Bit", "Nest"].indexOf(this.next.type) < 0)
  ) {
    var sum = 0;
    ctx.bitFields.forEach(function(parser) {
      sum += parser.options.length;
    });

    var val = ctx.generateTmpVariable();

    if (sum <= 8) {
      ctx.pushCode("var {0} = buffer.readUInt8(offset);", val);
      sum = 8;
    } else if (sum <= 16) {
      ctx.pushCode("var {0} = buffer.readUInt16BE(offset);", val);
      sum = 16;
    } else if (sum <= 24) {
      var val1 = ctx.generateTmpVariable();
      var val2 = ctx.generateTmpVariable();
      ctx.pushCode("var {0} = buffer.readUInt16BE(offset);", val1);
      ctx.pushCode("var {0} = buffer.readUInt8(offset + 2);", val2);
      ctx.pushCode("var {2} = ({0} << 8) | {1};", val1, val2, val);
      sum = 24;
    } else if (sum <= 32) {
      ctx.pushCode("var {0} = buffer.readUInt32BE(offset);", val);
      sum = 32;
    } else {
      throw new Error(
        "Currently, bit field sequence longer than 4-bytes is not supported."
      );
    }
    ctx.pushCode("offset += {0};", sum / 8);

    var bitOffset = 0;
    var isBigEndian = this.endian === "be";
    ctx.bitFields.forEach(function(parser) {
      ctx.pushCode(
        "{0} = {1} >> {2} & {3};",
        parser.varName,
        val,
        isBigEndian ? sum - bitOffset - parser.options.length : bitOffset,
        (1 << parser.options.length) - 1
      );
      bitOffset += parser.options.length;
    });

    ctx.bitFields = [];
  }
};

Parser.prototype.generateSkip = function(ctx) {
  var length = ctx.generateOption(this.options.length);
  ctx.pushCode("offset += {0};", length);
};

Parser.prototype.generateString = function(ctx) {
  var name = ctx.generateVariable(this.varName);
  var start = ctx.generateTmpVariable();

  if (this.options.length && this.options.zeroTerminated) {
    ctx.pushCode("var {0} = offset;", start);
    ctx.pushCode(
      "while(buffer.readUInt8(offset++) !== 0 && offset - {0}  < {1});",
      start,
      this.options.length
    );
    ctx.pushCode(
      "{0} = buffer.toString('{1}', {2}, offset - {2} < {3} ? offset - 1 : offset);",
      name,
      this.options.encoding,
      start,
      this.options.length
    );
  } else if (this.options.length) {
    ctx.pushCode(
      "{0} = buffer.toString('{1}', offset, offset + {2});",
      name,
      this.options.encoding,
      ctx.generateOption(this.options.length)
    );
    ctx.pushCode("offset += {0};", ctx.generateOption(this.options.length));
  } else if (this.options.zeroTerminated) {
    ctx.pushCode("var {0} = offset;", start);
    ctx.pushCode("while(buffer.readUInt8(offset++) !== 0);");
    ctx.pushCode(
      "{0} = buffer.toString('{1}', {2}, offset - 1);",
      name,
      this.options.encoding,
      start
    );
  } else if (this.options.greedy) {
    ctx.pushCode("var {0} = offset;", start);
    ctx.pushCode("while(buffer.length > offset++);");
    ctx.pushCode(
      "{0} = buffer.toString('{1}', {2}, offset);",
      name,
      this.options.encoding,
      start
    );
  }
  if (this.options.stripNull) {
    ctx.pushCode("{0} = {0}.replace(/\\x00+$/g, '')", name);
  }
};

Parser.prototype.generateBuffer = function(ctx) {
  if (this.options.readUntil === "eof") {
    ctx.pushCode(
      "{0} = buffer.slice(offset);",
      ctx.generateVariable(this.varName)
    );
  } else {
    ctx.pushCode(
      "{0} = buffer.slice(offset, offset + {1});",
      ctx.generateVariable(this.varName),
      ctx.generateOption(this.options.length)
    );
    ctx.pushCode("offset += {0};", ctx.generateOption(this.options.length));
  }

  if (this.options.clone) {
    var buf = ctx.generateTmpVariable();

    ctx.pushCode(
      "var {0} = new Buffer({1}.length);",
      buf,
      ctx.generateVariable(this.varName)
    );
    ctx.pushCode("{0}.copy({1});", ctx.generateVariable(this.varName), buf);
    ctx.pushCode("{0} = {1}", ctx.generateVariable(this.varName), buf);
  }
};

Parser.prototype.generateArray = function(ctx) {
  var length = ctx.generateOption(this.options.length);
  var lengthInBytes = ctx.generateOption(this.options.lengthInBytes);
  var type = this.options.type;
  var counter = ctx.generateTmpVariable();
  var lhs = ctx.generateVariable(this.varName);
  var item = ctx.generateTmpVariable();
  var key = this.options.key;
  var isHash = typeof key === "string";

  if (isHash) {
    ctx.pushCode("{0} = {};", lhs);
  } else {
    ctx.pushCode("{0} = [];", lhs);
  }
  if (typeof this.options.readUntil === "function") {
    ctx.pushCode("do {");
  } else if (this.options.readUntil === "eof") {
    ctx.pushCode("for (var {0} = 0; offset < buffer.length; {0}++) {", counter);
  } else if (lengthInBytes !== undefined) {
    ctx.pushCode(
      "for (var {0} = offset; offset - {0} < {1}; ) {",
      counter,
      lengthInBytes
    );
  } else {
    ctx.pushCode("for (var {0} = 0; {0} < {1}; {0}++) {", counter, length);
  }

  if (typeof type === "string") {
    if (!aliasRegistry[type]) {
      ctx.pushCode("var {0} = buffer.read{1}(offset);", item, NAME_MAP[type]);
      ctx.pushCode("offset += {0};", PRIMITIVE_TYPES[NAME_MAP[type]]);
    } else {
      var tempVar = ctx.generateTmpVariable();
      ctx.pushCode("var {0} = {1}(offset);", tempVar, FUNCTION_PREFIX + type);
      ctx.pushCode("var {0} = {1}.result; offset = {1}.offset;", item, tempVar);
      if (type !== this.alias) ctx.addReference(type);
    }
  } else if (type instanceof Parser) {
    ctx.pushCode("var {0} = {};", item);

    ctx.pushScope(item);
    type.generate(ctx);
    ctx.popScope();
  }

  if (isHash) {
    ctx.pushCode("{0}[{2}.{1}] = {2};", lhs, key, item);
  } else {
    ctx.pushCode("{0}.push({1});", lhs, item);
  }

  ctx.pushCode("}");

  if (typeof this.options.readUntil === "function") {
    ctx.pushCode(
      " while (!({0}).call(this, {1}, buffer.slice(offset)));",
      this.options.readUntil,
      item
    );
  }
};

Parser.prototype.generateChoiceCase = function(ctx, varName, type) {
  if (typeof type === "string") {
    if (!aliasRegistry[type]) {
      ctx.pushCode(
        "{0} = buffer.read{1}(offset);",
        ctx.generateVariable(this.varName),
        NAME_MAP[type]
      );
      ctx.pushCode("offset += {0};", PRIMITIVE_TYPES[NAME_MAP[type]]);
    } else {
      var tempVar = ctx.generateTmpVariable();
      ctx.pushCode("var {0} = {1}(offset);", tempVar, FUNCTION_PREFIX + type);
      ctx.pushCode(
        "{0} = {1}.result; offset = {1}.offset;",
        ctx.generateVariable(this.varName),
        tempVar
      );
      if (type !== this.alias) ctx.addReference(type);
    }
  } else if (type instanceof Parser) {
    ctx.pushPath(varName);
    type.generate(ctx);
    ctx.popPath(varName);
  }
};

Parser.prototype.generateChoice = function(ctx) {
  var tag = ctx.generateOption(this.options.tag);
  if (this.varName) {
    ctx.pushCode("{0} = {};", ctx.generateVariable(this.varName));
  }
  ctx.pushCode("switch({0}) {", tag);
  Object.keys(this.options.choices).forEach(function(tag) {
    var type = this.options.choices[tag];

    ctx.pushCode("case {0}:", tag);
    this.generateChoiceCase(ctx, this.varName, type);
    ctx.pushCode("break;");
  }, this);
  ctx.pushCode("default:");
  if (this.options.defaultChoice) {
    this.generateChoiceCase(ctx, this.varName, this.options.defaultChoice);
  } else {
    ctx.generateError('"Met undefined tag value " + {0} + " at choice"', tag);
  }
  ctx.pushCode("}");
};

Parser.prototype.generateNest = function(ctx) {
  var nestVar = ctx.generateVariable(this.varName);
  if (this.options.type instanceof Parser) {
    ctx.pushCode("{0} = {};", nestVar);
    ctx.pushPath(this.varName);
    this.options.type.generate(ctx);
    ctx.popPath(this.varName);
  } else if (aliasRegistry[this.options.type]) {
    var tempVar = ctx.generateTmpVariable();
    ctx.pushCode(
      "var {0} = {1}(offset);",
      tempVar,
      FUNCTION_PREFIX + this.options.type
    );
    ctx.pushCode("{0} = {1}.result; offset = {1}.offset;", nestVar, tempVar);
    if (this.options.type !== this.alias) ctx.addReference(this.options.type);
  }
};

Parser.prototype.generateFormatter = function(ctx, varName, formatter) {
  if (typeof formatter === "function") {
    ctx.pushCode("{0} = ({1}).call(this, {0});", varName, formatter);
  }
};

Parser.prototype.isInteger = function() {
  return !!this.type.match(/U?Int[8|16|32][BE|LE]?|Bit\d+/);
};

//========================================================================================
// Exports
//========================================================================================

exports.Parser = Parser;

},{"./context":5}],5:[function(require,module,exports){
//========================================================================================
// class Context
//========================================================================================

//----------------------------------------------------------------------------------------
// constructor
//----------------------------------------------------------------------------------------

var Context = function() {
  this.code = "";
  this.scopes = [["vars"]];
  this.isAsync = false;
  this.bitFields = [];
  this.tmpVariableCount = 0;
  this.references = {};
};

//----------------------------------------------------------------------------------------
// public methods
//----------------------------------------------------------------------------------------

Context.prototype.generateVariable = function(name) {
  var arr = [];

  Array.prototype.push.apply(arr, this.scopes[this.scopes.length - 1]);
  if (name) {
    arr.push(name);
  }

  return arr.join(".");
};

Context.prototype.generateOption = function(val) {
  switch (typeof val) {
    case "number":
      return val.toString();
    case "string":
      return this.generateVariable(val);
    case "function":
      return "(" + val + ").call(" + this.generateVariable() + ", vars)";
  }
};

Context.prototype.generateError = function() {
  var args = Array.prototype.slice.call(arguments);
  var err = Context.interpolate.apply(this, args);

  if (this.isAsync) {
    this.pushCode(
      "return process.nextTick(function() { callback(new Error(" +
        err +
        "), vars); });"
    );
  } else {
    this.pushCode("throw new Error(" + err + ");");
  }
};

Context.prototype.generateTmpVariable = function() {
  return "$tmp" + this.tmpVariableCount++;
};

Context.prototype.pushCode = function() {
  var args = Array.prototype.slice.call(arguments);

  this.code += Context.interpolate.apply(this, args) + "\n";
};

Context.prototype.pushPath = function(name) {
  if (name) {
    this.scopes[this.scopes.length - 1].push(name);
  }
};

Context.prototype.popPath = function(name) {
  if (name) {
    this.scopes[this.scopes.length - 1].pop();
  }
};

Context.prototype.pushScope = function(name) {
  this.scopes.push([name]);
};

Context.prototype.popScope = function() {
  this.scopes.pop();
};

Context.prototype.addReference = function(alias) {
  if (this.references[alias]) return;
  this.references[alias] = { resolved: false, requested: false };
};

Context.prototype.markResolved = function(alias) {
  this.references[alias].resolved = true;
};

Context.prototype.markRequested = function(aliasList) {
  aliasList.forEach(
    function(alias) {
      this.references[alias].requested = true;
    }.bind(this)
  );
};

Context.prototype.getUnresolvedReferences = function() {
  var references = this.references;
  return Object.keys(this.references).filter(function(alias) {
    return !references[alias].resolved && !references[alias].requested;
  });
};

//----------------------------------------------------------------------------------------
// private methods
//----------------------------------------------------------------------------------------

Context.interpolate = function(s) {
  var re = /{\d+}/g;
  var matches = s.match(re);
  var params = Array.prototype.slice.call(arguments, 1);

  if (matches) {
    matches.forEach(function(match) {
      var index = parseInt(match.substr(1, match.length - 2), 10);
      s = s.replace(match, params[index].toString());
    });
  }

  return s;
};

exports.Context = Context;

},{}],6:[function(require,module,exports){
(function (Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this,require("buffer").Buffer)
},{"base64-js":3,"buffer":6,"ieee754":7}],7:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],8:[function(require,module,exports){
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.THREE = {}));
}(this, function (exports) { 'use strict';

	// Polyfills

	if ( Number.EPSILON === undefined ) {

		Number.EPSILON = Math.pow( 2, - 52 );

	}

	if ( Number.isInteger === undefined ) {

		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger

		Number.isInteger = function ( value ) {

			return typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value;

		};

	}

	//

	if ( Math.sign === undefined ) {

		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

		Math.sign = function ( x ) {

			return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

		};

	}

	if ( 'name' in Function.prototype === false ) {

		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

		Object.defineProperty( Function.prototype, 'name', {

			get: function () {

				return this.toString().match( /^\s*function\s*([^\(\s]*)/ )[ 1 ];

			}

		} );

	}

	if ( Object.assign === undefined ) {

		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

		( function () {

			Object.assign = function ( target ) {

				if ( target === undefined || target === null ) {

					throw new TypeError( 'Cannot convert undefined or null to object' );

				}

				var output = Object( target );

				for ( var index = 1; index < arguments.length; index ++ ) {

					var source = arguments[ index ];

					if ( source !== undefined && source !== null ) {

						for ( var nextKey in source ) {

							if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {

								output[ nextKey ] = source[ nextKey ];

							}

						}

					}

				}

				return output;

			};

		} )();

	}

	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */

	function EventDispatcher() {}

	Object.assign( EventDispatcher.prototype, {

		addEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) this._listeners = {};

			var listeners = this._listeners;

			if ( listeners[ type ] === undefined ) {

				listeners[ type ] = [];

			}

			if ( listeners[ type ].indexOf( listener ) === - 1 ) {

				listeners[ type ].push( listener );

			}

		},

		hasEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) return false;

			var listeners = this._listeners;

			return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

		},

		removeEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) return;

			var listeners = this._listeners;
			var listenerArray = listeners[ type ];

			if ( listenerArray !== undefined ) {

				var index = listenerArray.indexOf( listener );

				if ( index !== - 1 ) {

					listenerArray.splice( index, 1 );

				}

			}

		},

		dispatchEvent: function ( event ) {

			if ( this._listeners === undefined ) return;

			var listeners = this._listeners;
			var listenerArray = listeners[ event.type ];

			if ( listenerArray !== undefined ) {

				event.target = this;

				var array = listenerArray.slice( 0 );

				for ( var i = 0, l = array.length; i < l; i ++ ) {

					array[ i ].call( this, event );

				}

			}

		}

	} );

	var REVISION = '103';
	var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
	var CullFaceNone = 0;
	var CullFaceBack = 1;
	var CullFaceFront = 2;
	var CullFaceFrontBack = 3;
	var FrontFaceDirectionCW = 0;
	var FrontFaceDirectionCCW = 1;
	var BasicShadowMap = 0;
	var PCFShadowMap = 1;
	var PCFSoftShadowMap = 2;
	var FrontSide = 0;
	var BackSide = 1;
	var DoubleSide = 2;
	var FlatShading = 1;
	var SmoothShading = 2;
	var NoColors = 0;
	var FaceColors = 1;
	var VertexColors = 2;
	var NoBlending = 0;
	var NormalBlending = 1;
	var AdditiveBlending = 2;
	var SubtractiveBlending = 3;
	var MultiplyBlending = 4;
	var CustomBlending = 5;
	var AddEquation = 100;
	var SubtractEquation = 101;
	var ReverseSubtractEquation = 102;
	var MinEquation = 103;
	var MaxEquation = 104;
	var ZeroFactor = 200;
	var OneFactor = 201;
	var SrcColorFactor = 202;
	var OneMinusSrcColorFactor = 203;
	var SrcAlphaFactor = 204;
	var OneMinusSrcAlphaFactor = 205;
	var DstAlphaFactor = 206;
	var OneMinusDstAlphaFactor = 207;
	var DstColorFactor = 208;
	var OneMinusDstColorFactor = 209;
	var SrcAlphaSaturateFactor = 210;
	var NeverDepth = 0;
	var AlwaysDepth = 1;
	var LessDepth = 2;
	var LessEqualDepth = 3;
	var EqualDepth = 4;
	var GreaterEqualDepth = 5;
	var GreaterDepth = 6;
	var NotEqualDepth = 7;
	var MultiplyOperation = 0;
	var MixOperation = 1;
	var AddOperation = 2;
	var NoToneMapping = 0;
	var LinearToneMapping = 1;
	var ReinhardToneMapping = 2;
	var Uncharted2ToneMapping = 3;
	var CineonToneMapping = 4;
	var ACESFilmicToneMapping = 5;

	var UVMapping = 300;
	var CubeReflectionMapping = 301;
	var CubeRefractionMapping = 302;
	var EquirectangularReflectionMapping = 303;
	var EquirectangularRefractionMapping = 304;
	var SphericalReflectionMapping = 305;
	var CubeUVReflectionMapping = 306;
	var CubeUVRefractionMapping = 307;
	var RepeatWrapping = 1000;
	var ClampToEdgeWrapping = 1001;
	var MirroredRepeatWrapping = 1002;
	var NearestFilter = 1003;
	var NearestMipMapNearestFilter = 1004;
	var NearestMipMapLinearFilter = 1005;
	var LinearFilter = 1006;
	var LinearMipMapNearestFilter = 1007;
	var LinearMipMapLinearFilter = 1008;
	var UnsignedByteType = 1009;
	var ByteType = 1010;
	var ShortType = 1011;
	var UnsignedShortType = 1012;
	var IntType = 1013;
	var UnsignedIntType = 1014;
	var FloatType = 1015;
	var HalfFloatType = 1016;
	var UnsignedShort4444Type = 1017;
	var UnsignedShort5551Type = 1018;
	var UnsignedShort565Type = 1019;
	var UnsignedInt248Type = 1020;
	var AlphaFormat = 1021;
	var RGBFormat = 1022;
	var RGBAFormat = 1023;
	var LuminanceFormat = 1024;
	var LuminanceAlphaFormat = 1025;
	var RGBEFormat = RGBAFormat;
	var DepthFormat = 1026;
	var DepthStencilFormat = 1027;
	var RedFormat = 1028;
	var RGB_S3TC_DXT1_Format = 33776;
	var RGBA_S3TC_DXT1_Format = 33777;
	var RGBA_S3TC_DXT3_Format = 33778;
	var RGBA_S3TC_DXT5_Format = 33779;
	var RGB_PVRTC_4BPPV1_Format = 35840;
	var RGB_PVRTC_2BPPV1_Format = 35841;
	var RGBA_PVRTC_4BPPV1_Format = 35842;
	var RGBA_PVRTC_2BPPV1_Format = 35843;
	var RGB_ETC1_Format = 36196;
	var RGBA_ASTC_4x4_Format = 37808;
	var RGBA_ASTC_5x4_Format = 37809;
	var RGBA_ASTC_5x5_Format = 37810;
	var RGBA_ASTC_6x5_Format = 37811;
	var RGBA_ASTC_6x6_Format = 37812;
	var RGBA_ASTC_8x5_Format = 37813;
	var RGBA_ASTC_8x6_Format = 37814;
	var RGBA_ASTC_8x8_Format = 37815;
	var RGBA_ASTC_10x5_Format = 37816;
	var RGBA_ASTC_10x6_Format = 37817;
	var RGBA_ASTC_10x8_Format = 37818;
	var RGBA_ASTC_10x10_Format = 37819;
	var RGBA_ASTC_12x10_Format = 37820;
	var RGBA_ASTC_12x12_Format = 37821;
	var LoopOnce = 2200;
	var LoopRepeat = 2201;
	var LoopPingPong = 2202;
	var InterpolateDiscrete = 2300;
	var InterpolateLinear = 2301;
	var InterpolateSmooth = 2302;
	var ZeroCurvatureEnding = 2400;
	var ZeroSlopeEnding = 2401;
	var WrapAroundEnding = 2402;
	var TrianglesDrawMode = 0;
	var TriangleStripDrawMode = 1;
	var TriangleFanDrawMode = 2;
	var LinearEncoding = 3000;
	var sRGBEncoding = 3001;
	var GammaEncoding = 3007;
	var RGBEEncoding = 3002;
	var LogLuvEncoding = 3003;
	var RGBM7Encoding = 3004;
	var RGBM16Encoding = 3005;
	var RGBDEncoding = 3006;
	var BasicDepthPacking = 3200;
	var RGBADepthPacking = 3201;
	var TangentSpaceNormalMap = 0;
	var ObjectSpaceNormalMap = 1;

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	var _Math = {

		DEG2RAD: Math.PI / 180,
		RAD2DEG: 180 / Math.PI,

		generateUUID: ( function () {

			// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

			var lut = [];

			for ( var i = 0; i < 256; i ++ ) {

				lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

			}

			return function generateUUID() {

				var d0 = Math.random() * 0xffffffff | 0;
				var d1 = Math.random() * 0xffffffff | 0;
				var d2 = Math.random() * 0xffffffff | 0;
				var d3 = Math.random() * 0xffffffff | 0;
				var uuid = lut[ d0 & 0xff ] + lut[ d0 >> 8 & 0xff ] + lut[ d0 >> 16 & 0xff ] + lut[ d0 >> 24 & 0xff ] + '-' +
					lut[ d1 & 0xff ] + lut[ d1 >> 8 & 0xff ] + '-' + lut[ d1 >> 16 & 0x0f | 0x40 ] + lut[ d1 >> 24 & 0xff ] + '-' +
					lut[ d2 & 0x3f | 0x80 ] + lut[ d2 >> 8 & 0xff ] + '-' + lut[ d2 >> 16 & 0xff ] + lut[ d2 >> 24 & 0xff ] +
					lut[ d3 & 0xff ] + lut[ d3 >> 8 & 0xff ] + lut[ d3 >> 16 & 0xff ] + lut[ d3 >> 24 & 0xff ];

				// .toUpperCase() here flattens concatenated strings to save heap memory space.
				return uuid.toUpperCase();

			};

		} )(),

		clamp: function ( value, min, max ) {

			return Math.max( min, Math.min( max, value ) );

		},

		// compute euclidian modulo of m % n
		// https://en.wikipedia.org/wiki/Modulo_operation

		euclideanModulo: function ( n, m ) {

			return ( ( n % m ) + m ) % m;

		},

		// Linear mapping from range <a1, a2> to range <b1, b2>

		mapLinear: function ( x, a1, a2, b1, b2 ) {

			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

		},

		// https://en.wikipedia.org/wiki/Linear_interpolation

		lerp: function ( x, y, t ) {

			return ( 1 - t ) * x + t * y;

		},

		// http://en.wikipedia.org/wiki/Smoothstep

		smoothstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * ( 3 - 2 * x );

		},

		smootherstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

		},

		// Random integer from <low, high> interval

		randInt: function ( low, high ) {

			return low + Math.floor( Math.random() * ( high - low + 1 ) );

		},

		// Random float from <low, high> interval

		randFloat: function ( low, high ) {

			return low + Math.random() * ( high - low );

		},

		// Random float from <-range/2, range/2> interval

		randFloatSpread: function ( range ) {

			return range * ( 0.5 - Math.random() );

		},

		degToRad: function ( degrees ) {

			return degrees * _Math.DEG2RAD;

		},

		radToDeg: function ( radians ) {

			return radians * _Math.RAD2DEG;

		},

		isPowerOfTwo: function ( value ) {

			return ( value & ( value - 1 ) ) === 0 && value !== 0;

		},

		ceilPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

		},

		floorPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

		}

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author philogb / http://blog.thejit.org/
	 * @author egraether / http://egraether.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	function Vector2( x, y ) {

		this.x = x || 0;
		this.y = y || 0;

	}

	Object.defineProperties( Vector2.prototype, {

		"width": {

			get: function () {

				return this.x;

			},

			set: function ( value ) {

				this.x = value;

			}

		},

		"height": {

			get: function () {

				return this.y;

			},

			set: function ( value ) {

				this.y = value;

			}

		}

	} );

	Object.assign( Vector2.prototype, {

		isVector2: true,

		set: function ( x, y ) {

			this.x = x;
			this.y = y;

			return this;

		},

		setScalar: function ( scalar ) {

			this.x = scalar;
			this.y = scalar;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;

			return this;

		},

		multiply: function ( v ) {

			this.x *= v.x;
			this.y *= v.y;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;

			return this;

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		applyMatrix3: function ( m ) {

			var x = this.x, y = this.y;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

			return this;

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );

			return this;

		},

		clamp: function ( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );

			return this;

		},

		clampScalar: function () {

			var min = new Vector2();
			var max = new Vector2();

			return function clampScalar( minVal, maxVal ) {

				min.set( minVal, minVal );
				max.set( maxVal, maxVal );

				return this.clamp( min, max );

			};

		}(),

		clampLength: function ( min, max ) {

			var length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y;

		},

		cross: function ( v ) {

			return this.x * v.y - this.y * v.x;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y );

		},

		manhattanLength: function () {

			return Math.abs( this.x ) + Math.abs( this.y );

		},

		normalize: function () {

			return this.divideScalar( this.length() || 1 );

		},

		angle: function () {

			// computes the angle in radians with respect to the positive x-axis

			var angle = Math.atan2( this.y, this.x );

			if ( angle < 0 ) angle += 2 * Math.PI;

			return angle;

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;

		},

		manhattanDistanceTo: function ( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

		},

		setLength: function ( length ) {

			return this.normalize().multiplyScalar( length );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;

			return array;

		},

		fromBufferAttribute: function ( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );

			return this;

		},

		rotateAround: function ( center, angle ) {

			var c = Math.cos( angle ), s = Math.sin( angle );

			var x = this.x - center.x;
			var y = this.y - center.y;

			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;

			return this;

		}

	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */

	function Quaternion( x, y, z, w ) {

		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._w = ( w !== undefined ) ? w : 1;

	}

	Object.assign( Quaternion, {

		slerp: function ( qa, qb, qm, t ) {

			return qm.copy( qa ).slerp( qb, t );

		},

		slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

			// fuzz-free, array-based Quaternion SLERP operation

			var x0 = src0[ srcOffset0 + 0 ],
				y0 = src0[ srcOffset0 + 1 ],
				z0 = src0[ srcOffset0 + 2 ],
				w0 = src0[ srcOffset0 + 3 ],

				x1 = src1[ srcOffset1 + 0 ],
				y1 = src1[ srcOffset1 + 1 ],
				z1 = src1[ srcOffset1 + 2 ],
				w1 = src1[ srcOffset1 + 3 ];

			if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

				var s = 1 - t,

					cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

					dir = ( cos >= 0 ? 1 : - 1 ),
					sqrSin = 1 - cos * cos;

				// Skip the Slerp for tiny steps to avoid numeric problems:
				if ( sqrSin > Number.EPSILON ) {

					var sin = Math.sqrt( sqrSin ),
						len = Math.atan2( sin, cos * dir );

					s = Math.sin( s * len ) / sin;
					t = Math.sin( t * len ) / sin;

				}

				var tDir = t * dir;

				x0 = x0 * s + x1 * tDir;
				y0 = y0 * s + y1 * tDir;
				z0 = z0 * s + z1 * tDir;
				w0 = w0 * s + w1 * tDir;

				// Normalize in case we just did a lerp:
				if ( s === 1 - t ) {

					var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

					x0 *= f;
					y0 *= f;
					z0 *= f;
					w0 *= f;

				}

			}

			dst[ dstOffset ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;

		}

	} );

	Object.defineProperties( Quaternion.prototype, {

		x: {

			get: function () {

				return this._x;

			},

			set: function ( value ) {

				this._x = value;
				this.onChangeCallback();

			}

		},

		y: {

			get: function () {

				return this._y;

			},

			set: function ( value ) {

				this._y = value;
				this.onChangeCallback();

			}

		},

		z: {

			get: function () {

				return this._z;

			},

			set: function ( value ) {

				this._z = value;
				this.onChangeCallback();

			}

		},

		w: {

			get: function () {

				return this._w;

			},

			set: function ( value ) {

				this._w = value;
				this.onChangeCallback();

			}

		}

	} );

	Object.assign( Quaternion.prototype, {

		isQuaternion: true,

		set: function ( x, y, z, w ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

			this.onChangeCallback();

			return this;

		},

		clone: function () {

			return new this.constructor( this._x, this._y, this._z, this._w );

		},

		copy: function ( quaternion ) {

			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;

			this.onChangeCallback();

			return this;

		},

		setFromEuler: function ( euler, update ) {

			if ( ! ( euler && euler.isEuler ) ) {

				throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

			}

			var x = euler._x, y = euler._y, z = euler._z, order = euler.order;

			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m

			var cos = Math.cos;
			var sin = Math.sin;

			var c1 = cos( x / 2 );
			var c2 = cos( y / 2 );
			var c3 = cos( z / 2 );

			var s1 = sin( x / 2 );
			var s2 = sin( y / 2 );
			var s3 = sin( z / 2 );

			if ( order === 'XYZ' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'YXZ' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if ( order === 'ZXY' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'ZYX' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if ( order === 'YZX' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'XZY' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			}

			if ( update !== false ) this.onChangeCallback();

			return this;

		},

		setFromAxisAngle: function ( axis, angle ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

			// assumes axis is normalized

			var halfAngle = angle / 2, s = Math.sin( halfAngle );

			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );

			this.onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function ( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

				trace = m11 + m22 + m33,
				s;

			if ( trace > 0 ) {

				s = 0.5 / Math.sqrt( trace + 1.0 );

				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;

			} else if ( m11 > m22 && m11 > m33 ) {

				s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

				this._w = ( m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = ( m12 + m21 ) / s;
				this._z = ( m13 + m31 ) / s;

			} else if ( m22 > m33 ) {

				s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

				this._w = ( m13 - m31 ) / s;
				this._x = ( m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = ( m23 + m32 ) / s;

			} else {

				s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;

			}

			this.onChangeCallback();

			return this;

		},

		setFromUnitVectors: function ( vFrom, vTo ) {

			// assumes direction vectors vFrom and vTo are normalized

			var EPS = 0.000001;

			var r = vFrom.dot( vTo ) + 1;

			if ( r < EPS ) {

				r = 0;

				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

					this._x = - vFrom.y;
					this._y = vFrom.x;
					this._z = 0;
					this._w = r;

				} else {

					this._x = 0;
					this._y = - vFrom.z;
					this._z = vFrom.y;
					this._w = r;

				}

			} else {

				// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

				this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
				this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
				this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
				this._w = r;

			}

			return this.normalize();

		},

		angleTo: function ( q ) {

			return 2 * Math.acos( Math.abs( _Math.clamp( this.dot( q ), - 1, 1 ) ) );

		},

		rotateTowards: function ( q, step ) {

			var angle = this.angleTo( q );

			if ( angle === 0 ) return this;

			var t = Math.min( 1, step / angle );

			this.slerp( q, t );

			return this;

		},

		inverse: function () {

			// quaternion is assumed to have unit length

			return this.conjugate();

		},

		conjugate: function () {

			this._x *= - 1;
			this._y *= - 1;
			this._z *= - 1;

			this.onChangeCallback();

			return this;

		},

		dot: function ( v ) {

			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

		},

		lengthSq: function () {

			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

		},

		length: function () {

			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

		},

		normalize: function () {

			var l = this.length();

			if ( l === 0 ) {

				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;

			} else {

				l = 1 / l;

				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;

			}

			this.onChangeCallback();

			return this;

		},

		multiply: function ( q, p ) {

			if ( p !== undefined ) {

				console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
				return this.multiplyQuaternions( q, p );

			}

			return this.multiplyQuaternions( this, q );

		},

		premultiply: function ( q ) {

			return this.multiplyQuaternions( q, this );

		},

		multiplyQuaternions: function ( a, b ) {

			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

			var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

			this.onChangeCallback();

			return this;

		},

		slerp: function ( qb, t ) {

			if ( t === 0 ) return this;
			if ( t === 1 ) return this.copy( qb );

			var x = this._x, y = this._y, z = this._z, w = this._w;

			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

			var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

			if ( cosHalfTheta < 0 ) {

				this._w = - qb._w;
				this._x = - qb._x;
				this._y = - qb._y;
				this._z = - qb._z;

				cosHalfTheta = - cosHalfTheta;

			} else {

				this.copy( qb );

			}

			if ( cosHalfTheta >= 1.0 ) {

				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;

				return this;

			}

			var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

			if ( sqrSinHalfTheta <= Number.EPSILON ) {

				var s = 1 - t;
				this._w = s * w + t * this._w;
				this._x = s * x + t * this._x;
				this._y = s * y + t * this._y;
				this._z = s * z + t * this._z;

				return this.normalize();

			}

			var sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
			var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
			var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
				ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

			this._w = ( w * ratioA + this._w * ratioB );
			this._x = ( x * ratioA + this._x * ratioB );
			this._y = ( y * ratioA + this._y * ratioB );
			this._z = ( z * ratioA + this._z * ratioB );

			this.onChangeCallback();

			return this;

		},

		equals: function ( quaternion ) {

			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this._x = array[ offset ];
			this._y = array[ offset + 1 ];
			this._z = array[ offset + 2 ];
			this._w = array[ offset + 3 ];

			this.onChangeCallback();

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._w;

			return array;

		},

		onChange: function ( callback ) {

			this.onChangeCallback = callback;

			return this;

		},

		onChangeCallback: function () {}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Vector3( x, y, z ) {

		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;

	}

	Object.assign( Vector3.prototype, {

		isVector3: true,

		set: function ( x, y, z ) {

			this.x = x;
			this.y = y;
			this.z = z;

			return this;

		},

		setScalar: function ( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y, this.z );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;

			return this;

		},

		multiply: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
				return this.multiplyVectors( v, w );

			}

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;

			return this;

		},

		multiplyVectors: function ( a, b ) {

			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;

			return this;

		},

		applyEuler: function () {

			var quaternion = new Quaternion();

			return function applyEuler( euler ) {

				if ( ! ( euler && euler.isEuler ) ) {

					console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

				}

				return this.applyQuaternion( quaternion.setFromEuler( euler ) );

			};

		}(),

		applyAxisAngle: function () {

			var quaternion = new Quaternion();

			return function applyAxisAngle( axis, angle ) {

				return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

			};

		}(),

		applyMatrix3: function ( m ) {

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

			return this;

		},

		applyMatrix4: function ( m ) {

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

			return this;

		},

		applyQuaternion: function ( q ) {

			var x = this.x, y = this.y, z = this.z;
			var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

			// calculate quat * vector

			var ix = qw * x + qy * z - qz * y;
			var iy = qw * y + qz * x - qx * z;
			var iz = qw * z + qx * y - qy * x;
			var iw = - qx * x - qy * y - qz * z;

			// calculate result * inverse quat

			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

			return this;

		},

		project: function ( camera ) {

			return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

		},

		unproject: function ( camera ) {

			return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

		},

		transformDirection: function ( m ) {

			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

			return this.normalize();

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );

			return this;

		},

		clamp: function ( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );

			return this;

		},

		clampScalar: function () {

			var min = new Vector3();
			var max = new Vector3();

			return function clampScalar( minVal, maxVal ) {

				min.set( minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal );

				return this.clamp( min, max );

			};

		}(),

		clampLength: function ( min, max ) {

			var length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z;

		},

		// TODO lengthSquared?

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

		},

		manhattanLength: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

		},

		normalize: function () {

			return this.divideScalar( this.length() || 1 );

		},

		setLength: function ( length ) {

			return this.normalize().multiplyScalar( length );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		},

		cross: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
				return this.crossVectors( v, w );

			}

			return this.crossVectors( this, v );

		},

		crossVectors: function ( a, b ) {

			var ax = a.x, ay = a.y, az = a.z;
			var bx = b.x, by = b.y, bz = b.z;

			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;

			return this;

		},

		projectOnVector: function ( vector ) {

			var scalar = vector.dot( this ) / vector.lengthSq();

			return this.copy( vector ).multiplyScalar( scalar );

		},

		projectOnPlane: function () {

			var v1 = new Vector3();

			return function projectOnPlane( planeNormal ) {

				v1.copy( this ).projectOnVector( planeNormal );

				return this.sub( v1 );

			};

		}(),

		reflect: function () {

			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length

			var v1 = new Vector3();

			return function reflect( normal ) {

				return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

			};

		}(),

		angleTo: function ( v ) {

			var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );

			// clamp, to handle numerical problems

			return Math.acos( _Math.clamp( theta, - 1, 1 ) );

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

			return dx * dx + dy * dy + dz * dz;

		},

		manhattanDistanceTo: function ( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

		},

		setFromSpherical: function ( s ) {

			return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

		},

		setFromSphericalCoords: function ( radius, phi, theta ) {

			var sinPhiRadius = Math.sin( phi ) * radius;

			this.x = sinPhiRadius * Math.sin( theta );
			this.y = Math.cos( phi ) * radius;
			this.z = sinPhiRadius * Math.cos( theta );

			return this;

		},

		setFromCylindrical: function ( c ) {

			return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

		},

		setFromCylindricalCoords: function ( radius, theta, y ) {

			this.x = radius * Math.sin( theta );
			this.y = y;
			this.z = radius * Math.cos( theta );

			return this;

		},

		setFromMatrixPosition: function ( m ) {

			var e = m.elements;

			this.x = e[ 12 ];
			this.y = e[ 13 ];
			this.z = e[ 14 ];

			return this;

		},

		setFromMatrixScale: function ( m ) {

			var sx = this.setFromMatrixColumn( m, 0 ).length();
			var sy = this.setFromMatrixColumn( m, 1 ).length();
			var sz = this.setFromMatrixColumn( m, 2 ).length();

			this.x = sx;
			this.y = sy;
			this.z = sz;

			return this;

		},

		setFromMatrixColumn: function ( m, index ) {

			return this.fromArray( m.elements, index * 4 );

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;

			return array;

		},

		fromBufferAttribute: function ( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );

			return this;

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 * @author tschw
	 */

	function Matrix3() {

		this.elements = [

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	Object.assign( Matrix3.prototype, {

		isMatrix3: true,

		set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

			var te = this.elements;

			te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
			te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
			te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			);

			return this;

		},

		clone: function () {

			return new this.constructor().fromArray( this.elements );

		},

		copy: function ( m ) {

			var te = this.elements;
			var me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
			te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
			te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

			return this;

		},

		setFromMatrix4: function ( m ) {

			var me = m.elements;

			this.set(

				me[ 0 ], me[ 4 ], me[ 8 ],
				me[ 1 ], me[ 5 ], me[ 9 ],
				me[ 2 ], me[ 6 ], me[ 10 ]

			);

			return this;

		},

		applyToBufferAttribute: function () {

			var v1 = new Vector3();

			return function applyToBufferAttribute( attribute ) {

				for ( var i = 0, l = attribute.count; i < l; i ++ ) {

					v1.x = attribute.getX( i );
					v1.y = attribute.getY( i );
					v1.z = attribute.getZ( i );

					v1.applyMatrix3( this );

					attribute.setXYZ( i, v1.x, v1.y, v1.z );

				}

				return attribute;

			};

		}(),

		multiply: function ( m ) {

			return this.multiplyMatrices( this, m );

		},

		premultiply: function ( m ) {

			return this.multiplyMatrices( m, this );

		},

		multiplyMatrices: function ( a, b ) {

			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;

			var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
			var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
			var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

			var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
			var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
			var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
			te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
			te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
			te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
			te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
			te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
			te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

			return this;

		},

		multiplyScalar: function ( s ) {

			var te = this.elements;

			te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
			te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
			te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

			return this;

		},

		determinant: function () {

			var te = this.elements;

			var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
				d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
				g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

		},

		getInverse: function ( matrix, throwOnDegenerate ) {

			if ( matrix && matrix.isMatrix4 ) {

				console.error( "THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument." );

			}

			var me = matrix.elements,
				te = this.elements,

				n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
				n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
				n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

				t11 = n33 * n22 - n32 * n23,
				t12 = n32 * n13 - n33 * n12,
				t13 = n23 * n12 - n22 * n13,

				det = n11 * t11 + n21 * t12 + n31 * t13;

			if ( det === 0 ) {

				var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";

				if ( throwOnDegenerate === true ) {

					throw new Error( msg );

				} else {

					console.warn( msg );

				}

				return this.identity();

			}

			var detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
			te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

			te[ 3 ] = t12 * detInv;
			te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
			te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

			te[ 6 ] = t13 * detInv;
			te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
			te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

			return this;

		},

		transpose: function () {

			var tmp, m = this.elements;

			tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
			tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
			tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

			return this;

		},

		getNormalMatrix: function ( matrix4 ) {

			return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

		},

		transposeIntoArray: function ( r ) {

			var m = this.elements;

			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];

			return this;

		},

		setUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {

			var c = Math.cos( rotation );
			var s = Math.sin( rotation );

			this.set(
				sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
				- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
				0, 0, 1
			);

		},

		scale: function ( sx, sy ) {

			var te = this.elements;

			te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
			te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

			return this;

		},

		rotate: function ( theta ) {

			var c = Math.cos( theta );
			var s = Math.sin( theta );

			var te = this.elements;

			var a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
			var a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

			te[ 0 ] = c * a11 + s * a21;
			te[ 3 ] = c * a12 + s * a22;
			te[ 6 ] = c * a13 + s * a23;

			te[ 1 ] = - s * a11 + c * a21;
			te[ 4 ] = - s * a12 + c * a22;
			te[ 7 ] = - s * a13 + c * a23;

			return this;

		},

		translate: function ( tx, ty ) {

			var te = this.elements;

			te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
			te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

			return this;

		},

		equals: function ( matrix ) {

			var te = this.elements;
			var me = matrix.elements;

			for ( var i = 0; i < 9; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			for ( var i = 0; i < 9; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			var te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];

			array[ offset + 3 ] = te[ 3 ];
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];

			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
			array[ offset + 8 ] = te[ 8 ];

			return array;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */

	var _canvas;

	var ImageUtils = {

		getDataURL: function ( image ) {

			var canvas;

			if ( typeof HTMLCanvasElement == 'undefined' ) {

				return image.src;

			} else if ( image instanceof HTMLCanvasElement ) {

				canvas = image;

			} else {

				if ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

				_canvas.width = image.width;
				_canvas.height = image.height;

				var context = _canvas.getContext( '2d' );

				if ( image instanceof ImageData ) {

					context.putImageData( image, 0, 0 );

				} else {

					context.drawImage( image, 0, 0, image.width, image.height );

				}

				canvas = _canvas;

			}

			if ( canvas.width > 2048 || canvas.height > 2048 ) {

				return canvas.toDataURL( 'image/jpeg', 0.6 );

			} else {

				return canvas.toDataURL( 'image/png' );

			}

		}

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */

	var textureId = 0;

	function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

		Object.defineProperty( this, 'id', { value: textureId ++ } );

		this.uuid = _Math.generateUUID();

		this.name = '';

		this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
		this.mipmaps = [];

		this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;

		this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
		this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;

		this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
		this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;

		this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

		this.format = format !== undefined ? format : RGBAFormat;
		this.type = type !== undefined ? type : UnsignedByteType;

		this.offset = new Vector2( 0, 0 );
		this.repeat = new Vector2( 1, 1 );
		this.center = new Vector2( 0, 0 );
		this.rotation = 0;

		this.matrixAutoUpdate = true;
		this.matrix = new Matrix3();

		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
		//
		// Also changing the encoding after already used by a Material will not automatically make the Material
		// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
		this.encoding = encoding !== undefined ? encoding : LinearEncoding;

		this.version = 0;
		this.onUpdate = null;

	}

	Texture.DEFAULT_IMAGE = undefined;
	Texture.DEFAULT_MAPPING = UVMapping;

	Texture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Texture,

		isTexture: true,

		updateMatrix: function () {

			this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.name = source.name;

			this.image = source.image;
			this.mipmaps = source.mipmaps.slice( 0 );

			this.mapping = source.mapping;

			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;

			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;

			this.anisotropy = source.anisotropy;

			this.format = source.format;
			this.type = source.type;

			this.offset.copy( source.offset );
			this.repeat.copy( source.repeat );
			this.center.copy( source.center );
			this.rotation = source.rotation;

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrix.copy( source.matrix );

			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;
			this.encoding = source.encoding;

			return this;

		},

		toJSON: function ( meta ) {

			var isRootObject = ( meta === undefined || typeof meta === 'string' );

			if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

				return meta.textures[ this.uuid ];

			}

			var output = {

				metadata: {
					version: 4.5,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},

				uuid: this.uuid,
				name: this.name,

				mapping: this.mapping,

				repeat: [ this.repeat.x, this.repeat.y ],
				offset: [ this.offset.x, this.offset.y ],
				center: [ this.center.x, this.center.y ],
				rotation: this.rotation,

				wrap: [ this.wrapS, this.wrapT ],

				format: this.format,
				type: this.type,
				encoding: this.encoding,

				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy,

				flipY: this.flipY,

				premultiplyAlpha: this.premultiplyAlpha,
				unpackAlignment: this.unpackAlignment

			};

			if ( this.image !== undefined ) {

				// TODO: Move to THREE.Image

				var image = this.image;

				if ( image.uuid === undefined ) {

					image.uuid = _Math.generateUUID(); // UGH

				}

				if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {

					var url;

					if ( Array.isArray( image ) ) {

						// process array of images e.g. CubeTexture

						url = [];

						for ( var i = 0, l = image.length; i < l; i ++ ) {

							url.push( ImageUtils.getDataURL( image[ i ] ) );

						}

					} else {

						// process single image

						url = ImageUtils.getDataURL( image );

					}

					meta.images[ image.uuid ] = {
						uuid: image.uuid,
						url: url
					};

				}

				output.image = image.uuid;

			}

			if ( ! isRootObject ) {

				meta.textures[ this.uuid ] = output;

			}

			return output;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		},

		transformUv: function ( uv ) {

			if ( this.mapping !== UVMapping ) return uv;

			uv.applyMatrix3( this.matrix );

			if ( uv.x < 0 || uv.x > 1 ) {

				switch ( this.wrapS ) {

					case RepeatWrapping:

						uv.x = uv.x - Math.floor( uv.x );
						break;

					case ClampToEdgeWrapping:

						uv.x = uv.x < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

							uv.x = Math.ceil( uv.x ) - uv.x;

						} else {

							uv.x = uv.x - Math.floor( uv.x );

						}
						break;

				}

			}

			if ( uv.y < 0 || uv.y > 1 ) {

				switch ( this.wrapT ) {

					case RepeatWrapping:

						uv.y = uv.y - Math.floor( uv.y );
						break;

					case ClampToEdgeWrapping:

						uv.y = uv.y < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

							uv.y = Math.ceil( uv.y ) - uv.y;

						} else {

							uv.y = uv.y - Math.floor( uv.y );

						}
						break;

				}

			}

			if ( this.flipY ) {

				uv.y = 1 - uv.y;

			}

			return uv;

		}

	} );

	Object.defineProperty( Texture.prototype, "needsUpdate", {

		set: function ( value ) {

			if ( value === true ) this.version ++;

		}

	} );

	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Vector4( x, y, z, w ) {

		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
		this.w = ( w !== undefined ) ? w : 1;

	}

	Object.assign( Vector4.prototype, {

		isVector4: true,

		set: function ( x, y, z, w ) {

			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;

			return this;

		},

		setScalar: function ( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			this.w = scalar;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setW: function ( w ) {

			this.w = w;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y, this.z, this.w );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = ( v.w !== undefined ) ? v.w : 1;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;

			return this;

		},

		applyMatrix4: function ( m ) {

			var x = this.x, y = this.y, z = this.z, w = this.w;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
			this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		setAxisAngleFromQuaternion: function ( q ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

			// q is assumed to be normalized

			this.w = 2 * Math.acos( q.w );

			var s = Math.sqrt( 1 - q.w * q.w );

			if ( s < 0.0001 ) {

				this.x = 1;
				this.y = 0;
				this.z = 0;

			} else {

				this.x = q.x / s;
				this.y = q.y / s;
				this.z = q.z / s;

			}

			return this;

		},

		setAxisAngleFromRotationMatrix: function ( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var angle, x, y, z,		// variables for result
				epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

				te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
			     ( Math.abs( m13 - m31 ) < epsilon ) &&
			     ( Math.abs( m23 - m32 ) < epsilon ) ) {

				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms

				if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
				     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
				     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
				     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

					// this singularity is identity matrix so angle = 0

					this.set( 1, 0, 0, 0 );

					return this; // zero angle, arbitrary axis

				}

				// otherwise this singularity is angle = 180

				angle = Math.PI;

				var xx = ( m11 + 1 ) / 2;
				var yy = ( m22 + 1 ) / 2;
				var zz = ( m33 + 1 ) / 2;
				var xy = ( m12 + m21 ) / 4;
				var xz = ( m13 + m31 ) / 4;
				var yz = ( m23 + m32 ) / 4;

				if ( ( xx > yy ) && ( xx > zz ) ) {

					// m11 is the largest diagonal term

					if ( xx < epsilon ) {

						x = 0;
						y = 0.707106781;
						z = 0.707106781;

					} else {

						x = Math.sqrt( xx );
						y = xy / x;
						z = xz / x;

					}

				} else if ( yy > zz ) {

					// m22 is the largest diagonal term

					if ( yy < epsilon ) {

						x = 0.707106781;
						y = 0;
						z = 0.707106781;

					} else {

						y = Math.sqrt( yy );
						x = xy / y;
						z = yz / y;

					}

				} else {

					// m33 is the largest diagonal term so base result on this

					if ( zz < epsilon ) {

						x = 0.707106781;
						y = 0.707106781;
						z = 0;

					} else {

						z = Math.sqrt( zz );
						x = xz / z;
						y = yz / z;

					}

				}

				this.set( x, y, z, angle );

				return this; // return 180 deg rotation

			}

			// as we have reached here there are no singularities so we can handle normally

			var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
			                   ( m13 - m31 ) * ( m13 - m31 ) +
			                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

			if ( Math.abs( s ) < 0.001 ) s = 1;

			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case

			this.x = ( m32 - m23 ) / s;
			this.y = ( m13 - m31 ) / s;
			this.z = ( m21 - m12 ) / s;
			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

			return this;

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );
			this.w = Math.min( this.w, v.w );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );
			this.w = Math.max( this.w, v.w );

			return this;

		},

		clamp: function ( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );
			this.w = Math.max( min.w, Math.min( max.w, this.w ) );

			return this;

		},

		clampScalar: function () {

			var min, max;

			return function clampScalar( minVal, maxVal ) {

				if ( min === undefined ) {

					min = new Vector4();
					max = new Vector4();

				}

				min.set( minVal, minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal, maxVal );

				return this.clamp( min, max );

			};

		}(),

		clampLength: function ( min, max ) {

			var length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
			this.w = Math.floor( this.w );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
			this.w = Math.ceil( this.w );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
			this.w = Math.round( this.w );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
			this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
			this.w = - this.w;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

		},

		manhattanLength: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

		},

		normalize: function () {

			return this.divideScalar( this.length() || 1 );

		},

		setLength: function ( length ) {

			return this.normalize().multiplyScalar( length );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
			this.w += ( v.w - this.w ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
			this.w = array[ offset + 3 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
			array[ offset + 3 ] = this.w;

			return array;

		},

		fromBufferAttribute: function ( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );
			this.w = attribute.getW( index );

			return this;

		}

	} );

	/**
	 * @author szimek / https://github.com/szimek/
	 * @author alteredq / http://alteredqualia.com/
	 * @author Marius Kintel / https://github.com/kintel
	 */

	/*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/
	function WebGLRenderTarget( width, height, options ) {

		this.width = width;
		this.height = height;

		this.scissor = new Vector4( 0, 0, width, height );
		this.scissorTest = false;

		this.viewport = new Vector4( 0, 0, width, height );

		options = options || {};

		this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
		this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

	}

	WebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: WebGLRenderTarget,

		isWebGLRenderTarget: true,

		setSize: function ( width, height ) {

			if ( this.width !== width || this.height !== height ) {

				this.width = width;
				this.height = height;

				this.dispose();

			}

			this.viewport.set( 0, 0, width, height );
			this.scissor.set( 0, 0, width, height );

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.width = source.width;
			this.height = source.height;

			this.viewport.copy( source.viewport );

			this.texture = source.texture.clone();

			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;
			this.depthTexture = source.depthTexture;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 * @author Matt DesLauriers / @mattdesl
	 */

	function WebGLMultisampleRenderTarget( width, height, options ) {

		WebGLRenderTarget.call( this, width, height, options );

		this.samples = 4;

	}

	WebGLMultisampleRenderTarget.prototype = Object.assign( Object.create( WebGLRenderTarget.prototype ), {

		constructor: WebGLMultisampleRenderTarget,

		isWebGLMultisampleRenderTarget: true,

		copy: function ( source ) {

			WebGLRenderTarget.prototype.copy.call( this, source );

			this.samples = source.samples;

			return this;

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com
	 */

	function WebGLRenderTargetCube( width, height, options ) {

		WebGLRenderTarget.call( this, width, height, options );

	}

	WebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );
	WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;

	WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

		Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.image = { data: data, width: width, height: height };

		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;

	}

	DataTexture.prototype = Object.create( Texture.prototype );
	DataTexture.prototype.constructor = DataTexture;

	DataTexture.prototype.isDataTexture = true;

	/**
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Box3( min, max ) {

		this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
		this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );

	}

	Object.assign( Box3.prototype, {

		isBox3: true,

		set: function ( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		},

		setFromArray: function ( array ) {

			var minX = + Infinity;
			var minY = + Infinity;
			var minZ = + Infinity;

			var maxX = - Infinity;
			var maxY = - Infinity;
			var maxZ = - Infinity;

			for ( var i = 0, l = array.length; i < l; i += 3 ) {

				var x = array[ i ];
				var y = array[ i + 1 ];
				var z = array[ i + 2 ];

				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( z < minZ ) minZ = z;

				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;
				if ( z > maxZ ) maxZ = z;

			}

			this.min.set( minX, minY, minZ );
			this.max.set( maxX, maxY, maxZ );

			return this;

		},

		setFromBufferAttribute: function ( attribute ) {

			var minX = + Infinity;
			var minY = + Infinity;
			var minZ = + Infinity;

			var maxX = - Infinity;
			var maxY = - Infinity;
			var maxZ = - Infinity;

			for ( var i = 0, l = attribute.count; i < l; i ++ ) {

				var x = attribute.getX( i );
				var y = attribute.getY( i );
				var z = attribute.getZ( i );

				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( z < minZ ) minZ = z;

				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;
				if ( z > maxZ ) maxZ = z;

			}

			this.min.set( minX, minY, minZ );
			this.max.set( maxX, maxY, maxZ );

			return this;

		},

		setFromPoints: function ( points ) {

			this.makeEmpty();

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] );

			}

			return this;

		},

		setFromCenterAndSize: function () {

			var v1 = new Vector3();

			return function setFromCenterAndSize( center, size ) {

				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );

				return this;

			};

		}(),

		setFromObject: function ( object ) {

			this.makeEmpty();

			return this.expandByObject( object );

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		},

		makeEmpty: function () {

			this.min.x = this.min.y = this.min.z = + Infinity;
			this.max.x = this.max.y = this.max.z = - Infinity;

			return this;

		},

		isEmpty: function () {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

		},

		getCenter: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box3: .getCenter() target is now required' );
				target = new Vector3();

			}

			return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		},

		getSize: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box3: .getSize() target is now required' );
				target = new Vector3();

			}

			return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

		},

		expandByPoint: function ( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		},

		expandByVector: function ( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		},

		expandByScalar: function ( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		},

		expandByObject: function () {

			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms

			var scope, i, l;

			var v1 = new Vector3();

			function traverse( node ) {

				var geometry = node.geometry;

				if ( geometry !== undefined ) {

					if ( geometry.isGeometry ) {

						var vertices = geometry.vertices;

						for ( i = 0, l = vertices.length; i < l; i ++ ) {

							v1.copy( vertices[ i ] );
							v1.applyMatrix4( node.matrixWorld );

							scope.expandByPoint( v1 );

						}

					} else if ( geometry.isBufferGeometry ) {

						var attribute = geometry.attributes.position;

						if ( attribute !== undefined ) {

							for ( i = 0, l = attribute.count; i < l; i ++ ) {

								v1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );

								scope.expandByPoint( v1 );

							}

						}

					}

				}

			}

			return function expandByObject( object ) {

				scope = this;

				object.updateMatrixWorld( true );

				object.traverse( traverse );

				return this;

			};

		}(),

		containsPoint: function ( point ) {

			return point.x < this.min.x || point.x > this.max.x ||
				point.y < this.min.y || point.y > this.max.y ||
				point.z < this.min.z || point.z > this.max.z ? false : true;

		},

		containsBox: function ( box ) {

			return this.min.x <= box.min.x && box.max.x <= this.max.x &&
				this.min.y <= box.min.y && box.max.y <= this.max.y &&
				this.min.z <= box.min.z && box.max.z <= this.max.z;

		},

		getParameter: function ( point, target ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			if ( target === undefined ) {

				console.warn( 'THREE.Box3: .getParameter() target is now required' );
				target = new Vector3();

			}

			return target.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y ),
				( point.z - this.min.z ) / ( this.max.z - this.min.z )
			);

		},

		intersectsBox: function ( box ) {

			// using 6 splitting planes to rule out intersections.
			return box.max.x < this.min.x || box.min.x > this.max.x ||
				box.max.y < this.min.y || box.min.y > this.max.y ||
				box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

		},

		intersectsSphere: ( function () {

			var closestPoint = new Vector3();

			return function intersectsSphere( sphere ) {

				// Find the point on the AABB closest to the sphere center.
				this.clampPoint( sphere.center, closestPoint );

				// If that point is inside the sphere, the AABB and sphere intersect.
				return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

			};

		} )(),

		intersectsPlane: function ( plane ) {

			// We compute the minimum and maximum dot product values. If those values
			// are on the same side (back or front) of the plane, then there is no intersection.

			var min, max;

			if ( plane.normal.x > 0 ) {

				min = plane.normal.x * this.min.x;
				max = plane.normal.x * this.max.x;

			} else {

				min = plane.normal.x * this.max.x;
				max = plane.normal.x * this.min.x;

			}

			if ( plane.normal.y > 0 ) {

				min += plane.normal.y * this.min.y;
				max += plane.normal.y * this.max.y;

			} else {

				min += plane.normal.y * this.max.y;
				max += plane.normal.y * this.min.y;

			}

			if ( plane.normal.z > 0 ) {

				min += plane.normal.z * this.min.z;
				max += plane.normal.z * this.max.z;

			} else {

				min += plane.normal.z * this.max.z;
				max += plane.normal.z * this.min.z;

			}

			return ( min <= - plane.constant && max >= - plane.constant );

		},

		intersectsTriangle: ( function () {

			// triangle centered vertices
			var v0 = new Vector3();
			var v1 = new Vector3();
			var v2 = new Vector3();

			// triangle edge vectors
			var f0 = new Vector3();
			var f1 = new Vector3();
			var f2 = new Vector3();

			var testAxis = new Vector3();

			var center = new Vector3();
			var extents = new Vector3();

			var triangleNormal = new Vector3();

			function satForAxes( axes ) {

				var i, j;

				for ( i = 0, j = axes.length - 3; i <= j; i += 3 ) {

					testAxis.fromArray( axes, i );
					// project the aabb onto the seperating axis
					var r = extents.x * Math.abs( testAxis.x ) + extents.y * Math.abs( testAxis.y ) + extents.z * Math.abs( testAxis.z );
					// project all 3 vertices of the triangle onto the seperating axis
					var p0 = v0.dot( testAxis );
					var p1 = v1.dot( testAxis );
					var p2 = v2.dot( testAxis );
					// actual test, basically see if either of the most extreme of the triangle points intersects r
					if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

						// points of the projected triangle are outside the projected half-length of the aabb
						// the axis is seperating and we can exit
						return false;

					}

				}

				return true;

			}

			return function intersectsTriangle( triangle ) {

				if ( this.isEmpty() ) {

					return false;

				}

				// compute box center and extents
				this.getCenter( center );
				extents.subVectors( this.max, center );

				// translate triangle to aabb origin
				v0.subVectors( triangle.a, center );
				v1.subVectors( triangle.b, center );
				v2.subVectors( triangle.c, center );

				// compute edge vectors for triangle
				f0.subVectors( v1, v0 );
				f1.subVectors( v2, v1 );
				f2.subVectors( v0, v2 );

				// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
				// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
				// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
				var axes = [
					0, - f0.z, f0.y, 0, - f1.z, f1.y, 0, - f2.z, f2.y,
					f0.z, 0, - f0.x, f1.z, 0, - f1.x, f2.z, 0, - f2.x,
					- f0.y, f0.x, 0, - f1.y, f1.x, 0, - f2.y, f2.x, 0
				];
				if ( ! satForAxes( axes ) ) {

					return false;

				}

				// test 3 face normals from the aabb
				axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
				if ( ! satForAxes( axes ) ) {

					return false;

				}

				// finally testing the face normal of the triangle
				// use already existing triangle edge vectors here
				triangleNormal.crossVectors( f0, f1 );
				axes = [ triangleNormal.x, triangleNormal.y, triangleNormal.z ];
				return satForAxes( axes );

			};

		} )(),

		clampPoint: function ( point, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box3: .clampPoint() target is now required' );
				target = new Vector3();

			}

			return target.copy( point ).clamp( this.min, this.max );

		},

		distanceToPoint: function () {

			var v1 = new Vector3();

			return function distanceToPoint( point ) {

				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();

			};

		}(),

		getBoundingSphere: function () {

			var v1 = new Vector3();

			return function getBoundingSphere( target ) {

				if ( target === undefined ) {

					console.error( 'THREE.Box3: .getBoundingSphere() target is now required' );
					//target = new Sphere(); // removed to avoid cyclic dependency

				}

				this.getCenter( target.center );

				target.radius = this.getSize( v1 ).length() * 0.5;

				return target;

			};

		}(),

		intersect: function ( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
			if ( this.isEmpty() ) this.makeEmpty();

			return this;

		},

		union: function ( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		},

		applyMatrix4: function () {

			var points = [
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3()
			];

			return function applyMatrix4( matrix ) {

				// transform of empty box is an empty box.
				if ( this.isEmpty() ) return this;

				// NOTE: I am using a binary pattern to specify all 2^3 combinations below
				points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
				points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
				points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
				points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
				points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
				points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
				points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
				points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

				this.setFromPoints( points );

				return this;

			};

		}(),

		translate: function ( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		},

		equals: function ( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Sphere( center, radius ) {

		this.center = ( center !== undefined ) ? center : new Vector3();
		this.radius = ( radius !== undefined ) ? radius : 0;

	}

	Object.assign( Sphere.prototype, {

		set: function ( center, radius ) {

			this.center.copy( center );
			this.radius = radius;

			return this;

		},

		setFromPoints: function () {

			var box = new Box3();

			return function setFromPoints( points, optionalCenter ) {

				var center = this.center;

				if ( optionalCenter !== undefined ) {

					center.copy( optionalCenter );

				} else {

					box.setFromPoints( points ).getCenter( center );

				}

				var maxRadiusSq = 0;

				for ( var i = 0, il = points.length; i < il; i ++ ) {

					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

				}

				this.radius = Math.sqrt( maxRadiusSq );

				return this;

			};

		}(),

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( sphere ) {

			this.center.copy( sphere.center );
			this.radius = sphere.radius;

			return this;

		},

		empty: function () {

			return ( this.radius <= 0 );

		},

		containsPoint: function ( point ) {

			return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

		},

		distanceToPoint: function ( point ) {

			return ( point.distanceTo( this.center ) - this.radius );

		},

		intersectsSphere: function ( sphere ) {

			var radiusSum = this.radius + sphere.radius;

			return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

		},

		intersectsBox: function ( box ) {

			return box.intersectsSphere( this );

		},

		intersectsPlane: function ( plane ) {

			return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

		},

		clampPoint: function ( point, target ) {

			var deltaLengthSq = this.center.distanceToSquared( point );

			if ( target === undefined ) {

				console.warn( 'THREE.Sphere: .clampPoint() target is now required' );
				target = new Vector3();

			}

			target.copy( point );

			if ( deltaLengthSq > ( this.radius * this.radius ) ) {

				target.sub( this.center ).normalize();
				target.multiplyScalar( this.radius ).add( this.center );

			}

			return target;

		},

		getBoundingBox: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Sphere: .getBoundingBox() target is now required' );
				target = new Box3();

			}

			target.set( this.center, this.center );
			target.expandByScalar( this.radius );

			return target;

		},

		applyMatrix4: function ( matrix ) {

			this.center.applyMatrix4( matrix );
			this.radius = this.radius * matrix.getMaxScaleOnAxis();

			return this;

		},

		translate: function ( offset ) {

			this.center.add( offset );

			return this;

		},

		equals: function ( sphere ) {

			return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 */

	function Plane( normal, constant ) {

		// normal is assumed to be normalized

		this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
		this.constant = ( constant !== undefined ) ? constant : 0;

	}

	Object.assign( Plane.prototype, {

		set: function ( normal, constant ) {

			this.normal.copy( normal );
			this.constant = constant;

			return this;

		},

		setComponents: function ( x, y, z, w ) {

			this.normal.set( x, y, z );
			this.constant = w;

			return this;

		},

		setFromNormalAndCoplanarPoint: function ( normal, point ) {

			this.normal.copy( normal );
			this.constant = - point.dot( this.normal );

			return this;

		},

		setFromCoplanarPoints: function () {

			var v1 = new Vector3();
			var v2 = new Vector3();

			return function setFromCoplanarPoints( a, b, c ) {

				var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

				// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

				this.setFromNormalAndCoplanarPoint( normal, a );

				return this;

			};

		}(),

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( plane ) {

			this.normal.copy( plane.normal );
			this.constant = plane.constant;

			return this;

		},

		normalize: function () {

			// Note: will lead to a divide by zero if the plane is invalid.

			var inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar( inverseNormalLength );
			this.constant *= inverseNormalLength;

			return this;

		},

		negate: function () {

			this.constant *= - 1;
			this.normal.negate();

			return this;

		},

		distanceToPoint: function ( point ) {

			return this.normal.dot( point ) + this.constant;

		},

		distanceToSphere: function ( sphere ) {

			return this.distanceToPoint( sphere.center ) - sphere.radius;

		},

		projectPoint: function ( point, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Plane: .projectPoint() target is now required' );
				target = new Vector3();

			}

			return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

		},

		intersectLine: function () {

			var v1 = new Vector3();

			return function intersectLine( line, target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Plane: .intersectLine() target is now required' );
					target = new Vector3();

				}

				var direction = line.delta( v1 );

				var denominator = this.normal.dot( direction );

				if ( denominator === 0 ) {

					// line is coplanar, return origin
					if ( this.distanceToPoint( line.start ) === 0 ) {

						return target.copy( line.start );

					}

					// Unsure if this is the correct method to handle this case.
					return undefined;

				}

				var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

				if ( t < 0 || t > 1 ) {

					return undefined;

				}

				return target.copy( direction ).multiplyScalar( t ).add( line.start );

			};

		}(),

		intersectsLine: function ( line ) {

			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

			var startSign = this.distanceToPoint( line.start );
			var endSign = this.distanceToPoint( line.end );

			return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

		},

		intersectsBox: function ( box ) {

			return box.intersectsPlane( this );

		},

		intersectsSphere: function ( sphere ) {

			return sphere.intersectsPlane( this );

		},

		coplanarPoint: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Plane: .coplanarPoint() target is now required' );
				target = new Vector3();

			}

			return target.copy( this.normal ).multiplyScalar( - this.constant );

		},

		applyMatrix4: function () {

			var v1 = new Vector3();
			var m1 = new Matrix3();

			return function applyMatrix4( matrix, optionalNormalMatrix ) {

				var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );

				var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );

				var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

				this.constant = - referencePoint.dot( normal );

				return this;

			};

		}(),

		translate: function ( offset ) {

			this.constant -= offset.dot( this.normal );

			return this;

		},

		equals: function ( plane ) {

			return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / http://clara.io
	 */

	function Frustum( p0, p1, p2, p3, p4, p5 ) {

		this.planes = [

			( p0 !== undefined ) ? p0 : new Plane(),
			( p1 !== undefined ) ? p1 : new Plane(),
			( p2 !== undefined ) ? p2 : new Plane(),
			( p3 !== undefined ) ? p3 : new Plane(),
			( p4 !== undefined ) ? p4 : new Plane(),
			( p5 !== undefined ) ? p5 : new Plane()

		];

	}

	Object.assign( Frustum.prototype, {

		set: function ( p0, p1, p2, p3, p4, p5 ) {

			var planes = this.planes;

			planes[ 0 ].copy( p0 );
			planes[ 1 ].copy( p1 );
			planes[ 2 ].copy( p2 );
			planes[ 3 ].copy( p3 );
			planes[ 4 ].copy( p4 );
			planes[ 5 ].copy( p5 );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( frustum ) {

			var planes = this.planes;

			for ( var i = 0; i < 6; i ++ ) {

				planes[ i ].copy( frustum.planes[ i ] );

			}

			return this;

		},

		setFromMatrix: function ( m ) {

			var planes = this.planes;
			var me = m.elements;
			var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
			var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
			var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
			var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

			planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
			planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
			planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
			planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
			planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

			return this;

		},

		intersectsObject: function () {

			var sphere = new Sphere();

			return function intersectsObject( object ) {

				var geometry = object.geometry;

				if ( geometry.boundingSphere === null )
					geometry.computeBoundingSphere();

				sphere.copy( geometry.boundingSphere )
					.applyMatrix4( object.matrixWorld );

				return this.intersectsSphere( sphere );

			};

		}(),

		intersectsSprite: function () {

			var sphere = new Sphere();

			return function intersectsSprite( sprite ) {

				sphere.center.set( 0, 0, 0 );
				sphere.radius = 0.7071067811865476;
				sphere.applyMatrix4( sprite.matrixWorld );

				return this.intersectsSphere( sphere );

			};

		}(),

		intersectsSphere: function ( sphere ) {

			var planes = this.planes;
			var center = sphere.center;
			var negRadius = - sphere.radius;

			for ( var i = 0; i < 6; i ++ ) {

				var distance = planes[ i ].distanceToPoint( center );

				if ( distance < negRadius ) {

					return false;

				}

			}

			return true;

		},

		intersectsBox: function () {

			var p = new Vector3();

			return function intersectsBox( box ) {

				var planes = this.planes;

				for ( var i = 0; i < 6; i ++ ) {

					var plane = planes[ i ];

					// corner at max distance

					p.x = plane.normal.x > 0 ? box.max.x : box.min.x;
					p.y = plane.normal.y > 0 ? box.max.y : box.min.y;
					p.z = plane.normal.z > 0 ? box.max.z : box.min.z;

					if ( plane.distanceToPoint( p ) < 0 ) {

						return false;

					}

				}

				return true;

			};

		}(),

		containsPoint: function ( point ) {

			var planes = this.planes;

			for ( var i = 0; i < 6; i ++ ) {

				if ( planes[ i ].distanceToPoint( point ) < 0 ) {

					return false;

				}

			}

			return true;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author jordi_ros / http://plattsoft.com
	 * @author D1plo1d / http://github.com/D1plo1d
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author timknip / http://www.floorplanner.com/
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Matrix4() {

		this.elements = [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	Object.assign( Matrix4.prototype, {

		isMatrix4: true,

		set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

			var te = this.elements;

			te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
			te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
			te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
			te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		clone: function () {

			return new Matrix4().fromArray( this.elements );

		},

		copy: function ( m ) {

			var te = this.elements;
			var me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
			te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
			te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
			te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

			return this;

		},

		copyPosition: function ( m ) {

			var te = this.elements, me = m.elements;

			te[ 12 ] = me[ 12 ];
			te[ 13 ] = me[ 13 ];
			te[ 14 ] = me[ 14 ];

			return this;

		},

		extractBasis: function ( xAxis, yAxis, zAxis ) {

			xAxis.setFromMatrixColumn( this, 0 );
			yAxis.setFromMatrixColumn( this, 1 );
			zAxis.setFromMatrixColumn( this, 2 );

			return this;

		},

		makeBasis: function ( xAxis, yAxis, zAxis ) {

			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0, 0, 0, 1
			);

			return this;

		},

		extractRotation: function () {

			var v1 = new Vector3();

			return function extractRotation( m ) {

				// this method does not support reflection matrices

				var te = this.elements;
				var me = m.elements;

				var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
				var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
				var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();

				te[ 0 ] = me[ 0 ] * scaleX;
				te[ 1 ] = me[ 1 ] * scaleX;
				te[ 2 ] = me[ 2 ] * scaleX;
				te[ 3 ] = 0;

				te[ 4 ] = me[ 4 ] * scaleY;
				te[ 5 ] = me[ 5 ] * scaleY;
				te[ 6 ] = me[ 6 ] * scaleY;
				te[ 7 ] = 0;

				te[ 8 ] = me[ 8 ] * scaleZ;
				te[ 9 ] = me[ 9 ] * scaleZ;
				te[ 10 ] = me[ 10 ] * scaleZ;
				te[ 11 ] = 0;

				te[ 12 ] = 0;
				te[ 13 ] = 0;
				te[ 14 ] = 0;
				te[ 15 ] = 1;

				return this;

			};

		}(),

		makeRotationFromEuler: function ( euler ) {

			if ( ! ( euler && euler.isEuler ) ) {

				console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

			}

			var te = this.elements;

			var x = euler.x, y = euler.y, z = euler.z;
			var a = Math.cos( x ), b = Math.sin( x );
			var c = Math.cos( y ), d = Math.sin( y );
			var e = Math.cos( z ), f = Math.sin( z );

			if ( euler.order === 'XYZ' ) {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = - c * f;
				te[ 8 ] = d;

				te[ 1 ] = af + be * d;
				te[ 5 ] = ae - bf * d;
				te[ 9 ] = - b * c;

				te[ 2 ] = bf - ae * d;
				te[ 6 ] = be + af * d;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YXZ' ) {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce + df * b;
				te[ 4 ] = de * b - cf;
				te[ 8 ] = a * d;

				te[ 1 ] = a * f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b;

				te[ 2 ] = cf * b - de;
				te[ 6 ] = df + ce * b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZXY' ) {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce - df * b;
				te[ 4 ] = - a * f;
				te[ 8 ] = de + cf * b;

				te[ 1 ] = cf + de * b;
				te[ 5 ] = a * e;
				te[ 9 ] = df - ce * b;

				te[ 2 ] = - a * d;
				te[ 6 ] = b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZYX' ) {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = be * d - af;
				te[ 8 ] = ae * d + bf;

				te[ 1 ] = c * f;
				te[ 5 ] = bf * d + ae;
				te[ 9 ] = af * d - be;

				te[ 2 ] = - d;
				te[ 6 ] = b * c;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YZX' ) {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = bd - ac * f;
				te[ 8 ] = bc * f + ad;

				te[ 1 ] = f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b * e;

				te[ 2 ] = - d * e;
				te[ 6 ] = ad * f + bc;
				te[ 10 ] = ac - bd * f;

			} else if ( euler.order === 'XZY' ) {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = - f;
				te[ 8 ] = d * e;

				te[ 1 ] = ac * f + bd;
				te[ 5 ] = a * e;
				te[ 9 ] = ad * f - bc;

				te[ 2 ] = bc * f - ad;
				te[ 6 ] = b * e;
				te[ 10 ] = bd * f + ac;

			}

			// bottom row
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;

			// last column
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		},

		makeRotationFromQuaternion: function () {

			var zero = new Vector3( 0, 0, 0 );
			var one = new Vector3( 1, 1, 1 );

			return function makeRotationFromQuaternion( q ) {

				return this.compose( zero, q, one );

			};

		}(),

		lookAt: function () {

			var x = new Vector3();
			var y = new Vector3();
			var z = new Vector3();

			return function lookAt( eye, target, up ) {

				var te = this.elements;

				z.subVectors( eye, target );

				if ( z.lengthSq() === 0 ) {

					// eye and target are in the same position

					z.z = 1;

				}

				z.normalize();
				x.crossVectors( up, z );

				if ( x.lengthSq() === 0 ) {

					// up and z are parallel

					if ( Math.abs( up.z ) === 1 ) {

						z.x += 0.0001;

					} else {

						z.z += 0.0001;

					}

					z.normalize();
					x.crossVectors( up, z );

				}

				x.normalize();
				y.crossVectors( z, x );

				te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
				te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
				te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

				return this;

			};

		}(),

		multiply: function ( m, n ) {

			if ( n !== undefined ) {

				console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
				return this.multiplyMatrices( m, n );

			}

			return this.multiplyMatrices( this, m );

		},

		premultiply: function ( m ) {

			return this.multiplyMatrices( m, this );

		},

		multiplyMatrices: function ( a, b ) {

			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;

			var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
			var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
			var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
			var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

			var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
			var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
			var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
			var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

			te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

			return this;

		},

		multiplyScalar: function ( s ) {

			var te = this.elements;

			te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
			te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
			te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
			te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

			return this;

		},

		applyToBufferAttribute: function () {

			var v1 = new Vector3();

			return function applyToBufferAttribute( attribute ) {

				for ( var i = 0, l = attribute.count; i < l; i ++ ) {

					v1.x = attribute.getX( i );
					v1.y = attribute.getY( i );
					v1.z = attribute.getZ( i );

					v1.applyMatrix4( this );

					attribute.setXYZ( i, v1.x, v1.y, v1.z );

				}

				return attribute;

			};

		}(),

		determinant: function () {

			var te = this.elements;

			var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
			var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
			var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
			var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

			return (
				n41 * (
					+ n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
				)

			);

		},

		transpose: function () {

			var te = this.elements;
			var tmp;

			tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
			tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
			tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

			tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
			tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
			tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

			return this;

		},

		setPosition: function ( v ) {

			var te = this.elements;

			te[ 12 ] = v.x;
			te[ 13 ] = v.y;
			te[ 14 ] = v.z;

			return this;

		},

		getInverse: function ( m, throwOnDegenerate ) {

			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			var te = this.elements,
				me = m.elements,

				n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
				n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
				n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
				n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

				t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
				t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
				t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
				t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

			var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

			if ( det === 0 ) {

				var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";

				if ( throwOnDegenerate === true ) {

					throw new Error( msg );

				} else {

					console.warn( msg );

				}

				return this.identity();

			}

			var detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
			te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
			te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

			te[ 4 ] = t12 * detInv;
			te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
			te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
			te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

			te[ 8 ] = t13 * detInv;
			te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
			te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
			te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

			te[ 12 ] = t14 * detInv;
			te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
			te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
			te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

			return this;

		},

		scale: function ( v ) {

			var te = this.elements;
			var x = v.x, y = v.y, z = v.z;

			te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
			te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
			te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
			te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

			return this;

		},

		getMaxScaleOnAxis: function () {

			var te = this.elements;

			var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
			var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
			var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

			return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

		},

		makeTranslation: function ( x, y, z ) {

			this.set(

				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationX: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				1, 0, 0, 0,
				0, c, - s, 0,
				0, s, c, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationY: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				 c, 0, s, 0,
				 0, 1, 0, 0,
				- s, 0, c, 0,
				 0, 0, 0, 1

			);

			return this;

		},

		makeRotationZ: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				c, - s, 0, 0,
				s, c, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationAxis: function ( axis, angle ) {

			// Based on http://www.gamedev.net/reference/articles/article1199.asp

			var c = Math.cos( angle );
			var s = Math.sin( angle );
			var t = 1 - c;
			var x = axis.x, y = axis.y, z = axis.z;
			var tx = t * x, ty = t * y;

			this.set(

				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1

			);

			 return this;

		},

		makeScale: function ( x, y, z ) {

			this.set(

				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeShear: function ( x, y, z ) {

			this.set(

				1, y, z, 0,
				x, 1, z, 0,
				x, y, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		compose: function ( position, quaternion, scale ) {

			var te = this.elements;

			var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
			var x2 = x + x,	y2 = y + y, z2 = z + z;
			var xx = x * x2, xy = x * y2, xz = x * z2;
			var yy = y * y2, yz = y * z2, zz = z * z2;
			var wx = w * x2, wy = w * y2, wz = w * z2;

			var sx = scale.x, sy = scale.y, sz = scale.z;

		        te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
		        te[ 1 ] = ( xy + wz ) * sx;
		        te[ 2 ] = ( xz - wy ) * sx;
		        te[ 3 ] = 0;

		        te[ 4 ] = ( xy - wz ) * sy;
		        te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
		        te[ 6 ] = ( yz + wx ) * sy;
		        te[ 7 ] = 0;

		        te[ 8 ] = ( xz + wy ) * sz;
		        te[ 9 ] = ( yz - wx ) * sz;
		        te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
		        te[ 11 ] = 0;

		        te[ 12 ] = position.x;
		        te[ 13 ] = position.y;
		        te[ 14 ] = position.z;
		        te[ 15 ] = 1;

		        return this;

		},

		decompose: function () {

			var vector = new Vector3();
			var matrix = new Matrix4();

			return function decompose( position, quaternion, scale ) {

				var te = this.elements;

				var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
				var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
				var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

				// if determine is negative, we need to invert one scale
				var det = this.determinant();
				if ( det < 0 ) sx = - sx;

				position.x = te[ 12 ];
				position.y = te[ 13 ];
				position.z = te[ 14 ];

				// scale the rotation part
				matrix.copy( this );

				var invSX = 1 / sx;
				var invSY = 1 / sy;
				var invSZ = 1 / sz;

				matrix.elements[ 0 ] *= invSX;
				matrix.elements[ 1 ] *= invSX;
				matrix.elements[ 2 ] *= invSX;

				matrix.elements[ 4 ] *= invSY;
				matrix.elements[ 5 ] *= invSY;
				matrix.elements[ 6 ] *= invSY;

				matrix.elements[ 8 ] *= invSZ;
				matrix.elements[ 9 ] *= invSZ;
				matrix.elements[ 10 ] *= invSZ;

				quaternion.setFromRotationMatrix( matrix );

				scale.x = sx;
				scale.y = sy;
				scale.z = sz;

				return this;

			};

		}(),

		makePerspective: function ( left, right, top, bottom, near, far ) {

			if ( far === undefined ) {

				console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

			}

			var te = this.elements;
			var x = 2 * near / ( right - left );
			var y = 2 * near / ( top - bottom );

			var a = ( right + left ) / ( right - left );
			var b = ( top + bottom ) / ( top - bottom );
			var c = - ( far + near ) / ( far - near );
			var d = - 2 * far * near / ( far - near );

			te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
			te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

			return this;

		},

		makeOrthographic: function ( left, right, top, bottom, near, far ) {

			var te = this.elements;
			var w = 1.0 / ( right - left );
			var h = 1.0 / ( top - bottom );
			var p = 1.0 / ( far - near );

			var x = ( right + left ) * w;
			var y = ( top + bottom ) * h;
			var z = ( far + near ) * p;

			te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
			te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

			return this;

		},

		equals: function ( matrix ) {

			var te = this.elements;
			var me = matrix.elements;

			for ( var i = 0; i < 16; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			for ( var i = 0; i < 16; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			var te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
			array[ offset + 3 ] = te[ 3 ];

			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];

			array[ offset + 8 ] = te[ 8 ];
			array[ offset + 9 ] = te[ 9 ];
			array[ offset + 10 ] = te[ 10 ];
			array[ offset + 11 ] = te[ 11 ];

			array[ offset + 12 ] = te[ 12 ];
			array[ offset + 13 ] = te[ 13 ];
			array[ offset + 14 ] = te[ 14 ];
			array[ offset + 15 ] = te[ 15 ];

			return array;

		}

	} );

	var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";

	var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

	var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";

	var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";

	var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

	var begin_vertex = "vec3 transformed = vec3( position );";

	var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

	var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick( specularColor, dotNV );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}";

	var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

	var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

	var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

	var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif";

	var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif";

	var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";

	var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

	var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

	var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";

	var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}";

	var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif";

	var defaultnormal_vertex = "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

	var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

	var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif";

	var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

	var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

	var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

	var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";

	var envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

	var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

	var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

	var envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

	var fog_vertex = "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif";

	var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";

	var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

	var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

	var gradientmap_pars_fragment = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif";

	var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif";

	var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

	var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif";

	var lights_pars_begin = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";

	var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";

	var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

	var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";

	var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif";

	var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#endif\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\t\tvec3 diffuse = material.diffuseColor;\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\t#else\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#endif\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

	var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif";

	var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif";

	var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif";

	var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

	var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif";

	var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

	var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif";

	var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";

	var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

	var map_particle_fragment = "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif";

	var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif";

	var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

	var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

	var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif";

	var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

	var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";

	var normal_fragment_begin = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif";

	var normal_fragment_maps = "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\t#ifdef USE_TANGENT\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy = normalScale * mapN.xy;\n\t\t\tnormal = normalize( vTBN * mapN );\n\t\t#else\n\t\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t\t#endif\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif";

	var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif";

	var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";

	var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

	var project_vertex = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;";

	var dithering_fragment = "#if defined( DITHERING )\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

	var dithering_pars_fragment = "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

	var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

	var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

	var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

	var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif";

	var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif";

	var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}";

	var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

	var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";

	var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

	var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

	var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

	var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

	var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

	var tonemapping_pars_fragment = "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}";

	var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";

	var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif";

	var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

	var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

	var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";

	var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";

	var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif";

	var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

	var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

	var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}";

	var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}";

	var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

	var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

	var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

	var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

	var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

	var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

	var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

	var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

	var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

	var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";

	var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

	var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

	var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

	var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}";

	var shadow_vert = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

	var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

	var ShaderChunk = {
		alphamap_fragment: alphamap_fragment,
		alphamap_pars_fragment: alphamap_pars_fragment,
		alphatest_fragment: alphatest_fragment,
		aomap_fragment: aomap_fragment,
		aomap_pars_fragment: aomap_pars_fragment,
		begin_vertex: begin_vertex,
		beginnormal_vertex: beginnormal_vertex,
		bsdfs: bsdfs,
		bumpmap_pars_fragment: bumpmap_pars_fragment,
		clipping_planes_fragment: clipping_planes_fragment,
		clipping_planes_pars_fragment: clipping_planes_pars_fragment,
		clipping_planes_pars_vertex: clipping_planes_pars_vertex,
		clipping_planes_vertex: clipping_planes_vertex,
		color_fragment: color_fragment,
		color_pars_fragment: color_pars_fragment,
		color_pars_vertex: color_pars_vertex,
		color_vertex: color_vertex,
		common: common,
		cube_uv_reflection_fragment: cube_uv_reflection_fragment,
		defaultnormal_vertex: defaultnormal_vertex,
		displacementmap_pars_vertex: displacementmap_pars_vertex,
		displacementmap_vertex: displacementmap_vertex,
		emissivemap_fragment: emissivemap_fragment,
		emissivemap_pars_fragment: emissivemap_pars_fragment,
		encodings_fragment: encodings_fragment,
		encodings_pars_fragment: encodings_pars_fragment,
		envmap_fragment: envmap_fragment,
		envmap_pars_fragment: envmap_pars_fragment,
		envmap_pars_vertex: envmap_pars_vertex,
		envmap_physical_pars_fragment: envmap_physical_pars_fragment,
		envmap_vertex: envmap_vertex,
		fog_vertex: fog_vertex,
		fog_pars_vertex: fog_pars_vertex,
		fog_fragment: fog_fragment,
		fog_pars_fragment: fog_pars_fragment,
		gradientmap_pars_fragment: gradientmap_pars_fragment,
		lightmap_fragment: lightmap_fragment,
		lightmap_pars_fragment: lightmap_pars_fragment,
		lights_lambert_vertex: lights_lambert_vertex,
		lights_pars_begin: lights_pars_begin,
		lights_phong_fragment: lights_phong_fragment,
		lights_phong_pars_fragment: lights_phong_pars_fragment,
		lights_physical_fragment: lights_physical_fragment,
		lights_physical_pars_fragment: lights_physical_pars_fragment,
		lights_fragment_begin: lights_fragment_begin,
		lights_fragment_maps: lights_fragment_maps,
		lights_fragment_end: lights_fragment_end,
		logdepthbuf_fragment: logdepthbuf_fragment,
		logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
		logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
		logdepthbuf_vertex: logdepthbuf_vertex,
		map_fragment: map_fragment,
		map_pars_fragment: map_pars_fragment,
		map_particle_fragment: map_particle_fragment,
		map_particle_pars_fragment: map_particle_pars_fragment,
		metalnessmap_fragment: metalnessmap_fragment,
		metalnessmap_pars_fragment: metalnessmap_pars_fragment,
		morphnormal_vertex: morphnormal_vertex,
		morphtarget_pars_vertex: morphtarget_pars_vertex,
		morphtarget_vertex: morphtarget_vertex,
		normal_fragment_begin: normal_fragment_begin,
		normal_fragment_maps: normal_fragment_maps,
		normalmap_pars_fragment: normalmap_pars_fragment,
		packing: packing,
		premultiplied_alpha_fragment: premultiplied_alpha_fragment,
		project_vertex: project_vertex,
		dithering_fragment: dithering_fragment,
		dithering_pars_fragment: dithering_pars_fragment,
		roughnessmap_fragment: roughnessmap_fragment,
		roughnessmap_pars_fragment: roughnessmap_pars_fragment,
		shadowmap_pars_fragment: shadowmap_pars_fragment,
		shadowmap_pars_vertex: shadowmap_pars_vertex,
		shadowmap_vertex: shadowmap_vertex,
		shadowmask_pars_fragment: shadowmask_pars_fragment,
		skinbase_vertex: skinbase_vertex,
		skinning_pars_vertex: skinning_pars_vertex,
		skinning_vertex: skinning_vertex,
		skinnormal_vertex: skinnormal_vertex,
		specularmap_fragment: specularmap_fragment,
		specularmap_pars_fragment: specularmap_pars_fragment,
		tonemapping_fragment: tonemapping_fragment,
		tonemapping_pars_fragment: tonemapping_pars_fragment,
		uv_pars_fragment: uv_pars_fragment,
		uv_pars_vertex: uv_pars_vertex,
		uv_vertex: uv_vertex,
		uv2_pars_fragment: uv2_pars_fragment,
		uv2_pars_vertex: uv2_pars_vertex,
		uv2_vertex: uv2_vertex,
		worldpos_vertex: worldpos_vertex,

		background_frag: background_frag,
		background_vert: background_vert,
		cube_frag: cube_frag,
		cube_vert: cube_vert,
		depth_frag: depth_frag,
		depth_vert: depth_vert,
		distanceRGBA_frag: distanceRGBA_frag,
		distanceRGBA_vert: distanceRGBA_vert,
		equirect_frag: equirect_frag,
		equirect_vert: equirect_vert,
		linedashed_frag: linedashed_frag,
		linedashed_vert: linedashed_vert,
		meshbasic_frag: meshbasic_frag,
		meshbasic_vert: meshbasic_vert,
		meshlambert_frag: meshlambert_frag,
		meshlambert_vert: meshlambert_vert,
		meshmatcap_frag: meshmatcap_frag,
		meshmatcap_vert: meshmatcap_vert,
		meshphong_frag: meshphong_frag,
		meshphong_vert: meshphong_vert,
		meshphysical_frag: meshphysical_frag,
		meshphysical_vert: meshphysical_vert,
		normal_frag: normal_frag,
		normal_vert: normal_vert,
		points_frag: points_frag,
		points_vert: points_vert,
		shadow_frag: shadow_frag,
		shadow_vert: shadow_vert,
		sprite_frag: sprite_frag,
		sprite_vert: sprite_vert
	};

	/**
	 * Uniform Utilities
	 */

	function cloneUniforms( src ) {

		var dst = {};

		for ( var u in src ) {

			dst[ u ] = {};

			for ( var p in src[ u ] ) {

				var property = src[ u ][ p ];

				if ( property && ( property.isColor ||
					property.isMatrix3 || property.isMatrix4 ||
					property.isVector2 || property.isVector3 || property.isVector4 ||
					property.isTexture ) ) {

					dst[ u ][ p ] = property.clone();

				} else if ( Array.isArray( property ) ) {

					dst[ u ][ p ] = property.slice();

				} else {

					dst[ u ][ p ] = property;

				}

			}

		}

		return dst;

	}

	function mergeUniforms( uniforms ) {

		var merged = {};

		for ( var u = 0; u < uniforms.length; u ++ ) {

			var tmp = cloneUniforms( uniforms[ u ] );

			for ( var p in tmp ) {

				merged[ p ] = tmp[ p ];

			}

		}

		return merged;

	}

	// Legacy

	var UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
		'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
		'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
		'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
		'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
		'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
		'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

	function Color( r, g, b ) {

		if ( g === undefined && b === undefined ) {

			// r is THREE.Color, hex or string
			return this.set( r );

		}

		return this.setRGB( r, g, b );

	}

	Object.assign( Color.prototype, {

		isColor: true,

		r: 1, g: 1, b: 1,

		set: function ( value ) {

			if ( value && value.isColor ) {

				this.copy( value );

			} else if ( typeof value === 'number' ) {

				this.setHex( value );

			} else if ( typeof value === 'string' ) {

				this.setStyle( value );

			}

			return this;

		},

		setScalar: function ( scalar ) {

			this.r = scalar;
			this.g = scalar;
			this.b = scalar;

			return this;

		},

		setHex: function ( hex ) {

			hex = Math.floor( hex );

			this.r = ( hex >> 16 & 255 ) / 255;
			this.g = ( hex >> 8 & 255 ) / 255;
			this.b = ( hex & 255 ) / 255;

			return this;

		},

		setRGB: function ( r, g, b ) {

			this.r = r;
			this.g = g;
			this.b = b;

			return this;

		},

		setHSL: function () {

			function hue2rgb( p, q, t ) {

				if ( t < 0 ) t += 1;
				if ( t > 1 ) t -= 1;
				if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
				if ( t < 1 / 2 ) return q;
				if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
				return p;

			}

			return function setHSL( h, s, l ) {

				// h,s,l ranges are in 0.0 - 1.0
				h = _Math.euclideanModulo( h, 1 );
				s = _Math.clamp( s, 0, 1 );
				l = _Math.clamp( l, 0, 1 );

				if ( s === 0 ) {

					this.r = this.g = this.b = l;

				} else {

					var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
					var q = ( 2 * l ) - p;

					this.r = hue2rgb( q, p, h + 1 / 3 );
					this.g = hue2rgb( q, p, h );
					this.b = hue2rgb( q, p, h - 1 / 3 );

				}

				return this;

			};

		}(),

		setStyle: function ( style ) {

			function handleAlpha( string ) {

				if ( string === undefined ) return;

				if ( parseFloat( string ) < 1 ) {

					console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

				}

			}


			var m;

			if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

				// rgb / hsl

				var color;
				var name = m[ 1 ];
				var components = m[ 2 ];

				switch ( name ) {

					case 'rgb':
					case 'rgba':

						if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

							// rgb(255,0,0) rgba(255,0,0,0.5)
							this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
							this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
							this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

							handleAlpha( color[ 5 ] );

							return this;

						}

						if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

							// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
							this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
							this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
							this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

							handleAlpha( color[ 5 ] );

							return this;

						}

						break;

					case 'hsl':
					case 'hsla':

						if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

							// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
							var h = parseFloat( color[ 1 ] ) / 360;
							var s = parseInt( color[ 2 ], 10 ) / 100;
							var l = parseInt( color[ 3 ], 10 ) / 100;

							handleAlpha( color[ 5 ] );

							return this.setHSL( h, s, l );

						}

						break;

				}

			} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

				// hex color

				var hex = m[ 1 ];
				var size = hex.length;

				if ( size === 3 ) {

					// #ff0
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

					return this;

				} else if ( size === 6 ) {

					// #ff0000
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

					return this;

				}

			}

			if ( style && style.length > 0 ) {

				// color keywords
				var hex = ColorKeywords[ style ];

				if ( hex !== undefined ) {

					// red
					this.setHex( hex );

				} else {

					// unknown color
					console.warn( 'THREE.Color: Unknown color ' + style );

				}

			}

			return this;

		},

		clone: function () {

			return new this.constructor( this.r, this.g, this.b );

		},

		copy: function ( color ) {

			this.r = color.r;
			this.g = color.g;
			this.b = color.b;

			return this;

		},

		copyGammaToLinear: function ( color, gammaFactor ) {

			if ( gammaFactor === undefined ) gammaFactor = 2.0;

			this.r = Math.pow( color.r, gammaFactor );
			this.g = Math.pow( color.g, gammaFactor );
			this.b = Math.pow( color.b, gammaFactor );

			return this;

		},

		copyLinearToGamma: function ( color, gammaFactor ) {

			if ( gammaFactor === undefined ) gammaFactor = 2.0;

			var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

			this.r = Math.pow( color.r, safeInverse );
			this.g = Math.pow( color.g, safeInverse );
			this.b = Math.pow( color.b, safeInverse );

			return this;

		},

		convertGammaToLinear: function ( gammaFactor ) {

			this.copyGammaToLinear( this, gammaFactor );

			return this;

		},

		convertLinearToGamma: function ( gammaFactor ) {

			this.copyLinearToGamma( this, gammaFactor );

			return this;

		},

		copySRGBToLinear: function () {

			function SRGBToLinear( c ) {

				return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

			}

			return function copySRGBToLinear( color ) {

				this.r = SRGBToLinear( color.r );
				this.g = SRGBToLinear( color.g );
				this.b = SRGBToLinear( color.b );

				return this;

			};

		}(),

		copyLinearToSRGB: function () {

			function LinearToSRGB( c ) {

				return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

			}

			return function copyLinearToSRGB( color ) {

				this.r = LinearToSRGB( color.r );
				this.g = LinearToSRGB( color.g );
				this.b = LinearToSRGB( color.b );

				return this;

			};

		}(),

		convertSRGBToLinear: function () {

			this.copySRGBToLinear( this );

			return this;

		},

		convertLinearToSRGB: function () {

			this.copyLinearToSRGB( this );

			return this;

		},

		getHex: function () {

			return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

		},

		getHexString: function () {

			return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

		},

		getHSL: function ( target ) {

			// h,s,l ranges are in 0.0 - 1.0

			if ( target === undefined ) {

				console.warn( 'THREE.Color: .getHSL() target is now required' );
				target = { h: 0, s: 0, l: 0 };

			}

			var r = this.r, g = this.g, b = this.b;

			var max = Math.max( r, g, b );
			var min = Math.min( r, g, b );

			var hue, saturation;
			var lightness = ( min + max ) / 2.0;

			if ( min === max ) {

				hue = 0;
				saturation = 0;

			} else {

				var delta = max - min;

				saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

				switch ( max ) {

					case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
					case g: hue = ( b - r ) / delta + 2; break;
					case b: hue = ( r - g ) / delta + 4; break;

				}

				hue /= 6;

			}

			target.h = hue;
			target.s = saturation;
			target.l = lightness;

			return target;

		},

		getStyle: function () {

			return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

		},

		offsetHSL: function () {

			var hsl = {};

			return function ( h, s, l ) {

				this.getHSL( hsl );

				hsl.h += h; hsl.s += s; hsl.l += l;

				this.setHSL( hsl.h, hsl.s, hsl.l );

				return this;

			};

		}(),

		add: function ( color ) {

			this.r += color.r;
			this.g += color.g;
			this.b += color.b;

			return this;

		},

		addColors: function ( color1, color2 ) {

			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;

			return this;

		},

		addScalar: function ( s ) {

			this.r += s;
			this.g += s;
			this.b += s;

			return this;

		},

		sub: function ( color ) {

			this.r = Math.max( 0, this.r - color.r );
			this.g = Math.max( 0, this.g - color.g );
			this.b = Math.max( 0, this.b - color.b );

			return this;

		},

		multiply: function ( color ) {

			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;

			return this;

		},

		multiplyScalar: function ( s ) {

			this.r *= s;
			this.g *= s;
			this.b *= s;

			return this;

		},

		lerp: function ( color, alpha ) {

			this.r += ( color.r - this.r ) * alpha;
			this.g += ( color.g - this.g ) * alpha;
			this.b += ( color.b - this.b ) * alpha;

			return this;

		},

		lerpHSL: function () {

			var hslA = { h: 0, s: 0, l: 0 };
			var hslB = { h: 0, s: 0, l: 0 };

			return function lerpHSL( color, alpha ) {

				this.getHSL( hslA );
				color.getHSL( hslB );

				var h = _Math.lerp( hslA.h, hslB.h, alpha );
				var s = _Math.lerp( hslA.s, hslB.s, alpha );
				var l = _Math.lerp( hslA.l, hslB.l, alpha );

				this.setHSL( h, s, l );

				return this;

			};

		}(),

		equals: function ( c ) {

			return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.r = array[ offset ];
			this.g = array[ offset + 1 ];
			this.b = array[ offset + 2 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.r;
			array[ offset + 1 ] = this.g;
			array[ offset + 2 ] = this.b;

			return array;

		},

		toJSON: function () {

			return this.getHex();

		}

	} );

	/**
	 * Uniforms library for shared webgl shaders
	 */

	var UniformsLib = {

		common: {

			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },

			map: { value: null },
			uvTransform: { value: new Matrix3() },

			alphaMap: { value: null },

		},

		specularmap: {

			specularMap: { value: null },

		},

		envmap: {

			envMap: { value: null },
			flipEnvMap: { value: - 1 },
			reflectivity: { value: 1.0 },
			refractionRatio: { value: 0.98 },
			maxMipLevel: { value: 0 }

		},

		aomap: {

			aoMap: { value: null },
			aoMapIntensity: { value: 1 }

		},

		lightmap: {

			lightMap: { value: null },
			lightMapIntensity: { value: 1 }

		},

		emissivemap: {

			emissiveMap: { value: null }

		},

		bumpmap: {

			bumpMap: { value: null },
			bumpScale: { value: 1 }

		},

		normalmap: {

			normalMap: { value: null },
			normalScale: { value: new Vector2( 1, 1 ) }

		},

		displacementmap: {

			displacementMap: { value: null },
			displacementScale: { value: 1 },
			displacementBias: { value: 0 }

		},

		roughnessmap: {

			roughnessMap: { value: null }

		},

		metalnessmap: {

			metalnessMap: { value: null }

		},

		gradientmap: {

			gradientMap: { value: null }

		},

		fog: {

			fogDensity: { value: 0.00025 },
			fogNear: { value: 1 },
			fogFar: { value: 2000 },
			fogColor: { value: new Color( 0xffffff ) }

		},

		lights: {

			ambientLightColor: { value: [] },

			directionalLights: { value: [], properties: {
				direction: {},
				color: {},

				shadow: {},
				shadowBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },

			directionalShadowMap: { value: [] },
			directionalShadowMatrix: { value: [] },

			spotLights: { value: [], properties: {
				color: {},
				position: {},
				direction: {},
				distance: {},
				coneCos: {},
				penumbraCos: {},
				decay: {},

				shadow: {},
				shadowBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },

			spotShadowMap: { value: [] },
			spotShadowMatrix: { value: [] },

			pointLights: { value: [], properties: {
				color: {},
				position: {},
				decay: {},
				distance: {},

				shadow: {},
				shadowBias: {},
				shadowRadius: {},
				shadowMapSize: {},
				shadowCameraNear: {},
				shadowCameraFar: {}
			} },

			pointShadowMap: { value: [] },
			pointShadowMatrix: { value: [] },

			hemisphereLights: { value: [], properties: {
				direction: {},
				skyColor: {},
				groundColor: {}
			} },

			// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
			rectAreaLights: { value: [], properties: {
				color: {},
				position: {},
				width: {},
				height: {}
			} }

		},

		points: {

			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },
			size: { value: 1.0 },
			scale: { value: 1.0 },
			map: { value: null },
			uvTransform: { value: new Matrix3() }

		},

		sprite: {

			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },
			center: { value: new Vector2( 0.5, 0.5 ) },
			rotation: { value: 0.0 },
			map: { value: null },
			uvTransform: { value: new Matrix3() }

		}

	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 */

	var ShaderLib = {

		basic: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.meshbasic_vert,
			fragmentShader: ShaderChunk.meshbasic_frag

		},

		lambert: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) }
				}
			] ),

			vertexShader: ShaderChunk.meshlambert_vert,
			fragmentShader: ShaderChunk.meshlambert_frag

		},

		phong: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.gradientmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) },
					specular: { value: new Color( 0x111111 ) },
					shininess: { value: 30 }
				}
			] ),

			vertexShader: ShaderChunk.meshphong_vert,
			fragmentShader: ShaderChunk.meshphong_frag

		},

		standard: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.roughnessmap,
				UniformsLib.metalnessmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) },
					roughness: { value: 0.5 },
					metalness: { value: 0.5 },
					envMapIntensity: { value: 1 } // temporary
				}
			] ),

			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag

		},

		matcap: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.fog,
				{
					matcap: { value: null }
				}
			] ),

			vertexShader: ShaderChunk.meshmatcap_vert,
			fragmentShader: ShaderChunk.meshmatcap_frag

		},

		points: {

			uniforms: mergeUniforms( [
				UniformsLib.points,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.points_vert,
			fragmentShader: ShaderChunk.points_frag

		},

		dashed: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.fog,
				{
					scale: { value: 1 },
					dashSize: { value: 1 },
					totalSize: { value: 2 }
				}
			] ),

			vertexShader: ShaderChunk.linedashed_vert,
			fragmentShader: ShaderChunk.linedashed_frag

		},

		depth: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.displacementmap
			] ),

			vertexShader: ShaderChunk.depth_vert,
			fragmentShader: ShaderChunk.depth_frag

		},

		normal: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				{
					opacity: { value: 1.0 }
				}
			] ),

			vertexShader: ShaderChunk.normal_vert,
			fragmentShader: ShaderChunk.normal_frag

		},

		sprite: {

			uniforms: mergeUniforms( [
				UniformsLib.sprite,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.sprite_vert,
			fragmentShader: ShaderChunk.sprite_frag

		},

		background: {

			uniforms: {
				uvTransform: { value: new Matrix3() },
				t2D: { value: null },
			},

			vertexShader: ShaderChunk.background_vert,
			fragmentShader: ShaderChunk.background_frag

		},
		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */

		cube: {

			uniforms: {
				tCube: { value: null },
				tFlip: { value: - 1 },
				opacity: { value: 1.0 }
			},

			vertexShader: ShaderChunk.cube_vert,
			fragmentShader: ShaderChunk.cube_frag

		},

		equirect: {

			uniforms: {
				tEquirect: { value: null },
			},

			vertexShader: ShaderChunk.equirect_vert,
			fragmentShader: ShaderChunk.equirect_frag

		},

		distanceRGBA: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.displacementmap,
				{
					referencePosition: { value: new Vector3() },
					nearDistance: { value: 1 },
					farDistance: { value: 1000 }
				}
			] ),

			vertexShader: ShaderChunk.distanceRGBA_vert,
			fragmentShader: ShaderChunk.distanceRGBA_frag

		},

		shadow: {

			uniforms: mergeUniforms( [
				UniformsLib.lights,
				UniformsLib.fog,
				{
					color: { value: new Color( 0x00000 ) },
					opacity: { value: 1.0 }
				},
			] ),

			vertexShader: ShaderChunk.shadow_vert,
			fragmentShader: ShaderChunk.shadow_frag

		}

	};

	ShaderLib.physical = {

		uniforms: mergeUniforms( [
			ShaderLib.standard.uniforms,
			{
				clearCoat: { value: 0 },
				clearCoatRoughness: { value: 0 }
			}
		] ),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLAnimation() {

		var context = null;
		var isAnimating = false;
		var animationLoop = null;

		function onAnimationFrame( time, frame ) {

			if ( isAnimating === false ) return;

			animationLoop( time, frame );

			context.requestAnimationFrame( onAnimationFrame );

		}

		return {

			start: function () {

				if ( isAnimating === true ) return;
				if ( animationLoop === null ) return;

				context.requestAnimationFrame( onAnimationFrame );

				isAnimating = true;

			},

			stop: function () {

				isAnimating = false;

			},

			setAnimationLoop: function ( callback ) {

				animationLoop = callback;

			},

			setContext: function ( value ) {

				context = value;

			}

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLAttributes( gl ) {

		var buffers = new WeakMap();

		function createBuffer( attribute, bufferType ) {

			var array = attribute.array;
			var usage = attribute.dynamic ? 35048 : 35044;

			var buffer = gl.createBuffer();

			gl.bindBuffer( bufferType, buffer );
			gl.bufferData( bufferType, array, usage );

			attribute.onUploadCallback();

			var type = 5126;

			if ( array instanceof Float32Array ) {

				type = 5126;

			} else if ( array instanceof Float64Array ) {

				console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );

			} else if ( array instanceof Uint16Array ) {

				type = 5123;

			} else if ( array instanceof Int16Array ) {

				type = 5122;

			} else if ( array instanceof Uint32Array ) {

				type = 5125;

			} else if ( array instanceof Int32Array ) {

				type = 5124;

			} else if ( array instanceof Int8Array ) {

				type = 5120;

			} else if ( array instanceof Uint8Array ) {

				type = 5121;

			}

			return {
				buffer: buffer,
				type: type,
				bytesPerElement: array.BYTES_PER_ELEMENT,
				version: attribute.version
			};

		}

		function updateBuffer( buffer, attribute, bufferType ) {

			var array = attribute.array;
			var updateRange = attribute.updateRange;

			gl.bindBuffer( bufferType, buffer );

			if ( attribute.dynamic === false ) {

				gl.bufferData( bufferType, array, 35044 );

			} else if ( updateRange.count === - 1 ) {

				// Not using update ranges

				gl.bufferSubData( bufferType, 0, array );

			} else if ( updateRange.count === 0 ) {

				console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

			} else {

				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

				updateRange.count = - 1; // reset range

			}

		}

		//

		function get( attribute ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			return buffers.get( attribute );

		}

		function remove( attribute ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			var data = buffers.get( attribute );

			if ( data ) {

				gl.deleteBuffer( data.buffer );

				buffers.delete( attribute );

			}

		}

		function update( attribute, bufferType ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			var data = buffers.get( attribute );

			if ( data === undefined ) {

				buffers.set( attribute, createBuffer( attribute, bufferType ) );

			} else if ( data.version < attribute.version ) {

				updateBuffer( data.buffer, attribute, bufferType );

				data.version = attribute.version;

			}

		}

		return {

			get: get,
			remove: remove,
			update: update

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Face3( a, b, c, normal, color, materialIndex ) {

		this.a = a;
		this.b = b;
		this.c = c;

		this.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();
		this.vertexNormals = Array.isArray( normal ) ? normal : [];

		this.color = ( color && color.isColor ) ? color : new Color();
		this.vertexColors = Array.isArray( color ) ? color : [];

		this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

	}

	Object.assign( Face3.prototype, {

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.a = source.a;
			this.b = source.b;
			this.c = source.c;

			this.normal.copy( source.normal );
			this.color.copy( source.color );

			this.materialIndex = source.materialIndex;

			for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

				this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

			}

			for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

				this.vertexColors[ i ] = source.vertexColors[ i ].clone();

			}

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */

	function Euler( x, y, z, order ) {

		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._order = order || Euler.DefaultOrder;

	}

	Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

	Euler.DefaultOrder = 'XYZ';

	Object.defineProperties( Euler.prototype, {

		x: {

			get: function () {

				return this._x;

			},

			set: function ( value ) {

				this._x = value;
				this.onChangeCallback();

			}

		},

		y: {

			get: function () {

				return this._y;

			},

			set: function ( value ) {

				this._y = value;
				this.onChangeCallback();

			}

		},

		z: {

			get: function () {

				return this._z;

			},

			set: function ( value ) {

				this._z = value;
				this.onChangeCallback();

			}

		},

		order: {

			get: function () {

				return this._order;

			},

			set: function ( value ) {

				this._order = value;
				this.onChangeCallback();

			}

		}

	} );

	Object.assign( Euler.prototype, {

		isEuler: true,

		set: function ( x, y, z, order ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order || this._order;

			this.onChangeCallback();

			return this;

		},

		clone: function () {

			return new this.constructor( this._x, this._y, this._z, this._order );

		},

		copy: function ( euler ) {

			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;

			this.onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function ( m, order, update ) {

			var clamp = _Math.clamp;

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements;
			var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
			var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
			var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			order = order || this._order;

			if ( order === 'XYZ' ) {

				this._y = Math.asin( clamp( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.99999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

			} else if ( order === 'YXZ' ) {

				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.99999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

			} else if ( order === 'ZXY' ) {

				this._x = Math.asin( clamp( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.99999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

			} else if ( order === 'ZYX' ) {

				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.99999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

			} else if ( order === 'YZX' ) {

				this._z = Math.asin( clamp( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.99999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

			} else if ( order === 'XZY' ) {

				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.99999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

			} else {

				console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );

			}

			this._order = order;

			if ( update !== false ) this.onChangeCallback();

			return this;

		},

		setFromQuaternion: function () {

			var matrix = new Matrix4();

			return function setFromQuaternion( q, order, update ) {

				matrix.makeRotationFromQuaternion( q );

				return this.setFromRotationMatrix( matrix, order, update );

			};

		}(),

		setFromVector3: function ( v, order ) {

			return this.set( v.x, v.y, v.z, order || this._order );

		},

		reorder: function () {

			// WARNING: this discards revolution information -bhouston

			var q = new Quaternion();

			return function reorder( newOrder ) {

				q.setFromEuler( this );

				return this.setFromQuaternion( q, newOrder );

			};

		}(),

		equals: function ( euler ) {

			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

		},

		fromArray: function ( array ) {

			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

			this.onChangeCallback();

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._order;

			return array;

		},

		toVector3: function ( optionalResult ) {

			if ( optionalResult ) {

				return optionalResult.set( this._x, this._y, this._z );

			} else {

				return new Vector3( this._x, this._y, this._z );

			}

		},

		onChange: function ( callback ) {

			this.onChangeCallback = callback;

			return this;

		},

		onChangeCallback: function () {}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Layers() {

		this.mask = 1 | 0;

	}

	Object.assign( Layers.prototype, {

		set: function ( channel ) {

			this.mask = 1 << channel | 0;

		},

		enable: function ( channel ) {

			this.mask |= 1 << channel | 0;

		},

		toggle: function ( channel ) {

			this.mask ^= 1 << channel | 0;

		},

		disable: function ( channel ) {

			this.mask &= ~ ( 1 << channel | 0 );

		},

		test: function ( layers ) {

			return ( this.mask & layers.mask ) !== 0;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author elephantatwork / www.elephantatwork.ch
	 */

	var object3DId = 0;

	function Object3D() {

		Object.defineProperty( this, 'id', { value: object3DId ++ } );

		this.uuid = _Math.generateUUID();

		this.name = '';
		this.type = 'Object3D';

		this.parent = null;
		this.children = [];

		this.up = Object3D.DefaultUp.clone();

		var position = new Vector3();
		var rotation = new Euler();
		var quaternion = new Quaternion();
		var scale = new Vector3( 1, 1, 1 );

		function onRotationChange() {

			quaternion.setFromEuler( rotation, false );

		}

		function onQuaternionChange() {

			rotation.setFromQuaternion( quaternion, undefined, false );

		}

		rotation.onChange( onRotationChange );
		quaternion.onChange( onQuaternionChange );

		Object.defineProperties( this, {
			position: {
				configurable: true,
				enumerable: true,
				value: position
			},
			rotation: {
				configurable: true,
				enumerable: true,
				value: rotation
			},
			quaternion: {
				configurable: true,
				enumerable: true,
				value: quaternion
			},
			scale: {
				configurable: true,
				enumerable: true,
				value: scale
			},
			modelViewMatrix: {
				value: new Matrix4()
			},
			normalMatrix: {
				value: new Matrix3()
			}
		} );

		this.matrix = new Matrix4();
		this.matrixWorld = new Matrix4();

		this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
		this.matrixWorldNeedsUpdate = false;

		this.layers = new Layers();
		this.visible = true;

		this.castShadow = false;
		this.receiveShadow = false;

		this.frustumCulled = true;
		this.renderOrder = 0;

		this.userData = {};

	}

	Object3D.DefaultUp = new Vector3( 0, 1, 0 );
	Object3D.DefaultMatrixAutoUpdate = true;

	Object3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Object3D,

		isObject3D: true,

		onBeforeRender: function () {},
		onAfterRender: function () {},

		applyMatrix: function ( matrix ) {

			this.matrix.multiplyMatrices( matrix, this.matrix );

			this.matrix.decompose( this.position, this.quaternion, this.scale );

		},

		applyQuaternion: function ( q ) {

			this.quaternion.premultiply( q );

			return this;

		},

		setRotationFromAxisAngle: function ( axis, angle ) {

			// assumes axis is normalized

			this.quaternion.setFromAxisAngle( axis, angle );

		},

		setRotationFromEuler: function ( euler ) {

			this.quaternion.setFromEuler( euler, true );

		},

		setRotationFromMatrix: function ( m ) {

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			this.quaternion.setFromRotationMatrix( m );

		},

		setRotationFromQuaternion: function ( q ) {

			// assumes q is normalized

			this.quaternion.copy( q );

		},

		rotateOnAxis: function () {

			// rotate object on axis in object space
			// axis is assumed to be normalized

			var q1 = new Quaternion();

			return function rotateOnAxis( axis, angle ) {

				q1.setFromAxisAngle( axis, angle );

				this.quaternion.multiply( q1 );

				return this;

			};

		}(),

		rotateOnWorldAxis: function () {

			// rotate object on axis in world space
			// axis is assumed to be normalized
			// method assumes no rotated parent

			var q1 = new Quaternion();

			return function rotateOnWorldAxis( axis, angle ) {

				q1.setFromAxisAngle( axis, angle );

				this.quaternion.premultiply( q1 );

				return this;

			};

		}(),

		rotateX: function () {

			var v1 = new Vector3( 1, 0, 0 );

			return function rotateX( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		rotateY: function () {

			var v1 = new Vector3( 0, 1, 0 );

			return function rotateY( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		rotateZ: function () {

			var v1 = new Vector3( 0, 0, 1 );

			return function rotateZ( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		translateOnAxis: function () {

			// translate object by distance along axis in object space
			// axis is assumed to be normalized

			var v1 = new Vector3();

			return function translateOnAxis( axis, distance ) {

				v1.copy( axis ).applyQuaternion( this.quaternion );

				this.position.add( v1.multiplyScalar( distance ) );

				return this;

			};

		}(),

		translateX: function () {

			var v1 = new Vector3( 1, 0, 0 );

			return function translateX( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		translateY: function () {

			var v1 = new Vector3( 0, 1, 0 );

			return function translateY( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		translateZ: function () {

			var v1 = new Vector3( 0, 0, 1 );

			return function translateZ( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		localToWorld: function ( vector ) {

			return vector.applyMatrix4( this.matrixWorld );

		},

		worldToLocal: function () {

			var m1 = new Matrix4();

			return function worldToLocal( vector ) {

				return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

			};

		}(),

		lookAt: function () {

			// This method does not support objects having non-uniformly-scaled parent(s)

			var q1 = new Quaternion();
			var m1 = new Matrix4();
			var target = new Vector3();
			var position = new Vector3();

			return function lookAt( x, y, z ) {

				if ( x.isVector3 ) {

					target.copy( x );

				} else {

					target.set( x, y, z );

				}

				var parent = this.parent;

				this.updateWorldMatrix( true, false );

				position.setFromMatrixPosition( this.matrixWorld );

				if ( this.isCamera || this.isLight ) {

					m1.lookAt( position, target, this.up );

				} else {

					m1.lookAt( target, position, this.up );

				}

				this.quaternion.setFromRotationMatrix( m1 );

				if ( parent ) {

					m1.extractRotation( parent.matrixWorld );
					q1.setFromRotationMatrix( m1 );
					this.quaternion.premultiply( q1.inverse() );

				}

			};

		}(),

		add: function ( object ) {

			if ( arguments.length > 1 ) {

				for ( var i = 0; i < arguments.length; i ++ ) {

					this.add( arguments[ i ] );

				}

				return this;

			}

			if ( object === this ) {

				console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
				return this;

			}

			if ( ( object && object.isObject3D ) ) {

				if ( object.parent !== null ) {

					object.parent.remove( object );

				}

				object.parent = this;
				object.dispatchEvent( { type: 'added' } );

				this.children.push( object );

			} else {

				console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

			}

			return this;

		},

		remove: function ( object ) {

			if ( arguments.length > 1 ) {

				for ( var i = 0; i < arguments.length; i ++ ) {

					this.remove( arguments[ i ] );

				}

				return this;

			}

			var index = this.children.indexOf( object );

			if ( index !== - 1 ) {

				object.parent = null;

				object.dispatchEvent( { type: 'removed' } );

				this.children.splice( index, 1 );

			}

			return this;

		},

		getObjectById: function ( id ) {

			return this.getObjectByProperty( 'id', id );

		},

		getObjectByName: function ( name ) {

			return this.getObjectByProperty( 'name', name );

		},

		getObjectByProperty: function ( name, value ) {

			if ( this[ name ] === value ) return this;

			for ( var i = 0, l = this.children.length; i < l; i ++ ) {

				var child = this.children[ i ];
				var object = child.getObjectByProperty( name, value );

				if ( object !== undefined ) {

					return object;

				}

			}

			return undefined;

		},

		getWorldPosition: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Object3D: .getWorldPosition() target is now required' );
				target = new Vector3();

			}

			this.updateMatrixWorld( true );

			return target.setFromMatrixPosition( this.matrixWorld );

		},

		getWorldQuaternion: function () {

			var position = new Vector3();
			var scale = new Vector3();

			return function getWorldQuaternion( target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Object3D: .getWorldQuaternion() target is now required' );
					target = new Quaternion();

				}

				this.updateMatrixWorld( true );

				this.matrixWorld.decompose( position, target, scale );

				return target;

			};

		}(),

		getWorldScale: function () {

			var position = new Vector3();
			var quaternion = new Quaternion();

			return function getWorldScale( target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Object3D: .getWorldScale() target is now required' );
					target = new Vector3();

				}

				this.updateMatrixWorld( true );

				this.matrixWorld.decompose( position, quaternion, target );

				return target;

			};

		}(),

		getWorldDirection: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Object3D: .getWorldDirection() target is now required' );
				target = new Vector3();

			}

			this.updateMatrixWorld( true );

			var e = this.matrixWorld.elements;

			return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

		},

		raycast: function () {},

		traverse: function ( callback ) {

			callback( this );

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverse( callback );

			}

		},

		traverseVisible: function ( callback ) {

			if ( this.visible === false ) return;

			callback( this );

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverseVisible( callback );

			}

		},

		traverseAncestors: function ( callback ) {

			var parent = this.parent;

			if ( parent !== null ) {

				callback( parent );

				parent.traverseAncestors( callback );

			}

		},

		updateMatrix: function () {

			this.matrix.compose( this.position, this.quaternion, this.scale );

			this.matrixWorldNeedsUpdate = true;

		},

		updateMatrixWorld: function ( force ) {

			if ( this.matrixAutoUpdate ) this.updateMatrix();

			if ( this.matrixWorldNeedsUpdate || force ) {

				if ( this.parent === null ) {

					this.matrixWorld.copy( this.matrix );

				} else {

					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

				}

				this.matrixWorldNeedsUpdate = false;

				force = true;

			}

			// update children

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateMatrixWorld( force );

			}

		},

		updateWorldMatrix: function ( updateParents, updateChildren ) {

			var parent = this.parent;

			if ( updateParents === true && parent !== null ) {

				parent.updateWorldMatrix( true, false );

			}

			if ( this.matrixAutoUpdate ) this.updateMatrix();

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			// update children

			if ( updateChildren === true ) {

				var children = this.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					children[ i ].updateWorldMatrix( false, true );

				}

			}

		},

		toJSON: function ( meta ) {

			// meta is a string when called from JSON.stringify
			var isRootObject = ( meta === undefined || typeof meta === 'string' );

			var output = {};

			// meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.
			if ( isRootObject ) {

				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {},
					shapes: {}
				};

				output.metadata = {
					version: 4.5,
					type: 'Object',
					generator: 'Object3D.toJSON'
				};

			}

			// standard Object3D serialization

			var object = {};

			object.uuid = this.uuid;
			object.type = this.type;

			if ( this.name !== '' ) object.name = this.name;
			if ( this.castShadow === true ) object.castShadow = true;
			if ( this.receiveShadow === true ) object.receiveShadow = true;
			if ( this.visible === false ) object.visible = false;
			if ( this.frustumCulled === false ) object.frustumCulled = false;
			if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
			if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;

			object.layers = this.layers.mask;
			object.matrix = this.matrix.toArray();

			if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

			// object specific properties

			if ( this.isMesh && this.drawMode !== TrianglesDrawMode ) object.drawMode = this.drawMode;

			//

			function serialize( library, element ) {

				if ( library[ element.uuid ] === undefined ) {

					library[ element.uuid ] = element.toJSON( meta );

				}

				return element.uuid;

			}

			if ( this.isMesh || this.isLine || this.isPoints ) {

				object.geometry = serialize( meta.geometries, this.geometry );

				var parameters = this.geometry.parameters;

				if ( parameters !== undefined && parameters.shapes !== undefined ) {

					var shapes = parameters.shapes;

					if ( Array.isArray( shapes ) ) {

						for ( var i = 0, l = shapes.length; i < l; i ++ ) {

							var shape = shapes[ i ];

							serialize( meta.shapes, shape );

						}

					} else {

						serialize( meta.shapes, shapes );

					}

				}

			}

			if ( this.material !== undefined ) {

				if ( Array.isArray( this.material ) ) {

					var uuids = [];

					for ( var i = 0, l = this.material.length; i < l; i ++ ) {

						uuids.push( serialize( meta.materials, this.material[ i ] ) );

					}

					object.material = uuids;

				} else {

					object.material = serialize( meta.materials, this.material );

				}

			}

			//

			if ( this.children.length > 0 ) {

				object.children = [];

				for ( var i = 0; i < this.children.length; i ++ ) {

					object.children.push( this.children[ i ].toJSON( meta ).object );

				}

			}

			if ( isRootObject ) {

				var geometries = extractFromCache( meta.geometries );
				var materials = extractFromCache( meta.materials );
				var textures = extractFromCache( meta.textures );
				var images = extractFromCache( meta.images );
				var shapes = extractFromCache( meta.shapes );

				if ( geometries.length > 0 ) output.geometries = geometries;
				if ( materials.length > 0 ) output.materials = materials;
				if ( textures.length > 0 ) output.textures = textures;
				if ( images.length > 0 ) output.images = images;
				if ( shapes.length > 0 ) output.shapes = shapes;

			}

			output.object = object;

			return output;

			// extract data from the cache hash
			// remove metadata on each item
			// and return as array
			function extractFromCache( cache ) {

				var values = [];
				for ( var key in cache ) {

					var data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}
				return values;

			}

		},

		clone: function ( recursive ) {

			return new this.constructor().copy( this, recursive );

		},

		copy: function ( source, recursive ) {

			if ( recursive === undefined ) recursive = true;

			this.name = source.name;

			this.up.copy( source.up );

			this.position.copy( source.position );
			this.quaternion.copy( source.quaternion );
			this.scale.copy( source.scale );

			this.matrix.copy( source.matrix );
			this.matrixWorld.copy( source.matrixWorld );

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

			this.layers.mask = source.layers.mask;
			this.visible = source.visible;

			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;

			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;

			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			if ( recursive === true ) {

				for ( var i = 0; i < source.children.length; i ++ ) {

					var child = source.children[ i ];
					this.add( child.clone() );

				}

			}

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author bhouston / http://clara.io
	 */

	var geometryId = 0; // Geometry uses even numbers as Id

	function Geometry() {

		Object.defineProperty( this, 'id', { value: geometryId += 2 } );

		this.uuid = _Math.generateUUID();

		this.name = '';
		this.type = 'Geometry';

		this.vertices = [];
		this.colors = [];
		this.faces = [];
		this.faceVertexUvs = [[]];

		this.morphTargets = [];
		this.morphNormals = [];

		this.skinWeights = [];
		this.skinIndices = [];

		this.lineDistances = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		// update flags

		this.elementsNeedUpdate = false;
		this.verticesNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.lineDistancesNeedUpdate = false;
		this.groupsNeedUpdate = false;

	}

	Geometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Geometry,

		isGeometry: true,

		applyMatrix: function ( matrix ) {

			var normalMatrix = new Matrix3().getNormalMatrix( matrix );

			for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

				var vertex = this.vertices[ i ];
				vertex.applyMatrix4( matrix );

			}

			for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

				var face = this.faces[ i ];
				face.normal.applyMatrix3( normalMatrix ).normalize();

				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

					face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

				}

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

			this.verticesNeedUpdate = true;
			this.normalsNeedUpdate = true;

			return this;

		},

		rotateX: function () {

			// rotate geometry around world x-axis

			var m1 = new Matrix4();

			return function rotateX( angle ) {

				m1.makeRotationX( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateY: function () {

			// rotate geometry around world y-axis

			var m1 = new Matrix4();

			return function rotateY( angle ) {

				m1.makeRotationY( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateZ: function () {

			// rotate geometry around world z-axis

			var m1 = new Matrix4();

			return function rotateZ( angle ) {

				m1.makeRotationZ( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		translate: function () {

			// translate geometry

			var m1 = new Matrix4();

			return function translate( x, y, z ) {

				m1.makeTranslation( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		scale: function () {

			// scale geometry

			var m1 = new Matrix4();

			return function scale( x, y, z ) {

				m1.makeScale( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		lookAt: function () {

			var obj = new Object3D();

			return function lookAt( vector ) {

				obj.lookAt( vector );

				obj.updateMatrix();

				this.applyMatrix( obj.matrix );

			};

		}(),

		fromBufferGeometry: function ( geometry ) {

			var scope = this;

			var indices = geometry.index !== null ? geometry.index.array : undefined;
			var attributes = geometry.attributes;

			var positions = attributes.position.array;
			var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
			var colors = attributes.color !== undefined ? attributes.color.array : undefined;
			var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
			var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

			if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

			for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {

				scope.vertices.push( new Vector3().fromArray( positions, i ) );

				if ( colors !== undefined ) {

					scope.colors.push( new Color().fromArray( colors, i ) );

				}

			}

			function addFace( a, b, c, materialIndex ) {

				var vertexColors = ( colors === undefined ) ? [] : [
					scope.colors[ a ].clone(),
					scope.colors[ b ].clone(),
					scope.colors[ c ].clone() ];

				var vertexNormals = ( normals === undefined ) ? [] : [
					new Vector3().fromArray( normals, a * 3 ),
					new Vector3().fromArray( normals, b * 3 ),
					new Vector3().fromArray( normals, c * 3 )
				];

				var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );

				scope.faces.push( face );

				if ( uvs !== undefined ) {

					scope.faceVertexUvs[ 0 ].push( [
						new Vector2().fromArray( uvs, a * 2 ),
						new Vector2().fromArray( uvs, b * 2 ),
						new Vector2().fromArray( uvs, c * 2 )
					] );

				}

				if ( uvs2 !== undefined ) {

					scope.faceVertexUvs[ 1 ].push( [
						new Vector2().fromArray( uvs2, a * 2 ),
						new Vector2().fromArray( uvs2, b * 2 ),
						new Vector2().fromArray( uvs2, c * 2 )
					] );

				}

			}

			var groups = geometry.groups;

			if ( groups.length > 0 ) {

				for ( var i = 0; i < groups.length; i ++ ) {

					var group = groups[ i ];

					var start = group.start;
					var count = group.count;

					for ( var j = start, jl = start + count; j < jl; j += 3 ) {

						if ( indices !== undefined ) {

							addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );

						} else {

							addFace( j, j + 1, j + 2, group.materialIndex );

						}

					}

				}

			} else {

				if ( indices !== undefined ) {

					for ( var i = 0; i < indices.length; i += 3 ) {

						addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

					}

				} else {

					for ( var i = 0; i < positions.length / 3; i += 3 ) {

						addFace( i, i + 1, i + 2 );

					}

				}

			}

			this.computeFaceNormals();

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			return this;

		},

		center: function () {

			var offset = new Vector3();

			return function center() {

				this.computeBoundingBox();

				this.boundingBox.getCenter( offset ).negate();

				this.translate( offset.x, offset.y, offset.z );

				return this;

			};

		}(),

		normalize: function () {

			this.computeBoundingSphere();

			var center = this.boundingSphere.center;
			var radius = this.boundingSphere.radius;

			var s = radius === 0 ? 1 : 1.0 / radius;

			var matrix = new Matrix4();
			matrix.set(
				s, 0, 0, - s * center.x,
				0, s, 0, - s * center.y,
				0, 0, s, - s * center.z,
				0, 0, 0, 1
			);

			this.applyMatrix( matrix );

			return this;

		},

		computeFaceNormals: function () {

			var cb = new Vector3(), ab = new Vector3();

			for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

				var face = this.faces[ f ];

				var vA = this.vertices[ face.a ];
				var vB = this.vertices[ face.b ];
				var vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				cb.normalize();

				face.normal.copy( cb );

			}

		},

		computeVertexNormals: function ( areaWeighted ) {

			if ( areaWeighted === undefined ) areaWeighted = true;

			var v, vl, f, fl, face, vertices;

			vertices = new Array( this.vertices.length );

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				vertices[ v ] = new Vector3();

			}

			if ( areaWeighted ) {

				// vertex normals weighted by triangle areas
				// http://www.iquilezles.org/www/articles/normals/normals.htm

				var vA, vB, vC;
				var cb = new Vector3(), ab = new Vector3();

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					vA = this.vertices[ face.a ];
					vB = this.vertices[ face.b ];
					vC = this.vertices[ face.c ];

					cb.subVectors( vC, vB );
					ab.subVectors( vA, vB );
					cb.cross( ab );

					vertices[ face.a ].add( cb );
					vertices[ face.b ].add( cb );
					vertices[ face.c ].add( cb );

				}

			} else {

				this.computeFaceNormals();

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					vertices[ face.a ].add( face.normal );
					vertices[ face.b ].add( face.normal );
					vertices[ face.c ].add( face.normal );

				}

			}

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				vertices[ v ].normalize();

			}

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				var vertexNormals = face.vertexNormals;

				if ( vertexNormals.length === 3 ) {

					vertexNormals[ 0 ].copy( vertices[ face.a ] );
					vertexNormals[ 1 ].copy( vertices[ face.b ] );
					vertexNormals[ 2 ].copy( vertices[ face.c ] );

				} else {

					vertexNormals[ 0 ] = vertices[ face.a ].clone();
					vertexNormals[ 1 ] = vertices[ face.b ].clone();
					vertexNormals[ 2 ] = vertices[ face.c ].clone();

				}

			}

			if ( this.faces.length > 0 ) {

				this.normalsNeedUpdate = true;

			}

		},

		computeFlatVertexNormals: function () {

			var f, fl, face;

			this.computeFaceNormals();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				var vertexNormals = face.vertexNormals;

				if ( vertexNormals.length === 3 ) {

					vertexNormals[ 0 ].copy( face.normal );
					vertexNormals[ 1 ].copy( face.normal );
					vertexNormals[ 2 ].copy( face.normal );

				} else {

					vertexNormals[ 0 ] = face.normal.clone();
					vertexNormals[ 1 ] = face.normal.clone();
					vertexNormals[ 2 ] = face.normal.clone();

				}

			}

			if ( this.faces.length > 0 ) {

				this.normalsNeedUpdate = true;

			}

		},

		computeMorphNormals: function () {

			var i, il, f, fl, face;

			// save original normals
			// - create temp variables on first access
			//   otherwise just copy (for faster repeated calls)

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				if ( ! face.__originalFaceNormal ) {

					face.__originalFaceNormal = face.normal.clone();

				} else {

					face.__originalFaceNormal.copy( face.normal );

				}

				if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

				for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

					if ( ! face.__originalVertexNormals[ i ] ) {

						face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

					} else {

						face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

					}

				}

			}

			// use temp geometry to compute face and vertex normals for each morph

			var tmpGeo = new Geometry();
			tmpGeo.faces = this.faces;

			for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

				// create on first access

				if ( ! this.morphNormals[ i ] ) {

					this.morphNormals[ i ] = {};
					this.morphNormals[ i ].faceNormals = [];
					this.morphNormals[ i ].vertexNormals = [];

					var dstNormalsFace = this.morphNormals[ i ].faceNormals;
					var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

					var faceNormal, vertexNormals;

					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

						faceNormal = new Vector3();
						vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };

						dstNormalsFace.push( faceNormal );
						dstNormalsVertex.push( vertexNormals );

					}

				}

				var morphNormals = this.morphNormals[ i ];

				// set vertices to morph target

				tmpGeo.vertices = this.morphTargets[ i ].vertices;

				// compute morph normals

				tmpGeo.computeFaceNormals();
				tmpGeo.computeVertexNormals();

				// store morph normals

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					faceNormal = morphNormals.faceNormals[ f ];
					vertexNormals = morphNormals.vertexNormals[ f ];

					faceNormal.copy( face.normal );

					vertexNormals.a.copy( face.vertexNormals[ 0 ] );
					vertexNormals.b.copy( face.vertexNormals[ 1 ] );
					vertexNormals.c.copy( face.vertexNormals[ 2 ] );

				}

			}

			// restore original normals

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				face.normal = face.__originalFaceNormal;
				face.vertexNormals = face.__originalVertexNormals;

			}

		},

		computeBoundingBox: function () {

			if ( this.boundingBox === null ) {

				this.boundingBox = new Box3();

			}

			this.boundingBox.setFromPoints( this.vertices );

		},

		computeBoundingSphere: function () {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new Sphere();

			}

			this.boundingSphere.setFromPoints( this.vertices );

		},

		merge: function ( geometry, matrix, materialIndexOffset ) {

			if ( ! ( geometry && geometry.isGeometry ) ) {

				console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
				return;

			}

			var normalMatrix,
				vertexOffset = this.vertices.length,
				vertices1 = this.vertices,
				vertices2 = geometry.vertices,
				faces1 = this.faces,
				faces2 = geometry.faces,
				uvs1 = this.faceVertexUvs[ 0 ],
				uvs2 = geometry.faceVertexUvs[ 0 ],
				colors1 = this.colors,
				colors2 = geometry.colors;

			if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

			if ( matrix !== undefined ) {

				normalMatrix = new Matrix3().getNormalMatrix( matrix );

			}

			// vertices

			for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

				var vertex = vertices2[ i ];

				var vertexCopy = vertex.clone();

				if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

				vertices1.push( vertexCopy );

			}

			// colors

			for ( var i = 0, il = colors2.length; i < il; i ++ ) {

				colors1.push( colors2[ i ].clone() );

			}

			// faces

			for ( i = 0, il = faces2.length; i < il; i ++ ) {

				var face = faces2[ i ], faceCopy, normal, color,
					faceVertexNormals = face.vertexNormals,
					faceVertexColors = face.vertexColors;

				faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
				faceCopy.normal.copy( face.normal );

				if ( normalMatrix !== undefined ) {

					faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

				}

				for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

					normal = faceVertexNormals[ j ].clone();

					if ( normalMatrix !== undefined ) {

						normal.applyMatrix3( normalMatrix ).normalize();

					}

					faceCopy.vertexNormals.push( normal );

				}

				faceCopy.color.copy( face.color );

				for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

					color = faceVertexColors[ j ];
					faceCopy.vertexColors.push( color.clone() );

				}

				faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

				faces1.push( faceCopy );

			}

			// uvs

			for ( i = 0, il = uvs2.length; i < il; i ++ ) {

				var uv = uvs2[ i ], uvCopy = [];

				if ( uv === undefined ) {

					continue;

				}

				for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

					uvCopy.push( uv[ j ].clone() );

				}

				uvs1.push( uvCopy );

			}

		},

		mergeMesh: function ( mesh ) {

			if ( ! ( mesh && mesh.isMesh ) ) {

				console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
				return;

			}

			if ( mesh.matrixAutoUpdate ) mesh.updateMatrix();

			this.merge( mesh.geometry, mesh.matrix );

		},

		/*
		 * Checks for duplicate vertices with hashmap.
		 * Duplicated vertices are removed
		 * and faces' vertices are updated.
		 */

		mergeVertices: function () {

			var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
			var unique = [], changes = [];

			var v, key;
			var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
			var precision = Math.pow( 10, precisionPoints );
			var i, il, face;
			var indices, j, jl;

			for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

				v = this.vertices[ i ];
				key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

				if ( verticesMap[ key ] === undefined ) {

					verticesMap[ key ] = i;
					unique.push( this.vertices[ i ] );
					changes[ i ] = unique.length - 1;

				} else {

					//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
					changes[ i ] = changes[ verticesMap[ key ] ];

				}

			}


			// if faces are completely degenerate after merging vertices, we
			// have to remove them from the geometry.
			var faceIndicesToRemove = [];

			for ( i = 0, il = this.faces.length; i < il; i ++ ) {

				face = this.faces[ i ];

				face.a = changes[ face.a ];
				face.b = changes[ face.b ];
				face.c = changes[ face.c ];

				indices = [ face.a, face.b, face.c ];

				// if any duplicate vertices are found in a Face3
				// we have to remove the face as nothing can be saved
				for ( var n = 0; n < 3; n ++ ) {

					if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

						faceIndicesToRemove.push( i );
						break;

					}

				}

			}

			for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

				var idx = faceIndicesToRemove[ i ];

				this.faces.splice( idx, 1 );

				for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

					this.faceVertexUvs[ j ].splice( idx, 1 );

				}

			}

			// Use unique set of vertices

			var diff = this.vertices.length - unique.length;
			this.vertices = unique;
			return diff;

		},

		setFromPoints: function ( points ) {

			this.vertices = [];

			for ( var i = 0, l = points.length; i < l; i ++ ) {

				var point = points[ i ];
				this.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

			}

			return this;

		},

		sortFacesByMaterialIndex: function () {

			var faces = this.faces;
			var length = faces.length;

			// tag faces

			for ( var i = 0; i < length; i ++ ) {

				faces[ i ]._id = i;

			}

			// sort faces

			function materialIndexSort( a, b ) {

				return a.materialIndex - b.materialIndex;

			}

			faces.sort( materialIndexSort );

			// sort uvs

			var uvs1 = this.faceVertexUvs[ 0 ];
			var uvs2 = this.faceVertexUvs[ 1 ];

			var newUvs1, newUvs2;

			if ( uvs1 && uvs1.length === length ) newUvs1 = [];
			if ( uvs2 && uvs2.length === length ) newUvs2 = [];

			for ( var i = 0; i < length; i ++ ) {

				var id = faces[ i ]._id;

				if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
				if ( newUvs2 ) newUvs2.push( uvs2[ id ] );

			}

			if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
			if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;

		},

		toJSON: function () {

			var data = {
				metadata: {
					version: 4.5,
					type: 'Geometry',
					generator: 'Geometry.toJSON'
				}
			};

			// standard Geometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;

			if ( this.parameters !== undefined ) {

				var parameters = this.parameters;

				for ( var key in parameters ) {

					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

				}

				return data;

			}

			var vertices = [];

			for ( var i = 0; i < this.vertices.length; i ++ ) {

				var vertex = this.vertices[ i ];
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

			var faces = [];
			var normals = [];
			var normalsHash = {};
			var colors = [];
			var colorsHash = {};
			var uvs = [];
			var uvsHash = {};

			for ( var i = 0; i < this.faces.length; i ++ ) {

				var face = this.faces[ i ];

				var hasMaterial = true;
				var hasFaceUv = false; // deprecated
				var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
				var hasFaceNormal = face.normal.length() > 0;
				var hasFaceVertexNormal = face.vertexNormals.length > 0;
				var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
				var hasFaceVertexColor = face.vertexColors.length > 0;

				var faceType = 0;

				faceType = setBit( faceType, 0, 0 ); // isQuad
				faceType = setBit( faceType, 1, hasMaterial );
				faceType = setBit( faceType, 2, hasFaceUv );
				faceType = setBit( faceType, 3, hasFaceVertexUv );
				faceType = setBit( faceType, 4, hasFaceNormal );
				faceType = setBit( faceType, 5, hasFaceVertexNormal );
				faceType = setBit( faceType, 6, hasFaceColor );
				faceType = setBit( faceType, 7, hasFaceVertexColor );

				faces.push( faceType );
				faces.push( face.a, face.b, face.c );
				faces.push( face.materialIndex );

				if ( hasFaceVertexUv ) {

					var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

					faces.push(
						getUvIndex( faceVertexUvs[ 0 ] ),
						getUvIndex( faceVertexUvs[ 1 ] ),
						getUvIndex( faceVertexUvs[ 2 ] )
					);

				}

				if ( hasFaceNormal ) {

					faces.push( getNormalIndex( face.normal ) );

				}

				if ( hasFaceVertexNormal ) {

					var vertexNormals = face.vertexNormals;

					faces.push(
						getNormalIndex( vertexNormals[ 0 ] ),
						getNormalIndex( vertexNormals[ 1 ] ),
						getNormalIndex( vertexNormals[ 2 ] )
					);

				}

				if ( hasFaceColor ) {

					faces.push( getColorIndex( face.color ) );

				}

				if ( hasFaceVertexColor ) {

					var vertexColors = face.vertexColors;

					faces.push(
						getColorIndex( vertexColors[ 0 ] ),
						getColorIndex( vertexColors[ 1 ] ),
						getColorIndex( vertexColors[ 2 ] )
					);

				}

			}

			function setBit( value, position, enabled ) {

				return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

			}

			function getNormalIndex( normal ) {

				var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

				if ( normalsHash[ hash ] !== undefined ) {

					return normalsHash[ hash ];

				}

				normalsHash[ hash ] = normals.length / 3;
				normals.push( normal.x, normal.y, normal.z );

				return normalsHash[ hash ];

			}

			function getColorIndex( color ) {

				var hash = color.r.toString() + color.g.toString() + color.b.toString();

				if ( colorsHash[ hash ] !== undefined ) {

					return colorsHash[ hash ];

				}

				colorsHash[ hash ] = colors.length;
				colors.push( color.getHex() );

				return colorsHash[ hash ];

			}

			function getUvIndex( uv ) {

				var hash = uv.x.toString() + uv.y.toString();

				if ( uvsHash[ hash ] !== undefined ) {

					return uvsHash[ hash ];

				}

				uvsHash[ hash ] = uvs.length / 2;
				uvs.push( uv.x, uv.y );

				return uvsHash[ hash ];

			}

			data.data = {};

			data.data.vertices = vertices;
			data.data.normals = normals;
			if ( colors.length > 0 ) data.data.colors = colors;
			if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
			data.data.faces = faces;

			return data;

		},

		clone: function () {

			/*
			 // Handle primitives

			 var parameters = this.parameters;

			 if ( parameters !== undefined ) {

			 var values = [];

			 for ( var key in parameters ) {

			 values.push( parameters[ key ] );

			 }

			 var geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;

			 }

			 return new this.constructor().copy( this );
			 */

			return new Geometry().copy( this );

		},

		copy: function ( source ) {

			var i, il, j, jl, k, kl;

			// reset

			this.vertices = [];
			this.colors = [];
			this.faces = [];
			this.faceVertexUvs = [[]];
			this.morphTargets = [];
			this.morphNormals = [];
			this.skinWeights = [];
			this.skinIndices = [];
			this.lineDistances = [];
			this.boundingBox = null;
			this.boundingSphere = null;

			// name

			this.name = source.name;

			// vertices

			var vertices = source.vertices;

			for ( i = 0, il = vertices.length; i < il; i ++ ) {

				this.vertices.push( vertices[ i ].clone() );

			}

			// colors

			var colors = source.colors;

			for ( i = 0, il = colors.length; i < il; i ++ ) {

				this.colors.push( colors[ i ].clone() );

			}

			// faces

			var faces = source.faces;

			for ( i = 0, il = faces.length; i < il; i ++ ) {

				this.faces.push( faces[ i ].clone() );

			}

			// face vertex uvs

			for ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

				var faceVertexUvs = source.faceVertexUvs[ i ];

				if ( this.faceVertexUvs[ i ] === undefined ) {

					this.faceVertexUvs[ i ] = [];

				}

				for ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

					var uvs = faceVertexUvs[ j ], uvsCopy = [];

					for ( k = 0, kl = uvs.length; k < kl; k ++ ) {

						var uv = uvs[ k ];

						uvsCopy.push( uv.clone() );

					}

					this.faceVertexUvs[ i ].push( uvsCopy );

				}

			}

			// morph targets

			var morphTargets = source.morphTargets;

			for ( i = 0, il = morphTargets.length; i < il; i ++ ) {

				var morphTarget = {};
				morphTarget.name = morphTargets[ i ].name;

				// vertices

				if ( morphTargets[ i ].vertices !== undefined ) {

					morphTarget.vertices = [];

					for ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {

						morphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );

					}

				}

				// normals

				if ( morphTargets[ i ].normals !== undefined ) {

					morphTarget.normals = [];

					for ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {

						morphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );

					}

				}

				this.morphTargets.push( morphTarget );

			}

			// morph normals

			var morphNormals = source.morphNormals;

			for ( i = 0, il = morphNormals.length; i < il; i ++ ) {

				var morphNormal = {};

				// vertex normals

				if ( morphNormals[ i ].vertexNormals !== undefined ) {

					morphNormal.vertexNormals = [];

					for ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {

						var srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];
						var destVertexNormal = {};

						destVertexNormal.a = srcVertexNormal.a.clone();
						destVertexNormal.b = srcVertexNormal.b.clone();
						destVertexNormal.c = srcVertexNormal.c.clone();

						morphNormal.vertexNormals.push( destVertexNormal );

					}

				}

				// face normals

				if ( morphNormals[ i ].faceNormals !== undefined ) {

					morphNormal.faceNormals = [];

					for ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {

						morphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );

					}

				}

				this.morphNormals.push( morphNormal );

			}

			// skin weights

			var skinWeights = source.skinWeights;

			for ( i = 0, il = skinWeights.length; i < il; i ++ ) {

				this.skinWeights.push( skinWeights[ i ].clone() );

			}

			// skin indices

			var skinIndices = source.skinIndices;

			for ( i = 0, il = skinIndices.length; i < il; i ++ ) {

				this.skinIndices.push( skinIndices[ i ].clone() );

			}

			// line distances

			var lineDistances = source.lineDistances;

			for ( i = 0, il = lineDistances.length; i < il; i ++ ) {

				this.lineDistances.push( lineDistances[ i ] );

			}

			// bounding box

			var boundingBox = source.boundingBox;

			if ( boundingBox !== null ) {

				this.boundingBox = boundingBox.clone();

			}

			// bounding sphere

			var boundingSphere = source.boundingSphere;

			if ( boundingSphere !== null ) {

				this.boundingSphere = boundingSphere.clone();

			}

			// update flags

			this.elementsNeedUpdate = source.elementsNeedUpdate;
			this.verticesNeedUpdate = source.verticesNeedUpdate;
			this.uvsNeedUpdate = source.uvsNeedUpdate;
			this.normalsNeedUpdate = source.normalsNeedUpdate;
			this.colorsNeedUpdate = source.colorsNeedUpdate;
			this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
			this.groupsNeedUpdate = source.groupsNeedUpdate;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function BufferAttribute( array, itemSize, normalized ) {

		if ( Array.isArray( array ) ) {

			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

		}

		this.name = '';

		this.array = array;
		this.itemSize = itemSize;
		this.count = array !== undefined ? array.length / itemSize : 0;
		this.normalized = normalized === true;

		this.dynamic = false;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

	}

	Object.defineProperty( BufferAttribute.prototype, 'needsUpdate', {

		set: function ( value ) {

			if ( value === true ) this.version ++;

		}

	} );

	Object.assign( BufferAttribute.prototype, {

		isBufferAttribute: true,

		onUploadCallback: function () {},

		setArray: function ( array ) {

			if ( Array.isArray( array ) ) {

				throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

			}

			this.count = array !== undefined ? array.length / this.itemSize : 0;
			this.array = array;

			return this;

		},

		setDynamic: function ( value ) {

			this.dynamic = value;

			return this;

		},

		copy: function ( source ) {

			this.name = source.name;
			this.array = new source.array.constructor( source.array );
			this.itemSize = source.itemSize;
			this.count = source.count;
			this.normalized = source.normalized;

			this.dynamic = source.dynamic;

			return this;

		},

		copyAt: function ( index1, attribute, index2 ) {

			index1 *= this.itemSize;
			index2 *= attribute.itemSize;

			for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		},

		copyArray: function ( array ) {

			this.array.set( array );

			return this;

		},

		copyColorsArray: function ( colors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = colors.length; i < l; i ++ ) {

				var color = colors[ i ];

				if ( color === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
					color = new Color();

				}

				array[ offset ++ ] = color.r;
				array[ offset ++ ] = color.g;
				array[ offset ++ ] = color.b;

			}

			return this;

		},

		copyVector2sArray: function ( vectors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
					vector = new Vector2();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;

			}

			return this;

		},

		copyVector3sArray: function ( vectors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
					vector = new Vector3();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;

			}

			return this;

		},

		copyVector4sArray: function ( vectors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
					vector = new Vector4();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;
				array[ offset ++ ] = vector.w;

			}

			return this;

		},

		set: function ( value, offset ) {

			if ( offset === undefined ) offset = 0;

			this.array.set( value, offset );

			return this;

		},

		getX: function ( index ) {

			return this.array[ index * this.itemSize ];

		},

		setX: function ( index, x ) {

			this.array[ index * this.itemSize ] = x;

			return this;

		},

		getY: function ( index ) {

			return this.array[ index * this.itemSize + 1 ];

		},

		setY: function ( index, y ) {

			this.array[ index * this.itemSize + 1 ] = y;

			return this;

		},

		getZ: function ( index ) {

			return this.array[ index * this.itemSize + 2 ];

		},

		setZ: function ( index, z ) {

			this.array[ index * this.itemSize + 2 ] = z;

			return this;

		},

		getW: function ( index ) {

			return this.array[ index * this.itemSize + 3 ];

		},

		setW: function ( index, w ) {

			this.array[ index * this.itemSize + 3 ] = w;

			return this;

		},

		setXY: function ( index, x, y ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;

			return this;

		},

		setXYZ: function ( index, x, y, z ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;

			return this;

		},

		setXYZW: function ( index, x, y, z, w ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
			this.array[ index + 3 ] = w;

			return this;

		},

		onUpload: function ( callback ) {

			this.onUploadCallback = callback;

			return this;

		},

		clone: function () {

			return new this.constructor( this.array, this.itemSize ).copy( this );

		}

	} );

	//

	function Int8BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );

	}

	Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;


	function Uint8BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );

	}

	Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;


	function Uint8ClampedBufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );

	}

	Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;


	function Int16BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );

	}

	Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;


	function Uint16BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );

	}

	Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;


	function Int32BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );

	}

	Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;


	function Uint32BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );

	}

	Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;


	function Float32BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );

	}

	Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;


	function Float64BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );

	}

	Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function DirectGeometry() {

		this.vertices = [];
		this.normals = [];
		this.colors = [];
		this.uvs = [];
		this.uvs2 = [];

		this.groups = [];

		this.morphTargets = {};

		this.skinWeights = [];
		this.skinIndices = [];

		// this.lineDistances = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		// update flags

		this.verticesNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.groupsNeedUpdate = false;

	}

	Object.assign( DirectGeometry.prototype, {

		computeGroups: function ( geometry ) {

			var group;
			var groups = [];
			var materialIndex = undefined;

			var faces = geometry.faces;

			for ( var i = 0; i < faces.length; i ++ ) {

				var face = faces[ i ];

				// materials

				if ( face.materialIndex !== materialIndex ) {

					materialIndex = face.materialIndex;

					if ( group !== undefined ) {

						group.count = ( i * 3 ) - group.start;
						groups.push( group );

					}

					group = {
						start: i * 3,
						materialIndex: materialIndex
					};

				}

			}

			if ( group !== undefined ) {

				group.count = ( i * 3 ) - group.start;
				groups.push( group );

			}

			this.groups = groups;

		},

		fromGeometry: function ( geometry ) {

			var faces = geometry.faces;
			var vertices = geometry.vertices;
			var faceVertexUvs = geometry.faceVertexUvs;

			var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
			var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

			// morphs

			var morphTargets = geometry.morphTargets;
			var morphTargetsLength = morphTargets.length;

			var morphTargetsPosition;

			if ( morphTargetsLength > 0 ) {

				morphTargetsPosition = [];

				for ( var i = 0; i < morphTargetsLength; i ++ ) {

					morphTargetsPosition[ i ] = {
						name: morphTargets[ i ].name,
					 	data: []
					};

				}

				this.morphTargets.position = morphTargetsPosition;

			}

			var morphNormals = geometry.morphNormals;
			var morphNormalsLength = morphNormals.length;

			var morphTargetsNormal;

			if ( morphNormalsLength > 0 ) {

				morphTargetsNormal = [];

				for ( var i = 0; i < morphNormalsLength; i ++ ) {

					morphTargetsNormal[ i ] = {
						name: morphNormals[ i ].name,
					 	data: []
					};

				}

				this.morphTargets.normal = morphTargetsNormal;

			}

			// skins

			var skinIndices = geometry.skinIndices;
			var skinWeights = geometry.skinWeights;

			var hasSkinIndices = skinIndices.length === vertices.length;
			var hasSkinWeights = skinWeights.length === vertices.length;

			//

			if ( vertices.length > 0 && faces.length === 0 ) {

				console.error( 'THREE.DirectGeometry: Faceless geometries are not supported.' );

			}

			for ( var i = 0; i < faces.length; i ++ ) {

				var face = faces[ i ];

				this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

				var vertexNormals = face.vertexNormals;

				if ( vertexNormals.length === 3 ) {

					this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

				} else {

					var normal = face.normal;

					this.normals.push( normal, normal, normal );

				}

				var vertexColors = face.vertexColors;

				if ( vertexColors.length === 3 ) {

					this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

				} else {

					var color = face.color;

					this.colors.push( color, color, color );

				}

				if ( hasFaceVertexUv === true ) {

					var vertexUvs = faceVertexUvs[ 0 ][ i ];

					if ( vertexUvs !== undefined ) {

						this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

					} else {

						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

						this.uvs.push( new Vector2(), new Vector2(), new Vector2() );

					}

				}

				if ( hasFaceVertexUv2 === true ) {

					var vertexUvs = faceVertexUvs[ 1 ][ i ];

					if ( vertexUvs !== undefined ) {

						this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

					} else {

						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

						this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );

					}

				}

				// morphs

				for ( var j = 0; j < morphTargetsLength; j ++ ) {

					var morphTarget = morphTargets[ j ].vertices;

					morphTargetsPosition[ j ].data.push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

				}

				for ( var j = 0; j < morphNormalsLength; j ++ ) {

					var morphNormal = morphNormals[ j ].vertexNormals[ i ];

					morphTargetsNormal[ j ].data.push( morphNormal.a, morphNormal.b, morphNormal.c );

				}

				// skins

				if ( hasSkinIndices ) {

					this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

				}

				if ( hasSkinWeights ) {

					this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

				}

			}

			this.computeGroups( geometry );

			this.verticesNeedUpdate = geometry.verticesNeedUpdate;
			this.normalsNeedUpdate = geometry.normalsNeedUpdate;
			this.colorsNeedUpdate = geometry.colorsNeedUpdate;
			this.uvsNeedUpdate = geometry.uvsNeedUpdate;
			this.groupsNeedUpdate = geometry.groupsNeedUpdate;

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function arrayMax( array ) {

		if ( array.length === 0 ) return - Infinity;

		var max = array[ 0 ];

		for ( var i = 1, l = array.length; i < l; ++ i ) {

			if ( array[ i ] > max ) max = array[ i ];

		}

		return max;

	}

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	var bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id

	function BufferGeometry() {

		Object.defineProperty( this, 'id', { value: bufferGeometryId += 2 } );

		this.uuid = _Math.generateUUID();

		this.name = '';
		this.type = 'BufferGeometry';

		this.index = null;
		this.attributes = {};

		this.morphAttributes = {};

		this.groups = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		this.drawRange = { start: 0, count: Infinity };

		this.userData = {};

	}

	BufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: BufferGeometry,

		isBufferGeometry: true,

		getIndex: function () {

			return this.index;

		},

		setIndex: function ( index ) {

			if ( Array.isArray( index ) ) {

				this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

			} else {

				this.index = index;

			}

		},

		addAttribute: function ( name, attribute ) {

			if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {

				console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

				return this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

			}

			if ( name === 'index' ) {

				console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
				this.setIndex( attribute );

				return this;

			}

			this.attributes[ name ] = attribute;

			return this;

		},

		getAttribute: function ( name ) {

			return this.attributes[ name ];

		},

		removeAttribute: function ( name ) {

			delete this.attributes[ name ];

			return this;

		},

		addGroup: function ( start, count, materialIndex ) {

			this.groups.push( {

				start: start,
				count: count,
				materialIndex: materialIndex !== undefined ? materialIndex : 0

			} );

		},

		clearGroups: function () {

			this.groups = [];

		},

		setDrawRange: function ( start, count ) {

			this.drawRange.start = start;
			this.drawRange.count = count;

		},

		applyMatrix: function ( matrix ) {

			var position = this.attributes.position;

			if ( position !== undefined ) {

				matrix.applyToBufferAttribute( position );
				position.needsUpdate = true;

			}

			var normal = this.attributes.normal;

			if ( normal !== undefined ) {

				var normalMatrix = new Matrix3().getNormalMatrix( matrix );

				normalMatrix.applyToBufferAttribute( normal );
				normal.needsUpdate = true;

			}

			var tangent = this.attributes.tangent;

			if ( tangent !== undefined ) {

				var normalMatrix = new Matrix3().getNormalMatrix( matrix );

				// Tangent is vec4, but the '.w' component is a sign value (+1/-1).
				normalMatrix.applyToBufferAttribute( tangent );
				tangent.needsUpdate = true;

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

			return this;

		},

		rotateX: function () {

			// rotate geometry around world x-axis

			var m1 = new Matrix4();

			return function rotateX( angle ) {

				m1.makeRotationX( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateY: function () {

			// rotate geometry around world y-axis

			var m1 = new Matrix4();

			return function rotateY( angle ) {

				m1.makeRotationY( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateZ: function () {

			// rotate geometry around world z-axis

			var m1 = new Matrix4();

			return function rotateZ( angle ) {

				m1.makeRotationZ( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		translate: function () {

			// translate geometry

			var m1 = new Matrix4();

			return function translate( x, y, z ) {

				m1.makeTranslation( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		scale: function () {

			// scale geometry

			var m1 = new Matrix4();

			return function scale( x, y, z ) {

				m1.makeScale( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		lookAt: function () {

			var obj = new Object3D();

			return function lookAt( vector ) {

				obj.lookAt( vector );

				obj.updateMatrix();

				this.applyMatrix( obj.matrix );

			};

		}(),

		center: function () {

			var offset = new Vector3();

			return function center() {

				this.computeBoundingBox();

				this.boundingBox.getCenter( offset ).negate();

				this.translate( offset.x, offset.y, offset.z );

				return this;

			};

		}(),

		setFromObject: function ( object ) {

			// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

			var geometry = object.geometry;

			if ( object.isPoints || object.isLine ) {

				var positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );
				var colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );

				this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
				this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

				if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

					var lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );

					this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

				}

				if ( geometry.boundingSphere !== null ) {

					this.boundingSphere = geometry.boundingSphere.clone();

				}

				if ( geometry.boundingBox !== null ) {

					this.boundingBox = geometry.boundingBox.clone();

				}

			} else if ( object.isMesh ) {

				if ( geometry && geometry.isGeometry ) {

					this.fromGeometry( geometry );

				}

			}

			return this;

		},

		setFromPoints: function ( points ) {

			var position = [];

			for ( var i = 0, l = points.length; i < l; i ++ ) {

				var point = points[ i ];
				position.push( point.x, point.y, point.z || 0 );

			}

			this.addAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

			return this;

		},

		updateFromObject: function ( object ) {

			var geometry = object.geometry;

			if ( object.isMesh ) {

				var direct = geometry.__directGeometry;

				if ( geometry.elementsNeedUpdate === true ) {

					direct = undefined;
					geometry.elementsNeedUpdate = false;

				}

				if ( direct === undefined ) {

					return this.fromGeometry( geometry );

				}

				direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
				direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
				direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
				direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
				direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

				geometry.verticesNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.uvsNeedUpdate = false;
				geometry.groupsNeedUpdate = false;

				geometry = direct;

			}

			var attribute;

			if ( geometry.verticesNeedUpdate === true ) {

				attribute = this.attributes.position;

				if ( attribute !== undefined ) {

					attribute.copyVector3sArray( geometry.vertices );
					attribute.needsUpdate = true;

				}

				geometry.verticesNeedUpdate = false;

			}

			if ( geometry.normalsNeedUpdate === true ) {

				attribute = this.attributes.normal;

				if ( attribute !== undefined ) {

					attribute.copyVector3sArray( geometry.normals );
					attribute.needsUpdate = true;

				}

				geometry.normalsNeedUpdate = false;

			}

			if ( geometry.colorsNeedUpdate === true ) {

				attribute = this.attributes.color;

				if ( attribute !== undefined ) {

					attribute.copyColorsArray( geometry.colors );
					attribute.needsUpdate = true;

				}

				geometry.colorsNeedUpdate = false;

			}

			if ( geometry.uvsNeedUpdate ) {

				attribute = this.attributes.uv;

				if ( attribute !== undefined ) {

					attribute.copyVector2sArray( geometry.uvs );
					attribute.needsUpdate = true;

				}

				geometry.uvsNeedUpdate = false;

			}

			if ( geometry.lineDistancesNeedUpdate ) {

				attribute = this.attributes.lineDistance;

				if ( attribute !== undefined ) {

					attribute.copyArray( geometry.lineDistances );
					attribute.needsUpdate = true;

				}

				geometry.lineDistancesNeedUpdate = false;

			}

			if ( geometry.groupsNeedUpdate ) {

				geometry.computeGroups( object.geometry );
				this.groups = geometry.groups;

				geometry.groupsNeedUpdate = false;

			}

			return this;

		},

		fromGeometry: function ( geometry ) {

			geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );

			return this.fromDirectGeometry( geometry.__directGeometry );

		},

		fromDirectGeometry: function ( geometry ) {

			var positions = new Float32Array( geometry.vertices.length * 3 );
			this.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

			if ( geometry.normals.length > 0 ) {

				var normals = new Float32Array( geometry.normals.length * 3 );
				this.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

			}

			if ( geometry.colors.length > 0 ) {

				var colors = new Float32Array( geometry.colors.length * 3 );
				this.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

			}

			if ( geometry.uvs.length > 0 ) {

				var uvs = new Float32Array( geometry.uvs.length * 2 );
				this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

			}

			if ( geometry.uvs2.length > 0 ) {

				var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
				this.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

			}

			// groups

			this.groups = geometry.groups;

			// morphs

			for ( var name in geometry.morphTargets ) {

				var array = [];
				var morphTargets = geometry.morphTargets[ name ];

				for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

					var morphTarget = morphTargets[ i ];

					var attribute = new Float32BufferAttribute( morphTarget.data.length * 3, 3 );
					attribute.name = morphTarget.name;

					array.push( attribute.copyVector3sArray( morphTarget.data ) );

				}

				this.morphAttributes[ name ] = array;

			}

			// skinning

			if ( geometry.skinIndices.length > 0 ) {

				var skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );
				this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

			}

			if ( geometry.skinWeights.length > 0 ) {

				var skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );
				this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

			}

			//

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

			return this;

		},

		computeBoundingBox: function () {

			var box = new Box3();

			return function computeBoundingBox() {

				if ( this.boundingBox === null ) {

					this.boundingBox = new Box3();

				}

				var position = this.attributes.position;
				var morphAttributesPosition = this.morphAttributes.position;

				if ( position !== undefined ) {

					this.boundingBox.setFromBufferAttribute( position );

					// process morph attributes if present

					if ( morphAttributesPosition ) {

						for ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

							var morphAttribute = morphAttributesPosition[ i ];
							box.setFromBufferAttribute( morphAttribute );

							this.boundingBox.expandByPoint( box.min );
							this.boundingBox.expandByPoint( box.max );

						}

					}

				} else {

					this.boundingBox.makeEmpty();

				}

				if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

					console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

				}

			};

		}(),

		computeBoundingSphere: function () {

			var box = new Box3();
			var boxMorphTargets = new Box3();
			var vector = new Vector3();

			return function computeBoundingSphere() {

				if ( this.boundingSphere === null ) {

					this.boundingSphere = new Sphere();

				}

				var position = this.attributes.position;
				var morphAttributesPosition = this.morphAttributes.position;

				if ( position ) {

					// first, find the center of the bounding sphere

					var center = this.boundingSphere.center;

					box.setFromBufferAttribute( position );

					// process morph attributes if present

					if ( morphAttributesPosition ) {

						for ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

							var morphAttribute = morphAttributesPosition[ i ];
							boxMorphTargets.setFromBufferAttribute( morphAttribute );

							box.expandByPoint( boxMorphTargets.min );
							box.expandByPoint( boxMorphTargets.max );

						}

					}

					box.getCenter( center );

					// second, try to find a boundingSphere with a radius smaller than the
					// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

					var maxRadiusSq = 0;

					for ( var i = 0, il = position.count; i < il; i ++ ) {

						vector.fromBufferAttribute( position, i );

						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

					}

					// process morph attributes if present

					if ( morphAttributesPosition ) {

						for ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

							var morphAttribute = morphAttributesPosition[ i ];

							for ( var j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

								vector.fromBufferAttribute( morphAttribute, i );

								maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

							}

						}

					}

					this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

					if ( isNaN( this.boundingSphere.radius ) ) {

						console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

					}

				}

			};

		}(),

		computeFaceNormals: function () {

			// backwards compatibility

		},

		computeVertexNormals: function () {

			var index = this.index;
			var attributes = this.attributes;

			if ( attributes.position ) {

				var positions = attributes.position.array;

				if ( attributes.normal === undefined ) {

					this.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );

				} else {

					// reset existing normals to zero

					var array = attributes.normal.array;

					for ( var i = 0, il = array.length; i < il; i ++ ) {

						array[ i ] = 0;

					}

				}

				var normals = attributes.normal.array;

				var vA, vB, vC;
				var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
				var cb = new Vector3(), ab = new Vector3();

				// indexed elements

				if ( index ) {

					var indices = index.array;

					for ( var i = 0, il = index.count; i < il; i += 3 ) {

						vA = indices[ i + 0 ] * 3;
						vB = indices[ i + 1 ] * 3;
						vC = indices[ i + 2 ] * 3;

						pA.fromArray( positions, vA );
						pB.fromArray( positions, vB );
						pC.fromArray( positions, vC );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ vA ] += cb.x;
						normals[ vA + 1 ] += cb.y;
						normals[ vA + 2 ] += cb.z;

						normals[ vB ] += cb.x;
						normals[ vB + 1 ] += cb.y;
						normals[ vB + 2 ] += cb.z;

						normals[ vC ] += cb.x;
						normals[ vC + 1 ] += cb.y;
						normals[ vC + 2 ] += cb.z;

					}

				} else {

					// non-indexed elements (unconnected triangle soup)

					for ( var i = 0, il = positions.length; i < il; i += 9 ) {

						pA.fromArray( positions, i );
						pB.fromArray( positions, i + 3 );
						pC.fromArray( positions, i + 6 );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ i ] = cb.x;
						normals[ i + 1 ] = cb.y;
						normals[ i + 2 ] = cb.z;

						normals[ i + 3 ] = cb.x;
						normals[ i + 4 ] = cb.y;
						normals[ i + 5 ] = cb.z;

						normals[ i + 6 ] = cb.x;
						normals[ i + 7 ] = cb.y;
						normals[ i + 8 ] = cb.z;

					}

				}

				this.normalizeNormals();

				attributes.normal.needsUpdate = true;

			}

		},

		merge: function ( geometry, offset ) {

			if ( ! ( geometry && geometry.isBufferGeometry ) ) {

				console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
				return;

			}

			if ( offset === undefined ) {

				offset = 0;

				console.warn(
					'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
					+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
				);

			}

			var attributes = this.attributes;

			for ( var key in attributes ) {

				if ( geometry.attributes[ key ] === undefined ) continue;

				var attribute1 = attributes[ key ];
				var attributeArray1 = attribute1.array;

				var attribute2 = geometry.attributes[ key ];
				var attributeArray2 = attribute2.array;

				var attributeSize = attribute2.itemSize;

				for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

					attributeArray1[ j ] = attributeArray2[ i ];

				}

			}

			return this;

		},

		normalizeNormals: function () {

			var vector = new Vector3();

			return function normalizeNormals() {

				var normals = this.attributes.normal;

				for ( var i = 0, il = normals.count; i < il; i ++ ) {

					vector.x = normals.getX( i );
					vector.y = normals.getY( i );
					vector.z = normals.getZ( i );

					vector.normalize();

					normals.setXYZ( i, vector.x, vector.y, vector.z );

				}

			};

		}(),

		toNonIndexed: function () {

			function convertBufferAttribute( attribute, indices ) {

				var array = attribute.array;
				var itemSize = attribute.itemSize;

				var array2 = new array.constructor( indices.length * itemSize );

				var index = 0, index2 = 0;

				for ( var i = 0, l = indices.length; i < l; i ++ ) {

					index = indices[ i ] * itemSize;

					for ( var j = 0; j < itemSize; j ++ ) {

						array2[ index2 ++ ] = array[ index ++ ];

					}

				}

				return new BufferAttribute( array2, itemSize );

			}

			//

			if ( this.index === null ) {

				console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
				return this;

			}

			var geometry2 = new BufferGeometry();

			var indices = this.index.array;
			var attributes = this.attributes;

			// attributes

			for ( var name in attributes ) {

				var attribute = attributes[ name ];

				var newAttribute = convertBufferAttribute( attribute, indices );

				geometry2.addAttribute( name, newAttribute );

			}

			// morph attributes

			var morphAttributes = this.morphAttributes;

			for ( name in morphAttributes ) {

				var morphArray = [];
				var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

				for ( var i = 0, il = morphAttribute.length; i < il; i ++ ) {

					var attribute = morphAttribute[ i ];

					var newAttribute = convertBufferAttribute( attribute, indices );

					morphArray.push( newAttribute );

				}

				geometry2.morphAttributes[ name ] = morphArray;

			}

			// groups

			var groups = this.groups;

			for ( var i = 0, l = groups.length; i < l; i ++ ) {

				var group = groups[ i ];
				geometry2.addGroup( group.start, group.count, group.materialIndex );

			}

			return geometry2;

		},

		toJSON: function () {

			var data = {
				metadata: {
					version: 4.5,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			};

			// standard BufferGeometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;
			if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

			if ( this.parameters !== undefined ) {

				var parameters = this.parameters;

				for ( var key in parameters ) {

					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

				}

				return data;

			}

			data.data = { attributes: {} };

			var index = this.index;

			if ( index !== null ) {

				data.data.index = {
					type: index.array.constructor.name,
					array: Array.prototype.slice.call( index.array )
				};

			}

			var attributes = this.attributes;

			for ( var key in attributes ) {

				var attribute = attributes[ key ];

				var attributeData = {
					itemSize: attribute.itemSize,
					type: attribute.array.constructor.name,
					array: Array.prototype.slice.call( attribute.array ),
					normalized: attribute.normalized
				};

				if ( attribute.name !== '' ) attributeData.name = attribute.name;

				data.data.attributes[ key ] = attributeData;

			}

			var morphAttributes = {};
			var hasMorphAttributes = false;

			for ( var key in this.morphAttributes ) {

				var attributeArray = this.morphAttributes[ key ];

				var array = [];

				for ( var i = 0, il = attributeArray.length; i < il; i ++ ) {

					var attribute = attributeArray[ i ];

					var attributeData = {
						itemSize: attribute.itemSize,
						type: attribute.array.constructor.name,
						array: Array.prototype.slice.call( attribute.array ),
						normalized: attribute.normalized
					};

					if ( attribute.name !== '' ) attributeData.name = attribute.name;

					array.push( attributeData );

				}

				if ( array.length > 0 ) {

					morphAttributes[ key ] = array;

					hasMorphAttributes = true;

				}

			}

			if ( hasMorphAttributes ) data.data.morphAttributes = morphAttributes;

			var groups = this.groups;

			if ( groups.length > 0 ) {

				data.data.groups = JSON.parse( JSON.stringify( groups ) );

			}

			var boundingSphere = this.boundingSphere;

			if ( boundingSphere !== null ) {

				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				};

			}

			return data;

		},

		clone: function () {

			/*
			 // Handle primitives

			 var parameters = this.parameters;

			 if ( parameters !== undefined ) {

			 var values = [];

			 for ( var key in parameters ) {

			 values.push( parameters[ key ] );

			 }

			 var geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;

			 }

			 return new this.constructor().copy( this );
			 */

			return new BufferGeometry().copy( this );

		},

		copy: function ( source ) {

			var name, i, l;

			// reset

			this.index = null;
			this.attributes = {};
			this.morphAttributes = {};
			this.groups = [];
			this.boundingBox = null;
			this.boundingSphere = null;

			// name

			this.name = source.name;

			// index

			var index = source.index;

			if ( index !== null ) {

				this.setIndex( index.clone() );

			}

			// attributes

			var attributes = source.attributes;

			for ( name in attributes ) {

				var attribute = attributes[ name ];
				this.addAttribute( name, attribute.clone() );

			}

			// morph attributes

			var morphAttributes = source.morphAttributes;

			for ( name in morphAttributes ) {

				var array = [];
				var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

				for ( i = 0, l = morphAttribute.length; i < l; i ++ ) {

					array.push( morphAttribute[ i ].clone() );

				}

				this.morphAttributes[ name ] = array;

			}

			// groups

			var groups = source.groups;

			for ( i = 0, l = groups.length; i < l; i ++ ) {

				var group = groups[ i ];
				this.addGroup( group.start, group.count, group.materialIndex );

			}

			// bounding box

			var boundingBox = source.boundingBox;

			if ( boundingBox !== null ) {

				this.boundingBox = boundingBox.clone();

			}

			// bounding sphere

			var boundingSphere = source.boundingSphere;

			if ( boundingSphere !== null ) {

				this.boundingSphere = boundingSphere.clone();

			}

			// draw range

			this.drawRange.start = source.drawRange.start;
			this.drawRange.count = source.drawRange.count;

			// user data

			this.userData = source.userData;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// BoxGeometry

	function BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

		Geometry.call( this );

		this.type = 'BoxGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
		this.mergeVertices();

	}

	BoxGeometry.prototype = Object.create( Geometry.prototype );
	BoxGeometry.prototype.constructor = BoxGeometry;

	// BoxBufferGeometry

	function BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

		BufferGeometry.call( this );

		this.type = 'BoxBufferGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		var scope = this;

		width = width || 1;
		height = height || 1;
		depth = depth || 1;

		// segments

		widthSegments = Math.floor( widthSegments ) || 1;
		heightSegments = Math.floor( heightSegments ) || 1;
		depthSegments = Math.floor( depthSegments ) || 1;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var numberOfVertices = 0;
		var groupStart = 0;

		// build each side of the box geometry

		buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
		buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
		buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
		buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
		buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
		buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

			var segmentWidth = width / gridX;
			var segmentHeight = height / gridY;

			var widthHalf = width / 2;
			var heightHalf = height / 2;
			var depthHalf = depth / 2;

			var gridX1 = gridX + 1;
			var gridY1 = gridY + 1;

			var vertexCounter = 0;
			var groupCount = 0;

			var ix, iy;

			var vector = new Vector3();

			// generate vertices, normals and uvs

			for ( iy = 0; iy < gridY1; iy ++ ) {

				var y = iy * segmentHeight - heightHalf;

				for ( ix = 0; ix < gridX1; ix ++ ) {

					var x = ix * segmentWidth - widthHalf;

					// set values to correct vector component

					vector[ u ] = x * udir;
					vector[ v ] = y * vdir;
					vector[ w ] = depthHalf;

					// now apply vector to vertex buffer

					vertices.push( vector.x, vector.y, vector.z );

					// set values to correct vector component

					vector[ u ] = 0;
					vector[ v ] = 0;
					vector[ w ] = depth > 0 ? 1 : - 1;

					// now apply vector to normal buffer

					normals.push( vector.x, vector.y, vector.z );

					// uvs

					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );

					// counters

					vertexCounter += 1;

				}

			}

			// indices

			// 1. you need three indices to draw a single face
			// 2. a single segment consists of two faces
			// 3. so we need to generate six (2*3) indices per segment

			for ( iy = 0; iy < gridY; iy ++ ) {

				for ( ix = 0; ix < gridX; ix ++ ) {

					var a = numberOfVertices + ix + gridX1 * iy;
					var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
					var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
					var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// increase counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, materialIndex );

			// calculate new start value for groups

			groupStart += groupCount;

			// update total number of vertices

			numberOfVertices += vertexCounter;

		}

	}

	BoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// PlaneGeometry

	function PlaneGeometry( width, height, widthSegments, heightSegments ) {

		Geometry.call( this );

		this.type = 'PlaneGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );
		this.mergeVertices();

	}

	PlaneGeometry.prototype = Object.create( Geometry.prototype );
	PlaneGeometry.prototype.constructor = PlaneGeometry;

	// PlaneBufferGeometry

	function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {

		BufferGeometry.call( this );

		this.type = 'PlaneBufferGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		width = width || 1;
		height = height || 1;

		var width_half = width / 2;
		var height_half = height / 2;

		var gridX = Math.floor( widthSegments ) || 1;
		var gridY = Math.floor( heightSegments ) || 1;

		var gridX1 = gridX + 1;
		var gridY1 = gridY + 1;

		var segment_width = width / gridX;
		var segment_height = height / gridY;

		var ix, iy;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// generate vertices, normals and uvs

		for ( iy = 0; iy < gridY1; iy ++ ) {

			var y = iy * segment_height - height_half;

			for ( ix = 0; ix < gridX1; ix ++ ) {

				var x = ix * segment_width - width_half;

				vertices.push( x, - y, 0 );

				normals.push( 0, 0, 1 );

				uvs.push( ix / gridX );
				uvs.push( 1 - ( iy / gridY ) );

			}

		}

		// indices

		for ( iy = 0; iy < gridY; iy ++ ) {

			for ( ix = 0; ix < gridX; ix ++ ) {

				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	var materialId = 0;

	function Material() {

		Object.defineProperty( this, 'id', { value: materialId ++ } );

		this.uuid = _Math.generateUUID();

		this.name = '';
		this.type = 'Material';

		this.fog = true;
		this.lights = true;

		this.blending = NormalBlending;
		this.side = FrontSide;
		this.flatShading = false;
		this.vertexTangents = false;
		this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors

		this.opacity = 1;
		this.transparent = false;

		this.blendSrc = SrcAlphaFactor;
		this.blendDst = OneMinusSrcAlphaFactor;
		this.blendEquation = AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;

		this.depthFunc = LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;

		this.clippingPlanes = null;
		this.clipIntersection = false;
		this.clipShadows = false;

		this.shadowSide = null;

		this.colorWrite = true;

		this.precision = null; // override the renderer's default precision for this material

		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;

		this.dithering = false;

		this.alphaTest = 0;
		this.premultipliedAlpha = false;

		this.visible = true;

		this.userData = {};

		this.needsUpdate = true;

	}

	Material.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Material,

		isMaterial: true,

		onBeforeCompile: function () {},

		setValues: function ( values ) {

			if ( values === undefined ) return;

			for ( var key in values ) {

				var newValue = values[ key ];

				if ( newValue === undefined ) {

					console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
					continue;

				}

				// for backward compatability if shading is set in the constructor
				if ( key === 'shading' ) {

					console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
					this.flatShading = ( newValue === FlatShading ) ? true : false;
					continue;

				}

				var currentValue = this[ key ];

				if ( currentValue === undefined ) {

					console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
					continue;

				}

				if ( currentValue && currentValue.isColor ) {

					currentValue.set( newValue );

				} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

					currentValue.copy( newValue );

				} else {

					this[ key ] = newValue;

				}

			}

		},

		toJSON: function ( meta ) {

			var isRoot = ( meta === undefined || typeof meta === 'string' );

			if ( isRoot ) {

				meta = {
					textures: {},
					images: {}
				};

			}

			var data = {
				metadata: {
					version: 4.5,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			};

			// standard Material serialization
			data.uuid = this.uuid;
			data.type = this.type;

			if ( this.name !== '' ) data.name = this.name;

			if ( this.color && this.color.isColor ) data.color = this.color.getHex();

			if ( this.roughness !== undefined ) data.roughness = this.roughness;
			if ( this.metalness !== undefined ) data.metalness = this.metalness;

			if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
			if ( this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

			if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
			if ( this.shininess !== undefined ) data.shininess = this.shininess;
			if ( this.clearCoat !== undefined ) data.clearCoat = this.clearCoat;
			if ( this.clearCoatRoughness !== undefined ) data.clearCoatRoughness = this.clearCoatRoughness;

			if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
			if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
			if ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;

			if ( this.aoMap && this.aoMap.isTexture ) {

				data.aoMap = this.aoMap.toJSON( meta ).uuid;
				data.aoMapIntensity = this.aoMapIntensity;

			}

			if ( this.bumpMap && this.bumpMap.isTexture ) {

				data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
				data.bumpScale = this.bumpScale;

			}

			if ( this.normalMap && this.normalMap.isTexture ) {

				data.normalMap = this.normalMap.toJSON( meta ).uuid;
				data.normalMapType = this.normalMapType;
				data.normalScale = this.normalScale.toArray();

			}

			if ( this.displacementMap && this.displacementMap.isTexture ) {

				data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;

			}

			if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
			if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

			if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
			if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

			if ( this.envMap && this.envMap.isTexture ) {

				data.envMap = this.envMap.toJSON( meta ).uuid;
				data.reflectivity = this.reflectivity; // Scale behind envMap

				if ( this.combine !== undefined ) data.combine = this.combine;
				if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;

			}

			if ( this.gradientMap && this.gradientMap.isTexture ) {

				data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

			}

			if ( this.size !== undefined ) data.size = this.size;
			if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

			if ( this.blending !== NormalBlending ) data.blending = this.blending;
			if ( this.flatShading === true ) data.flatShading = this.flatShading;
			if ( this.side !== FrontSide ) data.side = this.side;
			if ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;

			if ( this.opacity < 1 ) data.opacity = this.opacity;
			if ( this.transparent === true ) data.transparent = this.transparent;

			data.depthFunc = this.depthFunc;
			data.depthTest = this.depthTest;
			data.depthWrite = this.depthWrite;

			// rotation (SpriteMaterial)
			if ( this.rotation !== 0 ) data.rotation = this.rotation;

			if ( this.polygonOffset === true ) data.polygonOffset = true;
			if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
			if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

			if ( this.linewidth !== 1 ) data.linewidth = this.linewidth;
			if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
			if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
			if ( this.scale !== undefined ) data.scale = this.scale;

			if ( this.dithering === true ) data.dithering = true;

			if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
			if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;

			if ( this.wireframe === true ) data.wireframe = this.wireframe;
			if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
			if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
			if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

			if ( this.morphTargets === true ) data.morphTargets = true;
			if ( this.skinning === true ) data.skinning = true;

			if ( this.visible === false ) data.visible = false;
			if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;

			// TODO: Copied from Object3D.toJSON

			function extractFromCache( cache ) {

				var values = [];

				for ( var key in cache ) {

					var data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}

				return values;

			}

			if ( isRoot ) {

				var textures = extractFromCache( meta.textures );
				var images = extractFromCache( meta.images );

				if ( textures.length > 0 ) data.textures = textures;
				if ( images.length > 0 ) data.images = images;

			}

			return data;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.name = source.name;

			this.fog = source.fog;
			this.lights = source.lights;

			this.blending = source.blending;
			this.side = source.side;
			this.flatShading = source.flatShading;
			this.vertexColors = source.vertexColors;

			this.opacity = source.opacity;
			this.transparent = source.transparent;

			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;

			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;

			this.colorWrite = source.colorWrite;

			this.precision = source.precision;

			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;

			this.dithering = source.dithering;

			this.alphaTest = source.alphaTest;
			this.premultipliedAlpha = source.premultipliedAlpha;

			this.visible = source.visible;
			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			this.clipShadows = source.clipShadows;
			this.clipIntersection = source.clipIntersection;

			var srcPlanes = source.clippingPlanes,
				dstPlanes = null;

			if ( srcPlanes !== null ) {

				var n = srcPlanes.length;
				dstPlanes = new Array( n );

				for ( var i = 0; i !== n; ++ i )
					dstPlanes[ i ] = srcPlanes[ i ].clone();

			}

			this.clippingPlanes = dstPlanes;

			this.shadowSide = source.shadowSide;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

	var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  defines: { "label" : "value" },
	 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
	 *
	 *  fragmentShader: <string>,
	 *  vertexShader: <string>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  lights: <bool>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function ShaderMaterial( parameters ) {

		Material.call( this );

		this.type = 'ShaderMaterial';

		this.defines = {};
		this.uniforms = {};

		this.vertexShader = default_vertex;
		this.fragmentShader = default_fragment;

		this.linewidth = 1;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false; // set to use scene fog
		this.lights = false; // set to use scene lights
		this.clipping = false; // set to use user-defined clipping planes

		this.skinning = false; // set to use skinning attribute streams
		this.morphTargets = false; // set to use morph targets
		this.morphNormals = false; // set to use morph normals

		this.extensions = {
			derivatives: false, // set to use derivatives
			fragDepth: false, // set to use fragment depth values
			drawBuffers: false, // set to use draw buffers
			shaderTextureLOD: false // set to use shader texture LOD
		};

		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv2': [ 0, 0 ]
		};

		this.index0AttributeName = undefined;
		this.uniformsNeedUpdate = false;

		if ( parameters !== undefined ) {

			if ( parameters.attributes !== undefined ) {

				console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

			}

			this.setValues( parameters );

		}

	}

	ShaderMaterial.prototype = Object.create( Material.prototype );
	ShaderMaterial.prototype.constructor = ShaderMaterial;

	ShaderMaterial.prototype.isShaderMaterial = true;

	ShaderMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;

		this.uniforms = cloneUniforms( source.uniforms );

		this.defines = Object.assign( {}, source.defines );

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.lights = source.lights;
		this.clipping = source.clipping;

		this.skinning = source.skinning;

		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		this.extensions = source.extensions;

		return this;

	};

	ShaderMaterial.prototype.toJSON = function ( meta ) {

		var data = Material.prototype.toJSON.call( this, meta );

		data.uniforms = {};

		for ( var name in this.uniforms ) {

			var uniform = this.uniforms[ name ];
			var value = uniform.value;

			if ( value && value.isTexture ) {

				data.uniforms[ name ] = {
					type: 't',
					value: value.toJSON( meta ).uuid
				};

			} else if ( value && value.isColor ) {

				data.uniforms[ name ] = {
					type: 'c',
					value: value.getHex()
				};

			} else if ( value && value.isVector2 ) {

				data.uniforms[ name ] = {
					type: 'v2',
					value: value.toArray()
				};

			} else if ( value && value.isVector3 ) {

				data.uniforms[ name ] = {
					type: 'v3',
					value: value.toArray()
				};

			} else if ( value && value.isVector4 ) {

				data.uniforms[ name ] = {
					type: 'v4',
					value: value.toArray()
				};

			} else if ( value && value.isMatrix3 ) {

				data.uniforms[ name ] = {
					type: 'm3',
					value: value.toArray()
				};

			} else if ( value && value.isMatrix4 ) {

				data.uniforms[ name ] = {
					type: 'm4',
					value: value.toArray()
				};

			} else {

				data.uniforms[ name ] = {
					value: value
				};

				// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

			}

		}

		if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;

		var extensions = {};

		for ( var key in this.extensions ) {

			if ( this.extensions[ key ] === true ) extensions[ key ] = true;

		}

		if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

		return data;

	};

	/**
	 * @author bhouston / http://clara.io
	 */

	function Ray( origin, direction ) {

		this.origin = ( origin !== undefined ) ? origin : new Vector3();
		this.direction = ( direction !== undefined ) ? direction : new Vector3();

	}

	Object.assign( Ray.prototype, {

		set: function ( origin, direction ) {

			this.origin.copy( origin );
			this.direction.copy( direction );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( ray ) {

			this.origin.copy( ray.origin );
			this.direction.copy( ray.direction );

			return this;

		},

		at: function ( t, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Ray: .at() target is now required' );
				target = new Vector3();

			}

			return target.copy( this.direction ).multiplyScalar( t ).add( this.origin );

		},

		lookAt: function ( v ) {

			this.direction.copy( v ).sub( this.origin ).normalize();

			return this;

		},

		recast: function () {

			var v1 = new Vector3();

			return function recast( t ) {

				this.origin.copy( this.at( t, v1 ) );

				return this;

			};

		}(),

		closestPointToPoint: function ( point, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Ray: .closestPointToPoint() target is now required' );
				target = new Vector3();

			}

			target.subVectors( point, this.origin );

			var directionDistance = target.dot( this.direction );

			if ( directionDistance < 0 ) {

				return target.copy( this.origin );

			}

			return target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

		},

		distanceToPoint: function ( point ) {

			return Math.sqrt( this.distanceSqToPoint( point ) );

		},

		distanceSqToPoint: function () {

			var v1 = new Vector3();

			return function distanceSqToPoint( point ) {

				var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

				// point behind the ray

				if ( directionDistance < 0 ) {

					return this.origin.distanceToSquared( point );

				}

				v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

				return v1.distanceToSquared( point );

			};

		}(),

		distanceSqToSegment: function () {

			var segCenter = new Vector3();
			var segDir = new Vector3();
			var diff = new Vector3();

			return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

				// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
				// It returns the min distance between the ray and the segment
				// defined by v0 and v1
				// It can also set two optional targets :
				// - The closest point on the ray
				// - The closest point on the segment

				segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
				segDir.copy( v1 ).sub( v0 ).normalize();
				diff.copy( this.origin ).sub( segCenter );

				var segExtent = v0.distanceTo( v1 ) * 0.5;
				var a01 = - this.direction.dot( segDir );
				var b0 = diff.dot( this.direction );
				var b1 = - diff.dot( segDir );
				var c = diff.lengthSq();
				var det = Math.abs( 1 - a01 * a01 );
				var s0, s1, sqrDist, extDet;

				if ( det > 0 ) {

					// The ray and segment are not parallel.

					s0 = a01 * b1 - b0;
					s1 = a01 * b0 - b1;
					extDet = segExtent * det;

					if ( s0 >= 0 ) {

						if ( s1 >= - extDet ) {

							if ( s1 <= extDet ) {

								// region 0
								// Minimum at interior points of ray and segment.

								var invDet = 1 / det;
								s0 *= invDet;
								s1 *= invDet;
								sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

							} else {

								// region 1

								s1 = segExtent;
								s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

							}

						} else {

							// region 5

							s1 = - segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					} else {

						if ( s1 <= - extDet ) {

							// region 4

							s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						} else if ( s1 <= extDet ) {

							// region 3

							s0 = 0;
							s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = s1 * ( s1 + 2 * b1 ) + c;

						} else {

							// region 2

							s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					}

				} else {

					// Ray and segment are parallel.

					s1 = ( a01 > 0 ) ? - segExtent : segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

				if ( optionalPointOnRay ) {

					optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

				}

				if ( optionalPointOnSegment ) {

					optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

				}

				return sqrDist;

			};

		}(),

		intersectSphere: function () {

			var v1 = new Vector3();

			return function intersectSphere( sphere, target ) {

				v1.subVectors( sphere.center, this.origin );
				var tca = v1.dot( this.direction );
				var d2 = v1.dot( v1 ) - tca * tca;
				var radius2 = sphere.radius * sphere.radius;

				if ( d2 > radius2 ) return null;

				var thc = Math.sqrt( radius2 - d2 );

				// t0 = first intersect point - entrance on front of sphere
				var t0 = tca - thc;

				// t1 = second intersect point - exit point on back of sphere
				var t1 = tca + thc;

				// test to see if both t0 and t1 are behind the ray - if so, return null
				if ( t0 < 0 && t1 < 0 ) return null;

				// test to see if t0 is behind the ray:
				// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
				// in order to always return an intersect point that is in front of the ray.
				if ( t0 < 0 ) return this.at( t1, target );

				// else t0 is in front of the ray, so return the first collision point scaled by t0
				return this.at( t0, target );

			};

		}(),

		intersectsSphere: function ( sphere ) {

			return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

		},

		distanceToPlane: function ( plane ) {

			var denominator = plane.normal.dot( this.direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( plane.distanceToPoint( this.origin ) === 0 ) {

					return 0;

				}

				// Null is preferable to undefined since undefined means.... it is undefined

				return null;

			}

			var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

			// Return if the ray never intersects the plane

			return t >= 0 ? t : null;

		},

		intersectPlane: function ( plane, target ) {

			var t = this.distanceToPlane( plane );

			if ( t === null ) {

				return null;

			}

			return this.at( t, target );

		},

		intersectsPlane: function ( plane ) {

			// check if the ray lies on the plane first

			var distToPoint = plane.distanceToPoint( this.origin );

			if ( distToPoint === 0 ) {

				return true;

			}

			var denominator = plane.normal.dot( this.direction );

			if ( denominator * distToPoint < 0 ) {

				return true;

			}

			// ray origin is behind the plane (and is pointing behind it)

			return false;

		},

		intersectBox: function ( box, target ) {

			var tmin, tmax, tymin, tymax, tzmin, tzmax;

			var invdirx = 1 / this.direction.x,
				invdiry = 1 / this.direction.y,
				invdirz = 1 / this.direction.z;

			var origin = this.origin;

			if ( invdirx >= 0 ) {

				tmin = ( box.min.x - origin.x ) * invdirx;
				tmax = ( box.max.x - origin.x ) * invdirx;

			} else {

				tmin = ( box.max.x - origin.x ) * invdirx;
				tmax = ( box.min.x - origin.x ) * invdirx;

			}

			if ( invdiry >= 0 ) {

				tymin = ( box.min.y - origin.y ) * invdiry;
				tymax = ( box.max.y - origin.y ) * invdiry;

			} else {

				tymin = ( box.max.y - origin.y ) * invdiry;
				tymax = ( box.min.y - origin.y ) * invdiry;

			}

			if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

			// These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN

			if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

			if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

			if ( invdirz >= 0 ) {

				tzmin = ( box.min.z - origin.z ) * invdirz;
				tzmax = ( box.max.z - origin.z ) * invdirz;

			} else {

				tzmin = ( box.max.z - origin.z ) * invdirz;
				tzmax = ( box.min.z - origin.z ) * invdirz;

			}

			if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

			if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

			if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

			//return point closest to the ray (positive side)

			if ( tmax < 0 ) return null;

			return this.at( tmin >= 0 ? tmin : tmax, target );

		},

		intersectsBox: ( function () {

			var v = new Vector3();

			return function intersectsBox( box ) {

				return this.intersectBox( box, v ) !== null;

			};

		} )(),

		intersectTriangle: function () {

			// Compute the offset origin, edges, and normal.
			var diff = new Vector3();
			var edge1 = new Vector3();
			var edge2 = new Vector3();
			var normal = new Vector3();

			return function intersectTriangle( a, b, c, backfaceCulling, target ) {

				// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

				edge1.subVectors( b, a );
				edge2.subVectors( c, a );
				normal.crossVectors( edge1, edge2 );

				// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
				// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
				//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
				//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
				//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
				var DdN = this.direction.dot( normal );
				var sign;

				if ( DdN > 0 ) {

					if ( backfaceCulling ) return null;
					sign = 1;

				} else if ( DdN < 0 ) {

					sign = - 1;
					DdN = - DdN;

				} else {

					return null;

				}

				diff.subVectors( this.origin, a );
				var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

				// b1 < 0, no intersection
				if ( DdQxE2 < 0 ) {

					return null;

				}

				var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

				// b2 < 0, no intersection
				if ( DdE1xQ < 0 ) {

					return null;

				}

				// b1+b2 > 1, no intersection
				if ( DdQxE2 + DdE1xQ > DdN ) {

					return null;

				}

				// Line intersects triangle, check if ray does.
				var QdN = - sign * diff.dot( normal );

				// t < 0, no intersection
				if ( QdN < 0 ) {

					return null;

				}

				// Ray intersects triangle.
				return this.at( QdN / DdN, target );

			};

		}(),

		applyMatrix4: function ( matrix4 ) {

			this.origin.applyMatrix4( matrix4 );
			this.direction.transformDirection( matrix4 );

			return this;

		},

		equals: function ( ray ) {

			return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Triangle( a, b, c ) {

		this.a = ( a !== undefined ) ? a : new Vector3();
		this.b = ( b !== undefined ) ? b : new Vector3();
		this.c = ( c !== undefined ) ? c : new Vector3();

	}

	Object.assign( Triangle, {

		getNormal: function () {

			var v0 = new Vector3();

			return function getNormal( a, b, c, target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Triangle: .getNormal() target is now required' );
					target = new Vector3();

				}

				target.subVectors( c, b );
				v0.subVectors( a, b );
				target.cross( v0 );

				var targetLengthSq = target.lengthSq();
				if ( targetLengthSq > 0 ) {

					return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

				}

				return target.set( 0, 0, 0 );

			};

		}(),

		// static/instance method to calculate barycentric coordinates
		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
		getBarycoord: function () {

			var v0 = new Vector3();
			var v1 = new Vector3();
			var v2 = new Vector3();

			return function getBarycoord( point, a, b, c, target ) {

				v0.subVectors( c, a );
				v1.subVectors( b, a );
				v2.subVectors( point, a );

				var dot00 = v0.dot( v0 );
				var dot01 = v0.dot( v1 );
				var dot02 = v0.dot( v2 );
				var dot11 = v1.dot( v1 );
				var dot12 = v1.dot( v2 );

				var denom = ( dot00 * dot11 - dot01 * dot01 );

				if ( target === undefined ) {

					console.warn( 'THREE.Triangle: .getBarycoord() target is now required' );
					target = new Vector3();

				}

				// collinear or singular triangle
				if ( denom === 0 ) {

					// arbitrary location outside of triangle?
					// not sure if this is the best idea, maybe should be returning undefined
					return target.set( - 2, - 1, - 1 );

				}

				var invDenom = 1 / denom;
				var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
				var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

				// barycentric coordinates must always sum to 1
				return target.set( 1 - u - v, v, u );

			};

		}(),

		containsPoint: function () {

			var v1 = new Vector3();

			return function containsPoint( point, a, b, c ) {

				Triangle.getBarycoord( point, a, b, c, v1 );

				return ( v1.x >= 0 ) && ( v1.y >= 0 ) && ( ( v1.x + v1.y ) <= 1 );

			};

		}(),

		getUV: function () {

			var barycoord = new Vector3();

			return function getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {

				this.getBarycoord( point, p1, p2, p3, barycoord );

				target.set( 0, 0 );
				target.addScaledVector( uv1, barycoord.x );
				target.addScaledVector( uv2, barycoord.y );
				target.addScaledVector( uv3, barycoord.z );

				return target;

			};

		}()

	} );

	Object.assign( Triangle.prototype, {

		set: function ( a, b, c ) {

			this.a.copy( a );
			this.b.copy( b );
			this.c.copy( c );

			return this;

		},

		setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

			this.a.copy( points[ i0 ] );
			this.b.copy( points[ i1 ] );
			this.c.copy( points[ i2 ] );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( triangle ) {

			this.a.copy( triangle.a );
			this.b.copy( triangle.b );
			this.c.copy( triangle.c );

			return this;

		},

		getArea: function () {

			var v0 = new Vector3();
			var v1 = new Vector3();

			return function getArea() {

				v0.subVectors( this.c, this.b );
				v1.subVectors( this.a, this.b );

				return v0.cross( v1 ).length() * 0.5;

			};

		}(),

		getMidpoint: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Triangle: .getMidpoint() target is now required' );
				target = new Vector3();

			}

			return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

		},

		getNormal: function ( target ) {

			return Triangle.getNormal( this.a, this.b, this.c, target );

		},

		getPlane: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Triangle: .getPlane() target is now required' );
				target = new Vector3();

			}

			return target.setFromCoplanarPoints( this.a, this.b, this.c );

		},

		getBarycoord: function ( point, target ) {

			return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

		},

		containsPoint: function ( point ) {

			return Triangle.containsPoint( point, this.a, this.b, this.c );

		},

		getUV: function ( point, uv1, uv2, uv3, result ) {

			return Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, result );

		},

		intersectsBox: function ( box ) {

			return box.intersectsTriangle( this );

		},

		closestPointToPoint: function () {

			var vab = new Vector3();
			var vac = new Vector3();
			var vbc = new Vector3();
			var vap = new Vector3();
			var vbp = new Vector3();
			var vcp = new Vector3();

			return function closestPointToPoint( p, target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Triangle: .closestPointToPoint() target is now required' );
					target = new Vector3();

				}

				var a = this.a, b = this.b, c = this.c;
				var v, w;

				// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
				// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
				// under the accompanying license; see chapter 5.1.5 for detailed explanation.
				// basically, we're distinguishing which of the voronoi regions of the triangle
				// the point lies in with the minimum amount of redundant computation.

				vab.subVectors( b, a );
				vac.subVectors( c, a );
				vap.subVectors( p, a );
				var d1 = vab.dot( vap );
				var d2 = vac.dot( vap );
				if ( d1 <= 0 && d2 <= 0 ) {

					// vertex region of A; barycentric coords (1, 0, 0)
					return target.copy( a );

				}

				vbp.subVectors( p, b );
				var d3 = vab.dot( vbp );
				var d4 = vac.dot( vbp );
				if ( d3 >= 0 && d4 <= d3 ) {

					// vertex region of B; barycentric coords (0, 1, 0)
					return target.copy( b );

				}

				var vc = d1 * d4 - d3 * d2;
				if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

					v = d1 / ( d1 - d3 );
					// edge region of AB; barycentric coords (1-v, v, 0)
					return target.copy( a ).addScaledVector( vab, v );

				}

				vcp.subVectors( p, c );
				var d5 = vab.dot( vcp );
				var d6 = vac.dot( vcp );
				if ( d6 >= 0 && d5 <= d6 ) {

					// vertex region of C; barycentric coords (0, 0, 1)
					return target.copy( c );

				}

				var vb = d5 * d2 - d1 * d6;
				if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

					w = d2 / ( d2 - d6 );
					// edge region of AC; barycentric coords (1-w, 0, w)
					return target.copy( a ).addScaledVector( vac, w );

				}

				var va = d3 * d6 - d5 * d4;
				if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

					vbc.subVectors( c, b );
					w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
					// edge region of BC; barycentric coords (0, 1-w, w)
					return target.copy( b ).addScaledVector( vbc, w ); // edge region of BC

				}

				// face region
				var denom = 1 / ( va + vb + vc );
				// u = va * denom
				v = vb * denom;
				w = vc * denom;
				return target.copy( a ).addScaledVector( vab, v ).addScaledVector( vac, w );

			};

		}(),

		equals: function ( triangle ) {

			return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>
	 * }
	 */

	function MeshBasicMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshBasicMaterial';

		this.color = new Color( 0xffffff ); // emissive

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;

		this.lights = false;

		this.setValues( parameters );

	}

	MeshBasicMaterial.prototype = Object.create( Material.prototype );
	MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

	MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

	MeshBasicMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		return this;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author jonobr1 / http://jonobr1.com/
	 */

	function Mesh( geometry, material ) {

		Object3D.call( this );

		this.type = 'Mesh';

		this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
		this.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );

		this.drawMode = TrianglesDrawMode;

		this.updateMorphTargets();

	}

	Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Mesh,

		isMesh: true,

		setDrawMode: function ( value ) {

			this.drawMode = value;

		},

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source );

			this.drawMode = source.drawMode;

			if ( source.morphTargetInfluences !== undefined ) {

				this.morphTargetInfluences = source.morphTargetInfluences.slice();

			}

			if ( source.morphTargetDictionary !== undefined ) {

				this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

			}

			return this;

		},

		updateMorphTargets: function () {

			var geometry = this.geometry;
			var m, ml, name;

			if ( geometry.isBufferGeometry ) {

				var morphAttributes = geometry.morphAttributes;
				var keys = Object.keys( morphAttributes );

				if ( keys.length > 0 ) {

					var morphAttribute = morphAttributes[ keys[ 0 ] ];

					if ( morphAttribute !== undefined ) {

						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

							name = morphAttribute[ m ].name || String( m );

							this.morphTargetInfluences.push( 0 );
							this.morphTargetDictionary[ name ] = m;

						}

					}

				}

			} else {

				var morphTargets = geometry.morphTargets;

				if ( morphTargets !== undefined && morphTargets.length > 0 ) {

					console.error( 'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

				}

			}

		},

		raycast: ( function () {

			var inverseMatrix = new Matrix4();
			var ray = new Ray();
			var sphere = new Sphere();

			var vA = new Vector3();
			var vB = new Vector3();
			var vC = new Vector3();

			var tempA = new Vector3();
			var tempB = new Vector3();
			var tempC = new Vector3();

			var morphA = new Vector3();
			var morphB = new Vector3();
			var morphC = new Vector3();

			var uvA = new Vector2();
			var uvB = new Vector2();
			var uvC = new Vector2();

			var intersectionPoint = new Vector3();
			var intersectionPointWorld = new Vector3();

			function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

				var intersect;

				if ( material.side === BackSide ) {

					intersect = ray.intersectTriangle( pC, pB, pA, true, point );

				} else {

					intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

				}

				if ( intersect === null ) return null;

				intersectionPointWorld.copy( point );
				intersectionPointWorld.applyMatrix4( object.matrixWorld );

				var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

				if ( distance < raycaster.near || distance > raycaster.far ) return null;

				return {
					distance: distance,
					point: intersectionPointWorld.clone(),
					object: object
				};

			}

			function checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, uv, a, b, c ) {

				vA.fromBufferAttribute( position, a );
				vB.fromBufferAttribute( position, b );
				vC.fromBufferAttribute( position, c );

				var morphInfluences = object.morphTargetInfluences;

				if ( material.morphTargets && morphPosition && morphInfluences ) {

					morphA.set( 0, 0, 0 );
					morphB.set( 0, 0, 0 );
					morphC.set( 0, 0, 0 );

					for ( var i = 0, il = morphPosition.length; i < il; i ++ ) {

						var influence = morphInfluences[ i ];
						var morphAttribute = morphPosition[ i ];

						if ( influence === 0 ) continue;

						tempA.fromBufferAttribute( morphAttribute, a );
						tempB.fromBufferAttribute( morphAttribute, b );
						tempC.fromBufferAttribute( morphAttribute, c );

						morphA.addScaledVector( tempA.sub( vA ), influence );
						morphB.addScaledVector( tempB.sub( vB ), influence );
						morphC.addScaledVector( tempC.sub( vC ), influence );

					}

					vA.add( morphA );
					vB.add( morphB );
					vC.add( morphC );

				}

				var intersection = checkIntersection( object, material, raycaster, ray, vA, vB, vC, intersectionPoint );

				if ( intersection ) {

					if ( uv ) {

						uvA.fromBufferAttribute( uv, a );
						uvB.fromBufferAttribute( uv, b );
						uvC.fromBufferAttribute( uv, c );

						intersection.uv = Triangle.getUV( intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2() );

					}

					var face = new Face3( a, b, c );
					Triangle.getNormal( vA, vB, vC, face.normal );

					intersection.face = face;

				}

				return intersection;

			}

			return function raycast( raycaster, intersects ) {

				var geometry = this.geometry;
				var material = this.material;
				var matrixWorld = this.matrixWorld;

				if ( material === undefined ) return;

				// Checking boundingSphere distance to ray

				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( matrixWorld );

				if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

				//

				inverseMatrix.getInverse( matrixWorld );
				ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

				// Check boundingBox before continuing

				if ( geometry.boundingBox !== null ) {

					if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;

				}

				var intersection;

				if ( geometry.isBufferGeometry ) {

					var a, b, c;
					var index = geometry.index;
					var position = geometry.attributes.position;
					var morphPosition = geometry.morphAttributes.position;
					var uv = geometry.attributes.uv;
					var groups = geometry.groups;
					var drawRange = geometry.drawRange;
					var i, j, il, jl;
					var group, groupMaterial;
					var start, end;

					if ( index !== null ) {

						// indexed buffer geometry

						if ( Array.isArray( material ) ) {

							for ( i = 0, il = groups.length; i < il; i ++ ) {

								group = groups[ i ];
								groupMaterial = material[ group.materialIndex ];

								start = Math.max( group.start, drawRange.start );
								end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

								for ( j = start, jl = end; j < jl; j += 3 ) {

									a = index.getX( j );
									b = index.getX( j + 1 );
									c = index.getX( j + 2 );

									intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, ray, position, morphPosition, uv, a, b, c );

									if ( intersection ) {

										intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
										intersection.face.materialIndex = group.materialIndex;
										intersects.push( intersection );

									}

								}

							}

						} else {

							start = Math.max( 0, drawRange.start );
							end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

							for ( i = start, il = end; i < il; i += 3 ) {

								a = index.getX( i );
								b = index.getX( i + 1 );
								c = index.getX( i + 2 );

								intersection = checkBufferGeometryIntersection( this, material, raycaster, ray, position, morphPosition, uv, a, b, c );

								if ( intersection ) {

									intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
									intersects.push( intersection );

								}

							}

						}

					} else if ( position !== undefined ) {

						// non-indexed buffer geometry

						if ( Array.isArray( material ) ) {

							for ( i = 0, il = groups.length; i < il; i ++ ) {

								group = groups[ i ];
								groupMaterial = material[ group.materialIndex ];

								start = Math.max( group.start, drawRange.start );
								end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

								for ( j = start, jl = end; j < jl; j += 3 ) {

									a = j;
									b = j + 1;
									c = j + 2;

									intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, ray, position, morphPosition, uv, a, b, c );

									if ( intersection ) {

										intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
										intersection.face.materialIndex = group.materialIndex;
										intersects.push( intersection );

									}

								}

							}

						} else {

							start = Math.max( 0, drawRange.start );
							end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

							for ( i = start, il = end; i < il; i += 3 ) {

								a = i;
								b = i + 1;
								c = i + 2;

								intersection = checkBufferGeometryIntersection( this, material, raycaster, ray, position, morphPosition, uv, a, b, c );

								if ( intersection ) {

									intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
									intersects.push( intersection );

								}

							}

						}

					}

				} else if ( geometry.isGeometry ) {

					var fvA, fvB, fvC;
					var isMultiMaterial = Array.isArray( material );

					var vertices = geometry.vertices;
					var faces = geometry.faces;
					var uvs;

					var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
					if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

					for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

						var face = faces[ f ];
						var faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;

						if ( faceMaterial === undefined ) continue;

						fvA = vertices[ face.a ];
						fvB = vertices[ face.b ];
						fvC = vertices[ face.c ];

						intersection = checkIntersection( this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint );

						if ( intersection ) {

							if ( uvs && uvs[ f ] ) {

								var uvs_f = uvs[ f ];
								uvA.copy( uvs_f[ 0 ] );
								uvB.copy( uvs_f[ 1 ] );
								uvC.copy( uvs_f[ 2 ] );

								intersection.uv = Triangle.getUV( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC, new Vector2() );

							}

							intersection.face = face;
							intersection.faceIndex = f;
							intersects.push( intersection );

						}

					}

				}

			};

		}() ),

		clone: function () {

			return new this.constructor( this.geometry, this.material ).copy( this );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLBackground( renderer, state, objects, premultipliedAlpha ) {

		var clearColor = new Color( 0x000000 );
		var clearAlpha = 0;

		var planeMesh;
		var boxMesh;
		// Store the current background texture and its `version`
		// so we can recompile the material accordingly.
		var currentBackground = null;
		var currentBackgroundVersion = 0;

		function render( renderList, scene, camera, forceClear ) {

			var background = scene.background;

			// Ignore background in AR
			// TODO: Reconsider this.

			var vr = renderer.vr;
			var session = vr.getSession && vr.getSession();

			if ( session && session.environmentBlendMode === 'additive' ) {

				background = null;

			}

			if ( background === null ) {

				setClear( clearColor, clearAlpha );
				currentBackground = null;
				currentBackgroundVersion = 0;

			} else if ( background && background.isColor ) {

				setClear( background, 1 );
				forceClear = true;
				currentBackground = null;
				currentBackgroundVersion = 0;

			}

			if ( renderer.autoClear || forceClear ) {

				renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

			}

			if ( background && ( background.isCubeTexture || background.isWebGLRenderTargetCube ) ) {

				if ( boxMesh === undefined ) {

					boxMesh = new Mesh(
						new BoxBufferGeometry( 1, 1, 1 ),
						new ShaderMaterial( {
							type: 'BackgroundCubeMaterial',
							uniforms: cloneUniforms( ShaderLib.cube.uniforms ),
							vertexShader: ShaderLib.cube.vertexShader,
							fragmentShader: ShaderLib.cube.fragmentShader,
							side: BackSide,
							depthTest: false,
							depthWrite: false,
							fog: false
						} )
					);

					boxMesh.geometry.removeAttribute( 'normal' );
					boxMesh.geometry.removeAttribute( 'uv' );

					boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

						this.matrixWorld.copyPosition( camera.matrixWorld );

					};

					// enable code injection for non-built-in material
					Object.defineProperty( boxMesh.material, 'map', {

						get: function () {

							return this.uniforms.tCube.value;

						}

					} );

					objects.update( boxMesh );

				}

				var texture = background.isWebGLRenderTargetCube ? background.texture : background;
				boxMesh.material.uniforms.tCube.value = texture;
				boxMesh.material.uniforms.tFlip.value = ( background.isWebGLRenderTargetCube ) ? 1 : - 1;

				if ( currentBackground !== background ||
				     currentBackgroundVersion !== texture.version ) {

					boxMesh.material.needsUpdate = true;

					currentBackground = background;
					currentBackgroundVersion = texture.version;

				}

				// push to the pre-sorted opaque render list
				renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

			} else if ( background && background.isTexture ) {

				if ( planeMesh === undefined ) {

					planeMesh = new Mesh(
						new PlaneBufferGeometry( 2, 2 ),
						new ShaderMaterial( {
							type: 'BackgroundMaterial',
							uniforms: cloneUniforms( ShaderLib.background.uniforms ),
							vertexShader: ShaderLib.background.vertexShader,
							fragmentShader: ShaderLib.background.fragmentShader,
							side: FrontSide,
							depthTest: false,
							depthWrite: false,
							fog: false
						} )
					);

					planeMesh.geometry.removeAttribute( 'normal' );

					// enable code injection for non-built-in material
					Object.defineProperty( planeMesh.material, 'map', {

						get: function () {

							return this.uniforms.t2D.value;

						}

					} );

					objects.update( planeMesh );

				}

				planeMesh.material.uniforms.t2D.value = background;

				if ( background.matrixAutoUpdate === true ) {

					background.updateMatrix();

				}

				planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

				if ( currentBackground !== background ||
					   currentBackgroundVersion !== background.version ) {

					planeMesh.material.needsUpdate = true;

					currentBackground = background;
					currentBackgroundVersion = background.version;

				}


				// push to the pre-sorted opaque render list
				renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

			}

		}

		function setClear( color, alpha ) {

			state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );

		}

		return {

			getClearColor: function () {

				return clearColor;

			},
			setClearColor: function ( color, alpha ) {

				clearColor.set( color );
				clearAlpha = alpha !== undefined ? alpha : 1;
				setClear( clearColor, clearAlpha );

			},
			getClearAlpha: function () {

				return clearAlpha;

			},
			setClearAlpha: function ( alpha ) {

				clearAlpha = alpha;
				setClear( clearColor, clearAlpha );

			},
			render: render

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLBufferRenderer( gl, extensions, info, capabilities ) {

		var mode;

		function setMode( value ) {

			mode = value;

		}

		function render( start, count ) {

			gl.drawArrays( mode, start, count );

			info.update( count, mode );

		}

		function renderInstances( geometry, start, count ) {

			var extension;

			if ( capabilities.isWebGL2 ) {

				extension = gl;

			} else {

				extension = extensions.get( 'ANGLE_instanced_arrays' );

				if ( extension === null ) {

					console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

			}

			extension[ capabilities.isWebGL2 ? 'drawArraysInstanced' : 'drawArraysInstancedANGLE' ]( mode, start, count, geometry.maxInstancedCount );

			info.update( count, mode, geometry.maxInstancedCount );

		}

		//

		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLCapabilities( gl, extensions, parameters ) {

		var maxAnisotropy;

		function getMaxAnisotropy() {

			if ( maxAnisotropy !== undefined ) return maxAnisotropy;

			var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( extension !== null ) {

				maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

			} else {

				maxAnisotropy = 0;

			}

			return maxAnisotropy;

		}

		function getMaxPrecision( precision ) {

			if ( precision === 'highp' ) {

				if ( gl.getShaderPrecisionFormat( 35633, 36338 ).precision > 0 &&
				     gl.getShaderPrecisionFormat( 35632, 36338 ).precision > 0 ) {

					return 'highp';

				}

				precision = 'mediump';

			}

			if ( precision === 'mediump' ) {

				if ( gl.getShaderPrecisionFormat( 35633, 36337 ).precision > 0 &&
				     gl.getShaderPrecisionFormat( 35632, 36337 ).precision > 0 ) {

					return 'mediump';

				}

			}

			return 'lowp';

		}

		var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;

		var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
		var maxPrecision = getMaxPrecision( precision );

		if ( maxPrecision !== precision ) {

			console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
			precision = maxPrecision;

		}

		var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

		var maxTextures = gl.getParameter( 34930 );
		var maxVertexTextures = gl.getParameter( 35660 );
		var maxTextureSize = gl.getParameter( 3379 );
		var maxCubemapSize = gl.getParameter( 34076 );

		var maxAttributes = gl.getParameter( 34921 );
		var maxVertexUniforms = gl.getParameter( 36347 );
		var maxVaryings = gl.getParameter( 36348 );
		var maxFragmentUniforms = gl.getParameter( 36349 );

		var vertexTextures = maxVertexTextures > 0;
		var floatFragmentTextures = isWebGL2 || !! extensions.get( 'OES_texture_float' );
		var floatVertexTextures = vertexTextures && floatFragmentTextures;

		var maxSamples = isWebGL2 ? gl.getParameter( 36183 ) : 0;

		return {

			isWebGL2: isWebGL2,

			getMaxAnisotropy: getMaxAnisotropy,
			getMaxPrecision: getMaxPrecision,

			precision: precision,
			logarithmicDepthBuffer: logarithmicDepthBuffer,

			maxTextures: maxTextures,
			maxVertexTextures: maxVertexTextures,
			maxTextureSize: maxTextureSize,
			maxCubemapSize: maxCubemapSize,

			maxAttributes: maxAttributes,
			maxVertexUniforms: maxVertexUniforms,
			maxVaryings: maxVaryings,
			maxFragmentUniforms: maxFragmentUniforms,

			vertexTextures: vertexTextures,
			floatFragmentTextures: floatFragmentTextures,
			floatVertexTextures: floatVertexTextures,

			maxSamples: maxSamples

		};

	}

	/**
	 * @author tschw
	 */

	function WebGLClipping() {

		var scope = this,

			globalState = null,
			numGlobalPlanes = 0,
			localClippingEnabled = false,
			renderingShadows = false,

			plane = new Plane(),
			viewNormalMatrix = new Matrix3(),

			uniform = { value: null, needsUpdate: false };

		this.uniform = uniform;
		this.numPlanes = 0;
		this.numIntersection = 0;

		this.init = function ( planes, enableLocalClipping, camera ) {

			var enabled =
				planes.length !== 0 ||
				enableLocalClipping ||
				// enable state of previous frame - the clipping code has to
				// run another frame in order to reset the state:
				numGlobalPlanes !== 0 ||
				localClippingEnabled;

			localClippingEnabled = enableLocalClipping;

			globalState = projectPlanes( planes, camera, 0 );
			numGlobalPlanes = planes.length;

			return enabled;

		};

		this.beginShadows = function () {

			renderingShadows = true;
			projectPlanes( null );

		};

		this.endShadows = function () {

			renderingShadows = false;
			resetGlobalState();

		};

		this.setState = function ( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {

			if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

				// there's no local clipping

				if ( renderingShadows ) {

					// there's no global clipping

					projectPlanes( null );

				} else {

					resetGlobalState();

				}

			} else {

				var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
					lGlobal = nGlobal * 4,

					dstArray = cache.clippingState || null;

				uniform.value = dstArray; // ensure unique state

				dstArray = projectPlanes( planes, camera, lGlobal, fromCache );

				for ( var i = 0; i !== lGlobal; ++ i ) {

					dstArray[ i ] = globalState[ i ];

				}

				cache.clippingState = dstArray;
				this.numIntersection = clipIntersection ? this.numPlanes : 0;
				this.numPlanes += nGlobal;

			}


		};

		function resetGlobalState() {

			if ( uniform.value !== globalState ) {

				uniform.value = globalState;
				uniform.needsUpdate = numGlobalPlanes > 0;

			}

			scope.numPlanes = numGlobalPlanes;
			scope.numIntersection = 0;

		}

		function projectPlanes( planes, camera, dstOffset, skipTransform ) {

			var nPlanes = planes !== null ? planes.length : 0,
				dstArray = null;

			if ( nPlanes !== 0 ) {

				dstArray = uniform.value;

				if ( skipTransform !== true || dstArray === null ) {

					var flatSize = dstOffset + nPlanes * 4,
						viewMatrix = camera.matrixWorldInverse;

					viewNormalMatrix.getNormalMatrix( viewMatrix );

					if ( dstArray === null || dstArray.length < flatSize ) {

						dstArray = new Float32Array( flatSize );

					}

					for ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

						plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

						plane.normal.toArray( dstArray, i4 );
						dstArray[ i4 + 3 ] = plane.constant;

					}

				}

				uniform.value = dstArray;
				uniform.needsUpdate = true;

			}

			scope.numPlanes = nPlanes;

			return dstArray;

		}

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLExtensions( gl ) {

		var extensions = {};

		return {

			get: function ( name ) {

				if ( extensions[ name ] !== undefined ) {

					return extensions[ name ];

				}

				var extension;

				switch ( name ) {

					case 'WEBGL_depth_texture':
						extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
						break;

					case 'EXT_texture_filter_anisotropic':
						extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
						break;

					case 'WEBGL_compressed_texture_s3tc':
						extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
						break;

					case 'WEBGL_compressed_texture_pvrtc':
						extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
						break;

					default:
						extension = gl.getExtension( name );

				}

				if ( extension === null ) {

					console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

				}

				extensions[ name ] = extension;

				return extension;

			}

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLGeometries( gl, attributes, info ) {

		var geometries = {};
		var wireframeAttributes = {};

		function onGeometryDispose( event ) {

			var geometry = event.target;
			var buffergeometry = geometries[ geometry.id ];

			if ( buffergeometry.index !== null ) {

				attributes.remove( buffergeometry.index );

			}

			for ( var name in buffergeometry.attributes ) {

				attributes.remove( buffergeometry.attributes[ name ] );

			}

			geometry.removeEventListener( 'dispose', onGeometryDispose );

			delete geometries[ geometry.id ];

			var attribute = wireframeAttributes[ buffergeometry.id ];

			if ( attribute ) {

				attributes.remove( attribute );
				delete wireframeAttributes[ buffergeometry.id ];

			}

			//

			info.memory.geometries --;

		}

		function get( object, geometry ) {

			var buffergeometry = geometries[ geometry.id ];

			if ( buffergeometry ) return buffergeometry;

			geometry.addEventListener( 'dispose', onGeometryDispose );

			if ( geometry.isBufferGeometry ) {

				buffergeometry = geometry;

			} else if ( geometry.isGeometry ) {

				if ( geometry._bufferGeometry === undefined ) {

					geometry._bufferGeometry = new BufferGeometry().setFromObject( object );

				}

				buffergeometry = geometry._bufferGeometry;

			}

			geometries[ geometry.id ] = buffergeometry;

			info.memory.geometries ++;

			return buffergeometry;

		}

		function update( geometry ) {

			var index = geometry.index;
			var geometryAttributes = geometry.attributes;

			if ( index !== null ) {

				attributes.update( index, 34963 );

			}

			for ( var name in geometryAttributes ) {

				attributes.update( geometryAttributes[ name ], 34962 );

			}

			// morph targets

			var morphAttributes = geometry.morphAttributes;

			for ( var name in morphAttributes ) {

				var array = morphAttributes[ name ];

				for ( var i = 0, l = array.length; i < l; i ++ ) {

					attributes.update( array[ i ], 34962 );

				}

			}

		}

		function getWireframeAttribute( geometry ) {

			var attribute = wireframeAttributes[ geometry.id ];

			if ( attribute ) return attribute;

			var indices = [];

			var geometryIndex = geometry.index;
			var geometryAttributes = geometry.attributes;

			// console.time( 'wireframe' );

			if ( geometryIndex !== null ) {

				var array = geometryIndex.array;

				for ( var i = 0, l = array.length; i < l; i += 3 ) {

					var a = array[ i + 0 ];
					var b = array[ i + 1 ];
					var c = array[ i + 2 ];

					indices.push( a, b, b, c, c, a );

				}

			} else {

				var array = geometryAttributes.position.array;

				for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

					var a = i + 0;
					var b = i + 1;
					var c = i + 2;

					indices.push( a, b, b, c, c, a );

				}

			}

			// console.timeEnd( 'wireframe' );

			attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );

			attributes.update( attribute, 34963 );

			wireframeAttributes[ geometry.id ] = attribute;

			return attribute;

		}

		return {

			get: get,
			update: update,

			getWireframeAttribute: getWireframeAttribute

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {

		var mode;

		function setMode( value ) {

			mode = value;

		}

		var type, bytesPerElement;

		function setIndex( value ) {

			type = value.type;
			bytesPerElement = value.bytesPerElement;

		}

		function render( start, count ) {

			gl.drawElements( mode, count, type, start * bytesPerElement );

			info.update( count, mode );

		}

		function renderInstances( geometry, start, count ) {

			var extension;

			if ( capabilities.isWebGL2 ) {

				extension = gl;

			} else {

				var extension = extensions.get( 'ANGLE_instanced_arrays' );

				if ( extension === null ) {

					console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

			}

			extension[ capabilities.isWebGL2 ? 'drawElementsInstanced' : 'drawElementsInstancedANGLE' ]( mode, count, type, start * bytesPerElement, geometry.maxInstancedCount );

			info.update( count, mode, geometry.maxInstancedCount );

		}

		//

		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;

	}

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function WebGLInfo( gl ) {

		var memory = {
			geometries: 0,
			textures: 0
		};

		var render = {
			frame: 0,
			calls: 0,
			triangles: 0,
			points: 0,
			lines: 0
		};

		function update( count, mode, instanceCount ) {

			instanceCount = instanceCount || 1;

			render.calls ++;

			switch ( mode ) {

				case 4:
					render.triangles += instanceCount * ( count / 3 );
					break;

				case 5:
				case 6:
					render.triangles += instanceCount * ( count - 2 );
					break;

				case 1:
					render.lines += instanceCount * ( count / 2 );
					break;

				case 3:
					render.lines += instanceCount * ( count - 1 );
					break;

				case 2:
					render.lines += instanceCount * count;
					break;

				case 0:
					render.points += instanceCount * count;
					break;

				default:
					console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
					break;

			}

		}

		function reset() {

			render.frame ++;
			render.calls = 0;
			render.triangles = 0;
			render.points = 0;
			render.lines = 0;

		}

		return {
			memory: memory,
			render: render,
			programs: null,
			autoReset: true,
			reset: reset,
			update: update
		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function absNumericalSort( a, b ) {

		return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

	}

	function WebGLMorphtargets( gl ) {

		var influencesList = {};
		var morphInfluences = new Float32Array( 8 );

		function update( object, geometry, material, program ) {

			var objectInfluences = object.morphTargetInfluences;

			var length = objectInfluences.length;

			var influences = influencesList[ geometry.id ];

			if ( influences === undefined ) {

				// initialise list

				influences = [];

				for ( var i = 0; i < length; i ++ ) {

					influences[ i ] = [ i, 0 ];

				}

				influencesList[ geometry.id ] = influences;

			}

			var morphTargets = material.morphTargets && geometry.morphAttributes.position;
			var morphNormals = material.morphNormals && geometry.morphAttributes.normal;

			// Remove current morphAttributes

			for ( var i = 0; i < length; i ++ ) {

				var influence = influences[ i ];

				if ( influence[ 1 ] !== 0 ) {

					if ( morphTargets ) geometry.removeAttribute( 'morphTarget' + i );
					if ( morphNormals ) geometry.removeAttribute( 'morphNormal' + i );

				}

			}

			// Collect influences

			for ( var i = 0; i < length; i ++ ) {

				var influence = influences[ i ];

				influence[ 0 ] = i;
				influence[ 1 ] = objectInfluences[ i ];

			}

			influences.sort( absNumericalSort );

			// Add morphAttributes

			for ( var i = 0; i < 8; i ++ ) {

				var influence = influences[ i ];

				if ( influence ) {

					var index = influence[ 0 ];
					var value = influence[ 1 ];

					if ( value ) {

						if ( morphTargets ) geometry.addAttribute( 'morphTarget' + i, morphTargets[ index ] );
						if ( morphNormals ) geometry.addAttribute( 'morphNormal' + i, morphNormals[ index ] );

						morphInfluences[ i ] = value;
						continue;

					}

				}

				morphInfluences[ i ] = 0;

			}

			program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

		}

		return {

			update: update

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLObjects( geometries, info ) {

		var updateList = {};

		function update( object ) {

			var frame = info.render.frame;

			var geometry = object.geometry;
			var buffergeometry = geometries.get( object, geometry );

			// Update once per frame

			if ( updateList[ buffergeometry.id ] !== frame ) {

				if ( geometry.isGeometry ) {

					buffergeometry.updateFromObject( object );

				}

				geometries.update( buffergeometry );

				updateList[ buffergeometry.id ] = frame;

			}

			return buffergeometry;

		}

		function dispose() {

			updateList = {};

		}

		return {

			update: update,
			dispose: dispose

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

		images = images !== undefined ? images : [];
		mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
		format = format !== undefined ? format : RGBFormat;

		Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.flipY = false;

	}

	CubeTexture.prototype = Object.create( Texture.prototype );
	CubeTexture.prototype.constructor = CubeTexture;

	CubeTexture.prototype.isCubeTexture = true;

	Object.defineProperty( CubeTexture.prototype, 'images', {

		get: function () {

			return this.image;

		},

		set: function ( value ) {

			this.image = value;

		}

	} );

	/**
	 * @author Takahiro https://github.com/takahirox
	 */

	function DataTexture2DArray( data, width, height, depth ) {

		Texture.call( this, null );

		this.image = { data: data, width: width, height: height, depth: depth };

		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;

		this.wrapR = ClampToEdgeWrapping;

		this.generateMipmaps = false;
		this.flipY = false;

	}

	DataTexture2DArray.prototype = Object.create( Texture.prototype );
	DataTexture2DArray.prototype.constructor = DataTexture2DArray;
	DataTexture2DArray.prototype.isDataTexture2DArray = true;

	/**
	 * @author Artur Trzesiok
	 */

	function DataTexture3D( data, width, height, depth ) {

		// We're going to add .setXXX() methods for setting properties later.
		// Users can still set in DataTexture3D directly.
		//
		//	var texture = new THREE.DataTexture3D( data, width, height, depth );
		// 	texture.anisotropy = 16;
		//
		// See #14839

		Texture.call( this, null );

		this.image = { data: data, width: width, height: height, depth: depth };

		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;

		this.wrapR = ClampToEdgeWrapping;

		this.generateMipmaps = false;
		this.flipY = false;

	}

	DataTexture3D.prototype = Object.create( Texture.prototype );
	DataTexture3D.prototype.constructor = DataTexture3D;
	DataTexture3D.prototype.isDataTexture3D = true;

	/**
	 * @author tschw
	 * @author Mugen87 / https://github.com/Mugen87
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [textures] )
	 *
	 * 		uploads a uniform value(s)
	 *  	the 'textures' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (textures factorizations):
	 *
	 * .upload( gl, seq, values, textures )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (textures factorizations):
	 *
	 * .setValue( gl, name, value, textures )
	 *
	 * 		sets uniform with  name 'name' to 'value'
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 */

	var emptyTexture = new Texture();
	var emptyTexture2dArray = new DataTexture2DArray();
	var emptyTexture3d = new DataTexture3D();
	var emptyCubeTexture = new CubeTexture();

	// --- Utilities ---

	// Array Caches (provide typed arrays for temporary by size)

	var arrayCacheF32 = [];
	var arrayCacheI32 = [];

	// Float32Array caches used for uploading Matrix uniforms

	var mat4array = new Float32Array( 16 );
	var mat3array = new Float32Array( 9 );
	var mat2array = new Float32Array( 4 );

	// Flattening for arrays of vectors and matrices

	function flatten( array, nBlocks, blockSize ) {

		var firstElem = array[ 0 ];

		if ( firstElem <= 0 || firstElem > 0 ) return array;
		// unoptimized: ! isNaN( firstElem )
		// see http://jacksondunstan.com/articles/983

		var n = nBlocks * blockSize,
			r = arrayCacheF32[ n ];

		if ( r === undefined ) {

			r = new Float32Array( n );
			arrayCacheF32[ n ] = r;

		}

		if ( nBlocks !== 0 ) {

			firstElem.toArray( r, 0 );

			for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {

				offset += blockSize;
				array[ i ].toArray( r, offset );

			}

		}

		return r;

	}

	function arraysEqual( a, b ) {

		if ( a.length !== b.length ) return false;

		for ( var i = 0, l = a.length; i < l; i ++ ) {

			if ( a[ i ] !== b[ i ] ) return false;

		}

		return true;

	}

	function copyArray( a, b ) {

		for ( var i = 0, l = b.length; i < l; i ++ ) {

			a[ i ] = b[ i ];

		}

	}

	// Texture unit allocation

	function allocTexUnits( textures, n ) {

		var r = arrayCacheI32[ n ];

		if ( r === undefined ) {

			r = new Int32Array( n );
			arrayCacheI32[ n ] = r;

		}

		for ( var i = 0; i !== n; ++ i )
			r[ i ] = textures.allocateTextureUnit();

		return r;

	}

	// --- Setters ---

	// Note: Defining these methods externally, because they come in a bunch
	// and this way their names minify.

	// Single scalar

	function setValue1f( gl, v ) {

		var cache = this.cache;

		if ( cache[ 0 ] === v ) return;

		gl.uniform1f( this.addr, v );

		cache[ 0 ] = v;

	}

	function setValue1i( gl, v ) {

		var cache = this.cache;

		if ( cache[ 0 ] === v ) return;

		gl.uniform1i( this.addr, v );

		cache[ 0 ] = v;

	}

	// Single float vector (from flat array or THREE.VectorN)

	function setValue2fv( gl, v ) {

		var cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

				gl.uniform2f( this.addr, v.x, v.y );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform2fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValue3fv( gl, v ) {

		var cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

				gl.uniform3f( this.addr, v.x, v.y, v.z );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;

			}

		} else if ( v.r !== undefined ) {

			if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

				gl.uniform3f( this.addr, v.r, v.g, v.b );

				cache[ 0 ] = v.r;
				cache[ 1 ] = v.g;
				cache[ 2 ] = v.b;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform3fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValue4fv( gl, v ) {

		var cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

				gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;
				cache[ 3 ] = v.w;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform4fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	// Single matrix (from flat array or MatrixN)

	function setValue2fm( gl, v ) {

		var cache = this.cache;
		var elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix2fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat2array.set( elements );

			gl.uniformMatrix2fv( this.addr, false, mat2array );

			copyArray( cache, elements );

		}

	}

	function setValue3fm( gl, v ) {

		var cache = this.cache;
		var elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix3fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat3array.set( elements );

			gl.uniformMatrix3fv( this.addr, false, mat3array );

			copyArray( cache, elements );

		}

	}

	function setValue4fm( gl, v ) {

		var cache = this.cache;
		var elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix4fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat4array.set( elements );

			gl.uniformMatrix4fv( this.addr, false, mat4array );

			copyArray( cache, elements );

		}

	}

	// Single texture (2D / Cube)

	function setValueT1( gl, v, textures ) {

		var cache = this.cache;
		var unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.safeSetTexture2D( v || emptyTexture, unit );

	}

	function setValueT2DArray1( gl, v, textures ) {

		var cache = this.cache;
		var unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.setTexture2DArray( v || emptyTexture2dArray, unit );

	}

	function setValueT3D1( gl, v, textures ) {

		var cache = this.cache;
		var unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.setTexture3D( v || emptyTexture3d, unit );

	}

	function setValueT6( gl, v, textures ) {

		var cache = this.cache;
		var unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.safeSetTextureCube( v || emptyCubeTexture, unit );

	}

	// Integer / Boolean vectors or arrays thereof (always flat arrays)

	function setValue2iv( gl, v ) {

		var cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform2iv( this.addr, v );

		copyArray( cache, v );

	}

	function setValue3iv( gl, v ) {

		var cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform3iv( this.addr, v );

		copyArray( cache, v );

	}

	function setValue4iv( gl, v ) {

		var cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform4iv( this.addr, v );

		copyArray( cache, v );

	}

	// Helper to pick the right setter for the singular case

	function getSingularSetter( type ) {

		switch ( type ) {

			case 0x1406: return setValue1f; // FLOAT
			case 0x8b50: return setValue2fv; // _VEC2
			case 0x8b51: return setValue3fv; // _VEC3
			case 0x8b52: return setValue4fv; // _VEC4

			case 0x8b5a: return setValue2fm; // _MAT2
			case 0x8b5b: return setValue3fm; // _MAT3
			case 0x8b5c: return setValue4fm; // _MAT4

			case 0x8b5e: case 0x8d66: return setValueT1; // SAMPLER_2D, SAMPLER_EXTERNAL_OES
			case 0x8b5f: return setValueT3D1; // SAMPLER_3D
			case 0x8b60: return setValueT6; // SAMPLER_CUBE
			case 0x8DC1: return setValueT2DArray1; // SAMPLER_2D_ARRAY

			case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
			case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
			case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

		}

	}

	// Array of scalars

	function setValue1fv( gl, v ) {

		var cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform1fv( this.addr, v );

		copyArray( cache, v );

	}
	function setValue1iv( gl, v ) {

		var cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform1iv( this.addr, v );

		copyArray( cache, v );

	}

	// Array of vectors (flat or from THREE classes)

	function setValueV2a( gl, v ) {

		var cache = this.cache;
		var data = flatten( v, this.size, 2 );

		if ( arraysEqual( cache, data ) ) return;

		gl.uniform2fv( this.addr, data );

		this.updateCache( data );

	}

	function setValueV3a( gl, v ) {

		var cache = this.cache;
		var data = flatten( v, this.size, 3 );

		if ( arraysEqual( cache, data ) ) return;

		gl.uniform3fv( this.addr, data );

		this.updateCache( data );

	}

	function setValueV4a( gl, v ) {

		var cache = this.cache;
		var data = flatten( v, this.size, 4 );

		if ( arraysEqual( cache, data ) ) return;

		gl.uniform4fv( this.addr, data );

		this.updateCache( data );

	}

	// Array of matrices (flat or from THREE clases)

	function setValueM2a( gl, v ) {

		var cache = this.cache;
		var data = flatten( v, this.size, 4 );

		if ( arraysEqual( cache, data ) ) return;

		gl.uniformMatrix2fv( this.addr, false, data );

		this.updateCache( data );

	}

	function setValueM3a( gl, v ) {

		var cache = this.cache;
		var data = flatten( v, this.size, 9 );

		if ( arraysEqual( cache, data ) ) return;

		gl.uniformMatrix3fv( this.addr, false, data );

		this.updateCache( data );

	}

	function setValueM4a( gl, v ) {

		var cache = this.cache;
		var data = flatten( v, this.size, 16 );

		if ( arraysEqual( cache, data ) ) return;

		gl.uniformMatrix4fv( this.addr, false, data );

		this.updateCache( data );

	}

	// Array of textures (2D / Cube)

	function setValueT1a( gl, v, textures ) {

		var cache = this.cache;
		var n = v.length;

		var units = allocTexUnits( textures, n );

		if ( arraysEqual( cache, units ) === false ) {

			gl.uniform1iv( this.addr, units );
			copyArray( cache, units );

		}

		for ( var i = 0; i !== n; ++ i ) {

			textures.safeSetTexture2D( v[ i ] || emptyTexture, units[ i ] );

		}

	}

	function setValueT6a( gl, v, textures ) {

		var cache = this.cache;
		var n = v.length;

		var units = allocTexUnits( textures, n );

		if ( arraysEqual( cache, units ) === false ) {

			gl.uniform1iv( this.addr, units );
			copyArray( cache, units );

		}

		for ( var i = 0; i !== n; ++ i ) {

			textures.safeSetTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

		}

	}

	// Helper to pick the right setter for a pure (bottom-level) array

	function getPureArraySetter( type ) {

		switch ( type ) {

			case 0x1406: return setValue1fv; // FLOAT
			case 0x8b50: return setValueV2a; // _VEC2
			case 0x8b51: return setValueV3a; // _VEC3
			case 0x8b52: return setValueV4a; // _VEC4

			case 0x8b5a: return setValueM2a; // _MAT2
			case 0x8b5b: return setValueM3a; // _MAT3
			case 0x8b5c: return setValueM4a; // _MAT4

			case 0x8b5e: return setValueT1a; // SAMPLER_2D
			case 0x8b60: return setValueT6a; // SAMPLER_CUBE

			case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
			case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
			case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

		}

	}

	// --- Uniform Classes ---

	function SingleUniform( id, activeInfo, addr ) {

		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.setValue = getSingularSetter( activeInfo.type );

		// this.path = activeInfo.name; // DEBUG

	}

	function PureArrayUniform( id, activeInfo, addr ) {

		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.size = activeInfo.size;
		this.setValue = getPureArraySetter( activeInfo.type );

		// this.path = activeInfo.name; // DEBUG

	}

	PureArrayUniform.prototype.updateCache = function ( data ) {

		var cache = this.cache;

		if ( data instanceof Float32Array && cache.length !== data.length ) {

			this.cache = new Float32Array( data.length );

		}

		copyArray( cache, data );

	};

	function StructuredUniform( id ) {

		this.id = id;

		this.seq = [];
		this.map = {};

	}

	StructuredUniform.prototype.setValue = function ( gl, value, textures ) {

		var seq = this.seq;

		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

			var u = seq[ i ];
			u.setValue( gl, value[ u.id ], textures );

		}

	};

	// --- Top-level ---

	// Parser - builds up the property tree from the path strings

	var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

	// extracts
	// 	- the identifier (member name or array index)
	//  - followed by an optional right bracket (found when array index)
	//  - followed by an optional left bracket or dot (type of subscript)
	//
	// Note: These portions can be read in a non-overlapping fashion and
	// allow straightforward parsing of the hierarchy that WebGL encodes
	// in the uniform names.

	function addUniform( container, uniformObject ) {

		container.seq.push( uniformObject );
		container.map[ uniformObject.id ] = uniformObject;

	}

	function parseUniform( activeInfo, addr, container ) {

		var path = activeInfo.name,
			pathLength = path.length;

		// reset RegExp object, because of the early exit of a previous run
		RePathPart.lastIndex = 0;

		while ( true ) {

			var match = RePathPart.exec( path ),
				matchEnd = RePathPart.lastIndex,

				id = match[ 1 ],
				idIsIndex = match[ 2 ] === ']',
				subscript = match[ 3 ];

			if ( idIsIndex ) id = id | 0; // convert to integer

			if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

				// bare name or "pure" bottom-level array "[0]" suffix

				addUniform( container, subscript === undefined ?
					new SingleUniform( id, activeInfo, addr ) :
					new PureArrayUniform( id, activeInfo, addr ) );

				break;

			} else {

				// step into inner node / create it in case it doesn't exist

				var map = container.map, next = map[ id ];

				if ( next === undefined ) {

					next = new StructuredUniform( id );
					addUniform( container, next );

				}

				container = next;

			}

		}

	}

	// Root Container

	function WebGLUniforms( gl, program ) {

		this.seq = [];
		this.map = {};

		var n = gl.getProgramParameter( program, 35718 );

		for ( var i = 0; i < n; ++ i ) {

			var info = gl.getActiveUniform( program, i ),
				addr = gl.getUniformLocation( program, info.name );

			parseUniform( info, addr, this );

		}

	}

	WebGLUniforms.prototype.setValue = function ( gl, name, value, textures ) {

		var u = this.map[ name ];

		if ( u !== undefined ) u.setValue( gl, value, textures );

	};

	WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {

		var v = object[ name ];

		if ( v !== undefined ) this.setValue( gl, name, v );

	};


	// Static interface

	WebGLUniforms.upload = function ( gl, seq, values, textures ) {

		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

			var u = seq[ i ],
				v = values[ u.id ];

			if ( v.needsUpdate !== false ) {

				// note: always updating when .needsUpdate is undefined
				u.setValue( gl, v.value, textures );

			}

		}

	};

	WebGLUniforms.seqWithValue = function ( seq, values ) {

		var r = [];

		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

			var u = seq[ i ];
			if ( u.id in values ) r.push( u );

		}

		return r;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function addLineNumbers( string ) {

		var lines = string.split( '\n' );

		for ( var i = 0; i < lines.length; i ++ ) {

			lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

		}

		return lines.join( '\n' );

	}

	function WebGLShader( gl, type, string ) {

		var shader = gl.createShader( type );

		gl.shaderSource( shader, string );
		gl.compileShader( shader );

		if ( gl.getShaderParameter( shader, 35713 ) === false ) {

			console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

		}

		if ( gl.getShaderInfoLog( shader ) !== '' ) {

			console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === 35633 ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

		}

		// --enable-privileged-webgl-extension
		// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		return shader;

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var programIdCount = 0;

	function getEncodingComponents( encoding ) {

		switch ( encoding ) {

			case LinearEncoding:
				return [ 'Linear', '( value )' ];
			case sRGBEncoding:
				return [ 'sRGB', '( value )' ];
			case RGBEEncoding:
				return [ 'RGBE', '( value )' ];
			case RGBM7Encoding:
				return [ 'RGBM', '( value, 7.0 )' ];
			case RGBM16Encoding:
				return [ 'RGBM', '( value, 16.0 )' ];
			case RGBDEncoding:
				return [ 'RGBD', '( value, 256.0 )' ];
			case GammaEncoding:
				return [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];
			default:
				throw new Error( 'unsupported encoding: ' + encoding );

		}

	}

	function getTexelDecodingFunction( functionName, encoding ) {

		var components = getEncodingComponents( encoding );
		return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';

	}

	function getTexelEncodingFunction( functionName, encoding ) {

		var components = getEncodingComponents( encoding );
		return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';

	}

	function getToneMappingFunction( functionName, toneMapping ) {

		var toneMappingName;

		switch ( toneMapping ) {

			case LinearToneMapping:
				toneMappingName = 'Linear';
				break;

			case ReinhardToneMapping:
				toneMappingName = 'Reinhard';
				break;

			case Uncharted2ToneMapping:
				toneMappingName = 'Uncharted2';
				break;

			case CineonToneMapping:
				toneMappingName = 'OptimizedCineon';
				break;

			case ACESFilmicToneMapping:
				toneMappingName = 'ACESFilmic';
				break;

			default:
				throw new Error( 'unsupported toneMapping: ' + toneMapping );

		}

		return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

	}

	function generateExtensions( extensions, parameters, rendererExtensions ) {

		extensions = extensions || {};

		var chunks = [
			( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || ( parameters.normalMap && ! parameters.objectSpaceNormalMap ) || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
			( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
			( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
			( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : ''
		];

		return chunks.filter( filterEmptyLine ).join( '\n' );

	}

	function generateDefines( defines ) {

		var chunks = [];

		for ( var name in defines ) {

			var value = defines[ name ];

			if ( value === false ) continue;

			chunks.push( '#define ' + name + ' ' + value );

		}

		return chunks.join( '\n' );

	}

	function fetchAttributeLocations( gl, program ) {

		var attributes = {};

		var n = gl.getProgramParameter( program, 35721 );

		for ( var i = 0; i < n; i ++ ) {

			var info = gl.getActiveAttrib( program, i );
			var name = info.name;

			// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

			attributes[ name ] = gl.getAttribLocation( program, name );

		}

		return attributes;

	}

	function filterEmptyLine( string ) {

		return string !== '';

	}

	function replaceLightNums( string, parameters ) {

		return string
			.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
			.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
			.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
			.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
			.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );

	}

	function replaceClippingPlaneNums( string, parameters ) {

		return string
			.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
			.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

	}

	function parseIncludes( string ) {

		var pattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

		function replace( match, include ) {

			var replace = ShaderChunk[ include ];

			if ( replace === undefined ) {

				throw new Error( 'Can not resolve #include <' + include + '>' );

			}

			return parseIncludes( replace );

		}

		return string.replace( pattern, replace );

	}

	function unrollLoops( string ) {

		var pattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

		function replace( match, start, end, snippet ) {

			var unroll = '';

			for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {

				unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );

			}

			return unroll;

		}

		return string.replace( pattern, replace );

	}

	function WebGLProgram( renderer, extensions, code, material, shader, parameters, capabilities, textures ) {

		var gl = renderer.context;

		var defines = material.defines;

		var vertexShader = shader.vertexShader;
		var fragmentShader = shader.fragmentShader;

		var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

		if ( parameters.shadowMapType === PCFShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

		} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

		}

		var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
		var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
		var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

		if ( parameters.envMap ) {

			switch ( material.envMap.mapping ) {

				case CubeReflectionMapping:
				case CubeRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
					break;

				case CubeUVReflectionMapping:
				case CubeUVRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
					break;

				case EquirectangularReflectionMapping:
				case EquirectangularRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
					break;

				case SphericalReflectionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
					break;

			}

			switch ( material.envMap.mapping ) {

				case CubeRefractionMapping:
				case EquirectangularRefractionMapping:
					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
					break;

			}

			switch ( material.combine ) {

				case MultiplyOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
					break;

				case MixOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
					break;

				case AddOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
					break;

			}

		}

		var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

		// console.log( 'building new program ' );

		//

		var customExtensions = capabilities.isWebGL2 ? '' : generateExtensions( material.extensions, parameters, extensions );

		var customDefines = generateDefines( defines );

		//

		var program = gl.createProgram();

		var prefixVertex, prefixFragment;

		if ( material.isRawShaderMaterial ) {

			prefixVertex = [

				customDefines

			].filter( filterEmptyLine ).join( '\n' );

			if ( prefixVertex.length > 0 ) {

				prefixVertex += '\n';

			}

			prefixFragment = [

				customExtensions,
				customDefines

			].filter( filterEmptyLine ).join( '\n' );

			if ( prefixFragment.length > 0 ) {

				prefixFragment += '\n';

			}

		} else {

			prefixVertex = [

				'precision ' + parameters.precision + ' float;',
				'precision ' + parameters.precision + ' int;',

				'#define SHADER_NAME ' + shader.name,

				customDefines,

				parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				'#define MAX_BONES ' + parameters.maxBones,
				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
				( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
				parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

				parameters.vertexTangents ? '#define USE_TANGENT' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.skinning ? '#define USE_SKINNING' : '',
				parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

				parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
				parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				parameters.logarithmicDepthBuffer && ( capabilities.isWebGL2 || extensions.get( 'EXT_frag_depth' ) ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				'uniform mat4 modelMatrix;',
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform mat4 viewMatrix;',
				'uniform mat3 normalMatrix;',
				'uniform vec3 cameraPosition;',

				'attribute vec3 position;',
				'attribute vec3 normal;',
				'attribute vec2 uv;',

				'#ifdef USE_TANGENT',

				'	attribute vec4 tangent;',

				'#endif',

				'#ifdef USE_COLOR',

				'	attribute vec3 color;',

				'#endif',

				'#ifdef USE_MORPHTARGETS',

				'	attribute vec3 morphTarget0;',
				'	attribute vec3 morphTarget1;',
				'	attribute vec3 morphTarget2;',
				'	attribute vec3 morphTarget3;',

				'	#ifdef USE_MORPHNORMALS',

				'		attribute vec3 morphNormal0;',
				'		attribute vec3 morphNormal1;',
				'		attribute vec3 morphNormal2;',
				'		attribute vec3 morphNormal3;',

				'	#else',

				'		attribute vec3 morphTarget4;',
				'		attribute vec3 morphTarget5;',
				'		attribute vec3 morphTarget6;',
				'		attribute vec3 morphTarget7;',

				'	#endif',

				'#endif',

				'#ifdef USE_SKINNING',

				'	attribute vec4 skinIndex;',
				'	attribute vec4 skinWeight;',

				'#endif',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

			prefixFragment = [

				customExtensions,

				'precision ' + parameters.precision + ' float;',
				'precision ' + parameters.precision + ' int;',

				'#define SHADER_NAME ' + shader.name,

				customDefines,

				parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + ( parameters.alphaTest % 1 ? '' : '.0' ) : '', // add '.0' if integer

				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
				( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.matcap ? '#define USE_MATCAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapTypeDefine : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.envMap ? '#define ' + envMapBlendingDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

				parameters.vertexTangents ? '#define USE_TANGENT' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',

				parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

				parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				parameters.logarithmicDepthBuffer && ( capabilities.isWebGL2 || extensions.get( 'EXT_frag_depth' ) ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				parameters.envMap && ( capabilities.isWebGL2 || extensions.get( 'EXT_shader_texture_lod' ) ) ? '#define TEXTURE_LOD_EXT' : '',

				'uniform mat4 viewMatrix;',
				'uniform vec3 cameraPosition;',

				( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
				( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
				( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

				parameters.dithering ? '#define DITHERING' : '',

				( parameters.outputEncoding || parameters.mapEncoding || parameters.matcapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ?
					ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
				parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
				parameters.matcapEncoding ? getTexelDecodingFunction( 'matcapTexelToLinear', parameters.matcapEncoding ) : '',
				parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
				parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
				parameters.outputEncoding ? getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ) : '',

				parameters.depthPacking ? '#define DEPTH_PACKING ' + material.depthPacking : '',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

		}

		vertexShader = parseIncludes( vertexShader );
		vertexShader = replaceLightNums( vertexShader, parameters );
		vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

		fragmentShader = parseIncludes( fragmentShader );
		fragmentShader = replaceLightNums( fragmentShader, parameters );
		fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

		vertexShader = unrollLoops( vertexShader );
		fragmentShader = unrollLoops( fragmentShader );

		if ( capabilities.isWebGL2 && ! material.isRawShaderMaterial ) {

			var isGLSL3ShaderMaterial = false;

			var versionRegex = /^\s*#version\s+300\s+es\s*\n/;

			if ( material.isShaderMaterial &&
				vertexShader.match( versionRegex ) !== null &&
				fragmentShader.match( versionRegex ) !== null ) {

				isGLSL3ShaderMaterial = true;

				vertexShader = vertexShader.replace( versionRegex, '' );
				fragmentShader = fragmentShader.replace( versionRegex, '' );

			}

			// GLSL 3.0 conversion
			prefixVertex = [
				'#version 300 es\n',
				'#define attribute in',
				'#define varying out',
				'#define texture2D texture'
			].join( '\n' ) + '\n' + prefixVertex;

			prefixFragment = [
				'#version 300 es\n',
				'#define varying in',
				isGLSL3ShaderMaterial ? '' : 'out highp vec4 pc_fragColor;',
				isGLSL3ShaderMaterial ? '' : '#define gl_FragColor pc_fragColor',
				'#define gl_FragDepthEXT gl_FragDepth',
				'#define texture2D texture',
				'#define textureCube texture',
				'#define texture2DProj textureProj',
				'#define texture2DLodEXT textureLod',
				'#define texture2DProjLodEXT textureProjLod',
				'#define textureCubeLodEXT textureLod',
				'#define texture2DGradEXT textureGrad',
				'#define texture2DProjGradEXT textureProjGrad',
				'#define textureCubeGradEXT textureGrad'
			].join( '\n' ) + '\n' + prefixFragment;

		}

		var vertexGlsl = prefixVertex + vertexShader;
		var fragmentGlsl = prefixFragment + fragmentShader;

		// console.log( '*VERTEX*', vertexGlsl );
		// console.log( '*FRAGMENT*', fragmentGlsl );

		var glVertexShader = WebGLShader( gl, 35633, vertexGlsl );
		var glFragmentShader = WebGLShader( gl, 35632, fragmentGlsl );

		gl.attachShader( program, glVertexShader );
		gl.attachShader( program, glFragmentShader );

		// Force a particular attribute to index 0.

		if ( material.index0AttributeName !== undefined ) {

			gl.bindAttribLocation( program, 0, material.index0AttributeName );

		} else if ( parameters.morphTargets === true ) {

			// programs with morphTargets displace position out of attribute 0
			gl.bindAttribLocation( program, 0, 'position' );

		}

		gl.linkProgram( program );

		var programLog = gl.getProgramInfoLog( program ).trim();
		var vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
		var fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

		var runnable = true;
		var haveDiagnostics = true;

		// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
		// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

		if ( gl.getProgramParameter( program, 35714 ) === false ) {

			runnable = false;

			console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter( program, 35715 ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

		} else if ( programLog !== '' ) {

			console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

		} else if ( vertexLog === '' || fragmentLog === '' ) {

			haveDiagnostics = false;

		}

		if ( haveDiagnostics ) {

			this.diagnostics = {

				runnable: runnable,
				material: material,

				programLog: programLog,

				vertexShader: {

					log: vertexLog,
					prefix: prefixVertex

				},

				fragmentShader: {

					log: fragmentLog,
					prefix: prefixFragment

				}

			};

		}

		// clean up

		gl.deleteShader( glVertexShader );
		gl.deleteShader( glFragmentShader );

		// set up caching for uniform locations

		var cachedUniforms;

		this.getUniforms = function () {

			if ( cachedUniforms === undefined ) {

				cachedUniforms = new WebGLUniforms( gl, program, textures );

			}

			return cachedUniforms;

		};

		// set up caching for attribute locations

		var cachedAttributes;

		this.getAttributes = function () {

			if ( cachedAttributes === undefined ) {

				cachedAttributes = fetchAttributeLocations( gl, program );

			}

			return cachedAttributes;

		};

		// free resource

		this.destroy = function () {

			gl.deleteProgram( program );
			this.program = undefined;

		};

		// DEPRECATED

		Object.defineProperties( this, {

			uniforms: {
				get: function () {

					console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
					return this.getUniforms();

				}
			},

			attributes: {
				get: function () {

					console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
					return this.getAttributes();

				}
			}

		} );


		//

		this.name = shader.name;
		this.id = programIdCount ++;
		this.code = code;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;

		return this;

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLPrograms( renderer, extensions, capabilities, textures ) {

		var programs = [];

		var shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshDistanceMaterial: 'distanceRGBA',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			MeshToonMaterial: 'phong',
			MeshStandardMaterial: 'physical',
			MeshPhysicalMaterial: 'physical',
			MeshMatcapMaterial: 'matcap',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points',
			ShadowMaterial: 'shadow',
			SpriteMaterial: 'sprite'
		};

		var parameterNames = [
			"precision", "supportsVertexTextures", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding",
			"lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "displacementMap", "specularMap",
			"roughnessMap", "metalnessMap", "gradientMap",
			"alphaMap", "combine", "vertexColors", "vertexTangents", "fog", "useFog", "fogExp",
			"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
			"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
			"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
			"numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights",
			"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
			"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"
		];


		function allocateBones( object ) {

			var skeleton = object.skeleton;
			var bones = skeleton.bones;

			if ( capabilities.floatVertexTextures ) {

				return 1024;

			} else {

				// default for when object is not specified
				// ( for example when prebuilding shader to be used with multiple objects )
				//
				//  - leave some extra space for other uniforms
				//  - limit here is ANGLE's 254 max uniform vectors
				//    (up to 54 should be safe)

				var nVertexUniforms = capabilities.maxVertexUniforms;
				var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

				var maxBones = Math.min( nVertexMatrices, bones.length );

				if ( maxBones < bones.length ) {

					console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
					return 0;

				}

				return maxBones;

			}

		}

		function getTextureEncodingFromMap( map, gammaOverrideLinear ) {

			var encoding;

			if ( ! map ) {

				encoding = LinearEncoding;

			} else if ( map.isTexture ) {

				encoding = map.encoding;

			} else if ( map.isWebGLRenderTarget ) {

				console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
				encoding = map.texture.encoding;

			}

			// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
			if ( encoding === LinearEncoding && gammaOverrideLinear ) {

				encoding = GammaEncoding;

			}

			return encoding;

		}

		this.getParameters = function ( material, lights, shadows, fog, nClipPlanes, nClipIntersection, object ) {

			var shaderID = shaderIDs[ material.type ];

			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)

			var maxBones = object.isSkinnedMesh ? allocateBones( object ) : 0;
			var precision = capabilities.precision;

			if ( material.precision !== null ) {

				precision = capabilities.getMaxPrecision( material.precision );

				if ( precision !== material.precision ) {

					console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

				}

			}

			var currentRenderTarget = renderer.getRenderTarget();

			var parameters = {

				shaderID: shaderID,

				precision: precision,
				supportsVertexTextures: capabilities.vertexTextures,
				outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),
				map: !! material.map,
				mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),
				matcap: !! material.matcap,
				matcapEncoding: getTextureEncodingFromMap( material.matcap, renderer.gammaInput ),
				envMap: !! material.envMap,
				envMapMode: material.envMap && material.envMap.mapping,
				envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),
				envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),
				lightMap: !! material.lightMap,
				aoMap: !! material.aoMap,
				emissiveMap: !! material.emissiveMap,
				emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),
				bumpMap: !! material.bumpMap,
				normalMap: !! material.normalMap,
				objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
				displacementMap: !! material.displacementMap,
				roughnessMap: !! material.roughnessMap,
				metalnessMap: !! material.metalnessMap,
				specularMap: !! material.specularMap,
				alphaMap: !! material.alphaMap,

				gradientMap: !! material.gradientMap,

				combine: material.combine,

				vertexTangents: ( material.normalMap && material.vertexTangents ),
				vertexColors: material.vertexColors,

				fog: !! fog,
				useFog: material.fog,
				fogExp: ( fog && fog.isFogExp2 ),

				flatShading: material.flatShading,

				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

				skinning: material.skinning && maxBones > 0,
				maxBones: maxBones,
				useVertexTexture: capabilities.floatVertexTextures,

				morphTargets: material.morphTargets,
				morphNormals: material.morphNormals,
				maxMorphTargets: renderer.maxMorphTargets,
				maxMorphNormals: renderer.maxMorphNormals,

				numDirLights: lights.directional.length,
				numPointLights: lights.point.length,
				numSpotLights: lights.spot.length,
				numRectAreaLights: lights.rectArea.length,
				numHemiLights: lights.hemi.length,

				numClippingPlanes: nClipPlanes,
				numClipIntersection: nClipIntersection,

				dithering: material.dithering,

				shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,
				shadowMapType: renderer.shadowMap.type,

				toneMapping: renderer.toneMapping,
				physicallyCorrectLights: renderer.physicallyCorrectLights,

				premultipliedAlpha: material.premultipliedAlpha,

				alphaTest: material.alphaTest,
				doubleSided: material.side === DoubleSide,
				flipSided: material.side === BackSide,

				depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false

			};

			return parameters;

		};

		this.getProgramCode = function ( material, parameters ) {

			var array = [];

			if ( parameters.shaderID ) {

				array.push( parameters.shaderID );

			} else {

				array.push( material.fragmentShader );
				array.push( material.vertexShader );

			}

			if ( material.defines !== undefined ) {

				for ( var name in material.defines ) {

					array.push( name );
					array.push( material.defines[ name ] );

				}

			}

			for ( var i = 0; i < parameterNames.length; i ++ ) {

				array.push( parameters[ parameterNames[ i ] ] );

			}

			array.push( material.onBeforeCompile.toString() );

			array.push( renderer.gammaOutput );

			array.push( renderer.gammaFactor );

			return array.join();

		};

		this.acquireProgram = function ( material, shader, parameters, code ) {

			var program;

			// Check if code has been already compiled
			for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

				var programInfo = programs[ p ];

				if ( programInfo.code === code ) {

					program = programInfo;
					++ program.usedTimes;

					break;

				}

			}

			if ( program === undefined ) {

				program = new WebGLProgram( renderer, extensions, code, material, shader, parameters, capabilities, textures );
				programs.push( program );

			}

			return program;

		};

		this.releaseProgram = function ( program ) {

			if ( -- program.usedTimes === 0 ) {

				// Remove from unordered set
				var i = programs.indexOf( program );
				programs[ i ] = programs[ programs.length - 1 ];
				programs.pop();

				// Free WebGL resources
				program.destroy();

			}

		};

		// Exposed for resource monitoring & error feedback via renderer.info:
		this.programs = programs;

	}

	/**
	 * @author fordacious / fordacious.github.io
	 */

	function WebGLProperties() {

		var properties = new WeakMap();

		function get( object ) {

			var map = properties.get( object );

			if ( map === undefined ) {

				map = {};
				properties.set( object, map );

			}

			return map;

		}

		function remove( object ) {

			properties.delete( object );

		}

		function update( object, key, value ) {

			properties.get( object )[ key ] = value;

		}

		function dispose() {

			properties = new WeakMap();

		}

		return {
			get: get,
			remove: remove,
			update: update,
			dispose: dispose
		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function painterSortStable( a, b ) {

		if ( a.groupOrder !== b.groupOrder ) {

			return a.groupOrder - b.groupOrder;

		} else if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.program !== b.program ) {

			return a.program.id - b.program.id;

		} else if ( a.material.id !== b.material.id ) {

			return a.material.id - b.material.id;

		} else if ( a.z !== b.z ) {

			return a.z - b.z;

		} else {

			return a.id - b.id;

		}

	}

	function reversePainterSortStable( a, b ) {

		if ( a.groupOrder !== b.groupOrder ) {

			return a.groupOrder - b.groupOrder;

		} else if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return a.id - b.id;

		}

	}


	function WebGLRenderList() {

		var renderItems = [];
		var renderItemsIndex = 0;

		var opaque = [];
		var transparent = [];

		var defaultProgram = { id: - 1 };

		function init() {

			renderItemsIndex = 0;

			opaque.length = 0;
			transparent.length = 0;

		}

		function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

			var renderItem = renderItems[ renderItemsIndex ];

			if ( renderItem === undefined ) {

				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					program: material.program || defaultProgram,
					groupOrder: groupOrder,
					renderOrder: object.renderOrder,
					z: z,
					group: group
				};

				renderItems[ renderItemsIndex ] = renderItem;

			} else {

				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.program = material.program || defaultProgram;
				renderItem.groupOrder = groupOrder;
				renderItem.renderOrder = object.renderOrder;
				renderItem.z = z;
				renderItem.group = group;

			}

			renderItemsIndex ++;

			return renderItem;

		}

		function push( object, geometry, material, groupOrder, z, group ) {

			var renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

			( material.transparent === true ? transparent : opaque ).push( renderItem );

		}

		function unshift( object, geometry, material, groupOrder, z, group ) {

			var renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

			( material.transparent === true ? transparent : opaque ).unshift( renderItem );

		}

		function sort() {

			if ( opaque.length > 1 ) opaque.sort( painterSortStable );
			if ( transparent.length > 1 ) transparent.sort( reversePainterSortStable );

		}

		return {
			opaque: opaque,
			transparent: transparent,

			init: init,
			push: push,
			unshift: unshift,

			sort: sort
		};

	}

	function WebGLRenderLists() {

		var lists = {};

		function onSceneDispose( event ) {

			var scene = event.target;

			scene.removeEventListener( 'dispose', onSceneDispose );

			delete lists[ scene.id ];

		}

		function get( scene, camera ) {

			var cameras = lists[ scene.id ];
			var list;
			if ( cameras === undefined ) {

				list = new WebGLRenderList();
				lists[ scene.id ] = {};
				lists[ scene.id ][ camera.id ] = list;

				scene.addEventListener( 'dispose', onSceneDispose );

			} else {

				list = cameras[ camera.id ];
				if ( list === undefined ) {

					list = new WebGLRenderList();
					cameras[ camera.id ] = list;

				}

			}

			return list;

		}

		function dispose() {

			lists = {};

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function UniformsCache() {

		var lights = {};

		return {

			get: function ( light ) {

				if ( lights[ light.id ] !== undefined ) {

					return lights[ light.id ];

				}

				var uniforms;

				switch ( light.type ) {

					case 'DirectionalLight':
						uniforms = {
							direction: new Vector3(),
							color: new Color(),

							shadow: false,
							shadowBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'SpotLight':
						uniforms = {
							position: new Vector3(),
							direction: new Vector3(),
							color: new Color(),
							distance: 0,
							coneCos: 0,
							penumbraCos: 0,
							decay: 0,

							shadow: false,
							shadowBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'PointLight':
						uniforms = {
							position: new Vector3(),
							color: new Color(),
							distance: 0,
							decay: 0,

							shadow: false,
							shadowBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2(),
							shadowCameraNear: 1,
							shadowCameraFar: 1000
						};
						break;

					case 'HemisphereLight':
						uniforms = {
							direction: new Vector3(),
							skyColor: new Color(),
							groundColor: new Color()
						};
						break;

					case 'RectAreaLight':
						uniforms = {
							color: new Color(),
							position: new Vector3(),
							halfWidth: new Vector3(),
							halfHeight: new Vector3()
							// TODO (abelnation): set RectAreaLight shadow uniforms
						};
						break;

				}

				lights[ light.id ] = uniforms;

				return uniforms;

			}

		};

	}

	var count = 0;

	function WebGLLights() {

		var cache = new UniformsCache();

		var state = {

			id: count ++,

			hash: {
				stateID: - 1,
				directionalLength: - 1,
				pointLength: - 1,
				spotLength: - 1,
				rectAreaLength: - 1,
				hemiLength: - 1,
				shadowsLength: - 1
			},

			ambient: [ 0, 0, 0 ],
			directional: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotShadowMap: [],
			spotShadowMatrix: [],
			rectArea: [],
			point: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: []

		};

		var vector3 = new Vector3();
		var matrix4 = new Matrix4();
		var matrix42 = new Matrix4();

		function setup( lights, shadows, camera ) {

			var r = 0, g = 0, b = 0;

			var directionalLength = 0;
			var pointLength = 0;
			var spotLength = 0;
			var rectAreaLength = 0;
			var hemiLength = 0;

			var viewMatrix = camera.matrixWorldInverse;

			for ( var i = 0, l = lights.length; i < l; i ++ ) {

				var light = lights[ i ];

				var color = light.color;
				var intensity = light.intensity;
				var distance = light.distance;

				var shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

				if ( light.isAmbientLight ) {

					r += color.r * intensity;
					g += color.g * intensity;
					b += color.b * intensity;

				} else if ( light.isDirectionalLight ) {

					var uniforms = cache.get( light );

					uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( vector3 );
					uniforms.direction.transformDirection( viewMatrix );

					uniforms.shadow = light.castShadow;

					if ( light.castShadow ) {

						var shadow = light.shadow;

						uniforms.shadowBias = shadow.bias;
						uniforms.shadowRadius = shadow.radius;
						uniforms.shadowMapSize = shadow.mapSize;

					}

					state.directionalShadowMap[ directionalLength ] = shadowMap;
					state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
					state.directional[ directionalLength ] = uniforms;

					directionalLength ++;

				} else if ( light.isSpotLight ) {

					var uniforms = cache.get( light );

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					uniforms.color.copy( color ).multiplyScalar( intensity );
					uniforms.distance = distance;

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( vector3 );
					uniforms.direction.transformDirection( viewMatrix );

					uniforms.coneCos = Math.cos( light.angle );
					uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
					uniforms.decay = light.decay;

					uniforms.shadow = light.castShadow;

					if ( light.castShadow ) {

						var shadow = light.shadow;

						uniforms.shadowBias = shadow.bias;
						uniforms.shadowRadius = shadow.radius;
						uniforms.shadowMapSize = shadow.mapSize;

					}

					state.spotShadowMap[ spotLength ] = shadowMap;
					state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
					state.spot[ spotLength ] = uniforms;

					spotLength ++;

				} else if ( light.isRectAreaLight ) {

					var uniforms = cache.get( light );

					// (a) intensity is the total visible light emitted
					//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

					// (b) intensity is the brightness of the light
					uniforms.color.copy( color ).multiplyScalar( intensity );

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					// extract local rotation of light to derive width/height half vectors
					matrix42.identity();
					matrix4.copy( light.matrixWorld );
					matrix4.premultiply( viewMatrix );
					matrix42.extractRotation( matrix4 );

					uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
					uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

					uniforms.halfWidth.applyMatrix4( matrix42 );
					uniforms.halfHeight.applyMatrix4( matrix42 );

					// TODO (abelnation): RectAreaLight distance?
					// uniforms.distance = distance;

					state.rectArea[ rectAreaLength ] = uniforms;

					rectAreaLength ++;

				} else if ( light.isPointLight ) {

					var uniforms = cache.get( light );

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
					uniforms.distance = light.distance;
					uniforms.decay = light.decay;

					uniforms.shadow = light.castShadow;

					if ( light.castShadow ) {

						var shadow = light.shadow;

						uniforms.shadowBias = shadow.bias;
						uniforms.shadowRadius = shadow.radius;
						uniforms.shadowMapSize = shadow.mapSize;
						uniforms.shadowCameraNear = shadow.camera.near;
						uniforms.shadowCameraFar = shadow.camera.far;

					}

					state.pointShadowMap[ pointLength ] = shadowMap;
					state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;
					state.point[ pointLength ] = uniforms;

					pointLength ++;

				} else if ( light.isHemisphereLight ) {

					var uniforms = cache.get( light );

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					uniforms.direction.transformDirection( viewMatrix );
					uniforms.direction.normalize();

					uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
					uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

					state.hemi[ hemiLength ] = uniforms;

					hemiLength ++;

				}

			}

			state.ambient[ 0 ] = r;
			state.ambient[ 1 ] = g;
			state.ambient[ 2 ] = b;

			state.directional.length = directionalLength;
			state.spot.length = spotLength;
			state.rectArea.length = rectAreaLength;
			state.point.length = pointLength;
			state.hemi.length = hemiLength;

			state.hash.stateID = state.id;
			state.hash.directionalLength = directionalLength;
			state.hash.pointLength = pointLength;
			state.hash.spotLength = spotLength;
			state.hash.rectAreaLength = rectAreaLength;
			state.hash.hemiLength = hemiLength;
			state.hash.shadowsLength = shadows.length;

		}

		return {
			setup: setup,
			state: state
		};

	}

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function WebGLRenderState() {

		var lights = new WebGLLights();

		var lightsArray = [];
		var shadowsArray = [];

		function init() {

			lightsArray.length = 0;
			shadowsArray.length = 0;

		}

		function pushLight( light ) {

			lightsArray.push( light );

		}

		function pushShadow( shadowLight ) {

			shadowsArray.push( shadowLight );

		}

		function setupLights( camera ) {

			lights.setup( lightsArray, shadowsArray, camera );

		}

		var state = {
			lightsArray: lightsArray,
			shadowsArray: shadowsArray,

			lights: lights
		};

		return {
			init: init,
			state: state,
			setupLights: setupLights,

			pushLight: pushLight,
			pushShadow: pushShadow
		};

	}

	function WebGLRenderStates() {

		var renderStates = {};

		function onSceneDispose( event ) {

			var scene = event.target;

			scene.removeEventListener( 'dispose', onSceneDispose );

			delete renderStates[ scene.id ];

		}

		function get( scene, camera ) {

			var renderState;

			if ( renderStates[ scene.id ] === undefined ) {

				renderState = new WebGLRenderState();
				renderStates[ scene.id ] = {};
				renderStates[ scene.id ][ camera.id ] = renderState;

				scene.addEventListener( 'dispose', onSceneDispose );

			} else {

				if ( renderStates[ scene.id ][ camera.id ] === undefined ) {

					renderState = new WebGLRenderState();
					renderStates[ scene.id ][ camera.id ] = renderState;

				} else {

					renderState = renderStates[ scene.id ][ camera.id ];

				}

			}

			return renderState;

		}

		function dispose() {

			renderStates = {};

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / https://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */

	function MeshDepthMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshDepthMaterial';

		this.depthPacking = BasicDepthPacking;

		this.skinning = false;
		this.morphTargets = false;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false;
		this.lights = false;

		this.setValues( parameters );

	}

	MeshDepthMaterial.prototype = Object.create( Material.prototype );
	MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

	MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

	MeshDepthMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.depthPacking = source.depthPacking;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		return this;

	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *
	 *  referencePosition: <float>,
	 *  nearDistance: <float>,
	 *  farDistance: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>
	 *
	 * }
	 */

	function MeshDistanceMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshDistanceMaterial';

		this.referencePosition = new Vector3();
		this.nearDistance = 1;
		this.farDistance = 1000;

		this.skinning = false;
		this.morphTargets = false;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.fog = false;
		this.lights = false;

		this.setValues( parameters );

	}

	MeshDistanceMaterial.prototype = Object.create( Material.prototype );
	MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;

	MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

	MeshDistanceMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.referencePosition.copy( source.referencePosition );
		this.nearDistance = source.nearDistance;
		this.farDistance = source.farDistance;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		return this;

	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLShadowMap( _renderer, _objects, maxTextureSize ) {

		var _frustum = new Frustum(),
			_projScreenMatrix = new Matrix4(),

			_shadowMapSize = new Vector2(),
			_maxShadowMapSize = new Vector2( maxTextureSize, maxTextureSize ),

			_lookTarget = new Vector3(),
			_lightPositionWorld = new Vector3(),

			_MorphingFlag = 1,
			_SkinningFlag = 2,

			_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,

			_depthMaterials = new Array( _NumberOfMaterialVariants ),
			_distanceMaterials = new Array( _NumberOfMaterialVariants ),

			_materialCache = {};

		var shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };

		var cubeDirections = [
			new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
			new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
		];

		var cubeUps = [
			new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
			new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
		];

		var cube2DViewPorts = [
			new Vector4(), new Vector4(), new Vector4(),
			new Vector4(), new Vector4(), new Vector4()
		];

		// init

		for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {

			var useMorphing = ( i & _MorphingFlag ) !== 0;
			var useSkinning = ( i & _SkinningFlag ) !== 0;

			var depthMaterial = new MeshDepthMaterial( {

				depthPacking: RGBADepthPacking,

				morphTargets: useMorphing,
				skinning: useSkinning

			} );

			_depthMaterials[ i ] = depthMaterial;

			//

			var distanceMaterial = new MeshDistanceMaterial( {

				morphTargets: useMorphing,
				skinning: useSkinning

			} );

			_distanceMaterials[ i ] = distanceMaterial;

		}

		//

		var scope = this;

		this.enabled = false;

		this.autoUpdate = true;
		this.needsUpdate = false;

		this.type = PCFShadowMap;

		this.render = function ( lights, scene, camera ) {

			if ( scope.enabled === false ) return;
			if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

			if ( lights.length === 0 ) return;

			var currentRenderTarget = _renderer.getRenderTarget();

			var _state = _renderer.state;

			// Set GL state for depth map.
			_state.setBlending( NoBlending );
			_state.buffers.color.setClear( 1, 1, 1, 1 );
			_state.buffers.depth.setTest( true );
			_state.setScissorTest( false );

			// render depth map

			var faceCount;

			for ( var i = 0, il = lights.length; i < il; i ++ ) {

				var light = lights[ i ];
				var shadow = light.shadow;
				var isPointLight = light && light.isPointLight;

				if ( shadow === undefined ) {

					console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
					continue;

				}

				var shadowCamera = shadow.camera;

				_shadowMapSize.copy( shadow.mapSize );
				_shadowMapSize.min( _maxShadowMapSize );

				if ( isPointLight ) {

					var vpWidth = _shadowMapSize.x;
					var vpHeight = _shadowMapSize.y;

					// These viewports map a cube-map onto a 2D texture with the
					// following orientation:
					//
					//  xzXZ
					//   y Y
					//
					// X - Positive x direction
					// x - Negative x direction
					// Y - Positive y direction
					// y - Negative y direction
					// Z - Positive z direction
					// z - Negative z direction

					// positive X
					cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
					// negative X
					cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
					// positive Z
					cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
					// negative Z
					cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
					// positive Y
					cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
					// negative Y
					cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );

					_shadowMapSize.x *= 4.0;
					_shadowMapSize.y *= 2.0;

				}

				if ( shadow.map === null ) {

					var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

					shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
					shadow.map.texture.name = light.name + ".shadowMap";

					shadowCamera.updateProjectionMatrix();

				}

				if ( shadow.isSpotLightShadow ) {

					shadow.update( light );

				}

				var shadowMap = shadow.map;
				var shadowMatrix = shadow.matrix;

				_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
				shadowCamera.position.copy( _lightPositionWorld );

				if ( isPointLight ) {

					faceCount = 6;

					// for point lights we set the shadow matrix to be a translation-only matrix
					// equal to inverse of the light's position

					shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

				} else {

					faceCount = 1;

					_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
					shadowCamera.lookAt( _lookTarget );
					shadowCamera.updateMatrixWorld();

					// compute shadow matrix

					shadowMatrix.set(
						0.5, 0.0, 0.0, 0.5,
						0.0, 0.5, 0.0, 0.5,
						0.0, 0.0, 0.5, 0.5,
						0.0, 0.0, 0.0, 1.0
					);

					shadowMatrix.multiply( shadowCamera.projectionMatrix );
					shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

				}

				_renderer.setRenderTarget( shadowMap );
				_renderer.clear();

				// render shadow map for each cube face (if omni-directional) or
				// run a single pass if not

				for ( var face = 0; face < faceCount; face ++ ) {

					if ( isPointLight ) {

						_lookTarget.copy( shadowCamera.position );
						_lookTarget.add( cubeDirections[ face ] );
						shadowCamera.up.copy( cubeUps[ face ] );
						shadowCamera.lookAt( _lookTarget );
						shadowCamera.updateMatrixWorld();

						var vpDimensions = cube2DViewPorts[ face ];
						_state.viewport( vpDimensions );

					}

					// update camera matrices and frustum

					_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
					_frustum.setFromMatrix( _projScreenMatrix );

					// set object matrices & frustum culling

					renderObject( scene, camera, shadowCamera, isPointLight );

				}

			}

			scope.needsUpdate = false;

			_renderer.setRenderTarget( currentRenderTarget );

		};

		function getDepthMaterial( object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar ) {

			var geometry = object.geometry;

			var result = null;

			var materialVariants = _depthMaterials;
			var customMaterial = object.customDepthMaterial;

			if ( isPointLight ) {

				materialVariants = _distanceMaterials;
				customMaterial = object.customDistanceMaterial;

			}

			if ( ! customMaterial ) {

				var useMorphing = false;

				if ( material.morphTargets ) {

					if ( geometry && geometry.isBufferGeometry ) {

						useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

					} else if ( geometry && geometry.isGeometry ) {

						useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;

					}

				}

				if ( object.isSkinnedMesh && material.skinning === false ) {

					console.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );

				}

				var useSkinning = object.isSkinnedMesh && material.skinning;

				var variantIndex = 0;

				if ( useMorphing ) variantIndex |= _MorphingFlag;
				if ( useSkinning ) variantIndex |= _SkinningFlag;

				result = materialVariants[ variantIndex ];

			} else {

				result = customMaterial;

			}

			if ( _renderer.localClippingEnabled &&
					material.clipShadows === true &&
					material.clippingPlanes.length !== 0 ) {

				// in this case we need a unique material instance reflecting the
				// appropriate state

				var keyA = result.uuid, keyB = material.uuid;

				var materialsForVariant = _materialCache[ keyA ];

				if ( materialsForVariant === undefined ) {

					materialsForVariant = {};
					_materialCache[ keyA ] = materialsForVariant;

				}

				var cachedMaterial = materialsForVariant[ keyB ];

				if ( cachedMaterial === undefined ) {

					cachedMaterial = result.clone();
					materialsForVariant[ keyB ] = cachedMaterial;

				}

				result = cachedMaterial;

			}

			result.visible = material.visible;
			result.wireframe = material.wireframe;

			result.side = ( material.shadowSide != null ) ? material.shadowSide : shadowSide[ material.side ];

			result.clipShadows = material.clipShadows;
			result.clippingPlanes = material.clippingPlanes;
			result.clipIntersection = material.clipIntersection;

			result.wireframeLinewidth = material.wireframeLinewidth;
			result.linewidth = material.linewidth;

			if ( isPointLight && result.isMeshDistanceMaterial ) {

				result.referencePosition.copy( lightPositionWorld );
				result.nearDistance = shadowCameraNear;
				result.farDistance = shadowCameraFar;

			}

			return result;

		}

		function renderObject( object, camera, shadowCamera, isPointLight ) {

			if ( object.visible === false ) return;

			var visible = object.layers.test( camera.layers );

			if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

				if ( object.castShadow && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

					object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

					var geometry = _objects.update( object );
					var material = object.material;

					if ( Array.isArray( material ) ) {

						var groups = geometry.groups;

						for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

							var group = groups[ k ];
							var groupMaterial = material[ group.materialIndex ];

							if ( groupMaterial && groupMaterial.visible ) {

								var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );
								_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

							}

						}

					} else if ( material.visible ) {

						var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );
						_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

					}

				}

			}

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				renderObject( children[ i ], camera, shadowCamera, isPointLight );

			}

		}

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLState( gl, extensions, utils, capabilities ) {

		function ColorBuffer() {

			var locked = false;

			var color = new Vector4();
			var currentColorMask = null;
			var currentColorClear = new Vector4( 0, 0, 0, 0 );

			return {

				setMask: function ( colorMask ) {

					if ( currentColorMask !== colorMask && ! locked ) {

						gl.colorMask( colorMask, colorMask, colorMask, colorMask );
						currentColorMask = colorMask;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( r, g, b, a, premultipliedAlpha ) {

					if ( premultipliedAlpha === true ) {

						r *= a; g *= a; b *= a;

					}

					color.set( r, g, b, a );

					if ( currentColorClear.equals( color ) === false ) {

						gl.clearColor( r, g, b, a );
						currentColorClear.copy( color );

					}

				},

				reset: function () {

					locked = false;

					currentColorMask = null;
					currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

				}

			};

		}

		function DepthBuffer() {

			var locked = false;

			var currentDepthMask = null;
			var currentDepthFunc = null;
			var currentDepthClear = null;

			return {

				setTest: function ( depthTest ) {

					if ( depthTest ) {

						enable( 2929 );

					} else {

						disable( 2929 );

					}

				},

				setMask: function ( depthMask ) {

					if ( currentDepthMask !== depthMask && ! locked ) {

						gl.depthMask( depthMask );
						currentDepthMask = depthMask;

					}

				},

				setFunc: function ( depthFunc ) {

					if ( currentDepthFunc !== depthFunc ) {

						if ( depthFunc ) {

							switch ( depthFunc ) {

								case NeverDepth:

									gl.depthFunc( 512 );
									break;

								case AlwaysDepth:

									gl.depthFunc( 519 );
									break;

								case LessDepth:

									gl.depthFunc( 513 );
									break;

								case LessEqualDepth:

									gl.depthFunc( 515 );
									break;

								case EqualDepth:

									gl.depthFunc( 514 );
									break;

								case GreaterEqualDepth:

									gl.depthFunc( 518 );
									break;

								case GreaterDepth:

									gl.depthFunc( 516 );
									break;

								case NotEqualDepth:

									gl.depthFunc( 517 );
									break;

								default:

									gl.depthFunc( 515 );

							}

						} else {

							gl.depthFunc( 515 );

						}

						currentDepthFunc = depthFunc;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( depth ) {

					if ( currentDepthClear !== depth ) {

						gl.clearDepth( depth );
						currentDepthClear = depth;

					}

				},

				reset: function () {

					locked = false;

					currentDepthMask = null;
					currentDepthFunc = null;
					currentDepthClear = null;

				}

			};

		}

		function StencilBuffer() {

			var locked = false;

			var currentStencilMask = null;
			var currentStencilFunc = null;
			var currentStencilRef = null;
			var currentStencilFuncMask = null;
			var currentStencilFail = null;
			var currentStencilZFail = null;
			var currentStencilZPass = null;
			var currentStencilClear = null;

			return {

				setTest: function ( stencilTest ) {

					if ( stencilTest ) {

						enable( 2960 );

					} else {

						disable( 2960 );

					}

				},

				setMask: function ( stencilMask ) {

					if ( currentStencilMask !== stencilMask && ! locked ) {

						gl.stencilMask( stencilMask );
						currentStencilMask = stencilMask;

					}

				},

				setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

					if ( currentStencilFunc !== stencilFunc ||
					     currentStencilRef 	!== stencilRef 	||
					     currentStencilFuncMask !== stencilMask ) {

						gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

						currentStencilFunc = stencilFunc;
						currentStencilRef = stencilRef;
						currentStencilFuncMask = stencilMask;

					}

				},

				setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

					if ( currentStencilFail	 !== stencilFail 	||
					     currentStencilZFail !== stencilZFail ||
					     currentStencilZPass !== stencilZPass ) {

						gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

						currentStencilFail = stencilFail;
						currentStencilZFail = stencilZFail;
						currentStencilZPass = stencilZPass;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( stencil ) {

					if ( currentStencilClear !== stencil ) {

						gl.clearStencil( stencil );
						currentStencilClear = stencil;

					}

				},

				reset: function () {

					locked = false;

					currentStencilMask = null;
					currentStencilFunc = null;
					currentStencilRef = null;
					currentStencilFuncMask = null;
					currentStencilFail = null;
					currentStencilZFail = null;
					currentStencilZPass = null;
					currentStencilClear = null;

				}

			};

		}

		//

		var colorBuffer = new ColorBuffer();
		var depthBuffer = new DepthBuffer();
		var stencilBuffer = new StencilBuffer();

		var maxVertexAttributes = gl.getParameter( 34921 );
		var newAttributes = new Uint8Array( maxVertexAttributes );
		var enabledAttributes = new Uint8Array( maxVertexAttributes );
		var attributeDivisors = new Uint8Array( maxVertexAttributes );

		var enabledCapabilities = {};

		var compressedTextureFormats = null;

		var currentProgram = null;

		var currentBlendingEnabled = null;
		var currentBlending = null;
		var currentBlendEquation = null;
		var currentBlendSrc = null;
		var currentBlendDst = null;
		var currentBlendEquationAlpha = null;
		var currentBlendSrcAlpha = null;
		var currentBlendDstAlpha = null;
		var currentPremultipledAlpha = false;

		var currentFlipSided = null;
		var currentCullFace = null;

		var currentLineWidth = null;

		var currentPolygonOffsetFactor = null;
		var currentPolygonOffsetUnits = null;

		var maxTextures = gl.getParameter( 35661 );

		var lineWidthAvailable = false;
		var version = 0;
		var glVersion = gl.getParameter( 7938 );

		if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

			version = parseFloat( /^WebGL\ ([0-9])/.exec( glVersion )[ 1 ] );
			lineWidthAvailable = ( version >= 1.0 );

		} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

			version = parseFloat( /^OpenGL\ ES\ ([0-9])/.exec( glVersion )[ 1 ] );
			lineWidthAvailable = ( version >= 2.0 );

		}

		var currentTextureSlot = null;
		var currentBoundTextures = {};

		var currentScissor = new Vector4();
		var currentViewport = new Vector4();

		function createTexture( type, target, count ) {

			var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
			var texture = gl.createTexture();

			gl.bindTexture( type, texture );
			gl.texParameteri( type, 10241, 9728 );
			gl.texParameteri( type, 10240, 9728 );

			for ( var i = 0; i < count; i ++ ) {

				gl.texImage2D( target + i, 0, 6408, 1, 1, 0, 6408, 5121, data );

			}

			return texture;

		}

		var emptyTextures = {};
		emptyTextures[ 3553 ] = createTexture( 3553, 3553, 1 );
		emptyTextures[ 34067 ] = createTexture( 34067, 34069, 6 );

		// init

		colorBuffer.setClear( 0, 0, 0, 1 );
		depthBuffer.setClear( 1 );
		stencilBuffer.setClear( 0 );

		enable( 2929 );
		depthBuffer.setFunc( LessEqualDepth );

		setFlipSided( false );
		setCullFace( CullFaceBack );
		enable( 2884 );

		setBlending( NoBlending );

		//

		function initAttributes() {

			for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

				newAttributes[ i ] = 0;

			}

		}

		function enableAttribute( attribute ) {

			enableAttributeAndDivisor( attribute, 0 );

		}

		function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

			newAttributes[ attribute ] = 1;

			if ( enabledAttributes[ attribute ] === 0 ) {

				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;

			}

			if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

				var extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );

				extension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
				attributeDivisors[ attribute ] = meshPerAttribute;

			}

		}

		function disableUnusedAttributes() {

			for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {

				if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;

				}

			}

		}

		function enable( id ) {

			if ( enabledCapabilities[ id ] !== true ) {

				gl.enable( id );
				enabledCapabilities[ id ] = true;

			}

		}

		function disable( id ) {

			if ( enabledCapabilities[ id ] !== false ) {

				gl.disable( id );
				enabledCapabilities[ id ] = false;

			}

		}

		function getCompressedTextureFormats() {

			if ( compressedTextureFormats === null ) {

				compressedTextureFormats = [];

				if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
				     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
				     extensions.get( 'WEBGL_compressed_texture_etc1' ) ||
				     extensions.get( 'WEBGL_compressed_texture_astc' ) ) {

					var formats = gl.getParameter( 34467 );

					for ( var i = 0; i < formats.length; i ++ ) {

						compressedTextureFormats.push( formats[ i ] );

					}

				}

			}

			return compressedTextureFormats;

		}

		function useProgram( program ) {

			if ( currentProgram !== program ) {

				gl.useProgram( program );

				currentProgram = program;

				return true;

			}

			return false;

		}

		function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

			if ( blending === NoBlending ) {

				if ( currentBlendingEnabled ) {

					disable( 3042 );
					currentBlendingEnabled = false;

				}

				return;

			}

			if ( ! currentBlendingEnabled ) {

				enable( 3042 );
				currentBlendingEnabled = true;

			}

			if ( blending !== CustomBlending ) {

				if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

					if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {

						gl.blendEquation( 32774 );

						currentBlendEquation = AddEquation;
						currentBlendEquationAlpha = AddEquation;

					}

					if ( premultipliedAlpha ) {

						switch ( blending ) {

							case NormalBlending:
								gl.blendFuncSeparate( 1, 771, 1, 771 );
								break;

							case AdditiveBlending:
								gl.blendFunc( 1, 1 );
								break;

							case SubtractiveBlending:
								gl.blendFuncSeparate( 0, 0, 769, 771 );
								break;

							case MultiplyBlending:
								gl.blendFuncSeparate( 0, 768, 0, 770 );
								break;

							default:
								console.error( 'THREE.WebGLState: Invalid blending: ', blending );
								break;

						}

					} else {

						switch ( blending ) {

							case NormalBlending:
								gl.blendFuncSeparate( 770, 771, 1, 771 );
								break;

							case AdditiveBlending:
								gl.blendFunc( 770, 1 );
								break;

							case SubtractiveBlending:
								gl.blendFunc( 0, 769 );
								break;

							case MultiplyBlending:
								gl.blendFunc( 0, 768 );
								break;

							default:
								console.error( 'THREE.WebGLState: Invalid blending: ', blending );
								break;

						}

					}

					currentBlendSrc = null;
					currentBlendDst = null;
					currentBlendSrcAlpha = null;
					currentBlendDstAlpha = null;

					currentBlending = blending;
					currentPremultipledAlpha = premultipliedAlpha;

				}

				return;

			}

			// custom blending

			blendEquationAlpha = blendEquationAlpha || blendEquation;
			blendSrcAlpha = blendSrcAlpha || blendSrc;
			blendDstAlpha = blendDstAlpha || blendDst;

			if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

				gl.blendEquationSeparate( utils.convert( blendEquation ), utils.convert( blendEquationAlpha ) );

				currentBlendEquation = blendEquation;
				currentBlendEquationAlpha = blendEquationAlpha;

			}

			if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

				gl.blendFuncSeparate( utils.convert( blendSrc ), utils.convert( blendDst ), utils.convert( blendSrcAlpha ), utils.convert( blendDstAlpha ) );

				currentBlendSrc = blendSrc;
				currentBlendDst = blendDst;
				currentBlendSrcAlpha = blendSrcAlpha;
				currentBlendDstAlpha = blendDstAlpha;

			}

			currentBlending = blending;
			currentPremultipledAlpha = null;

		}

		function setMaterial( material, frontFaceCW ) {

			material.side === DoubleSide
				? disable( 2884 )
				: enable( 2884 );

			var flipSided = ( material.side === BackSide );
			if ( frontFaceCW ) flipSided = ! flipSided;

			setFlipSided( flipSided );

			( material.blending === NormalBlending && material.transparent === false )
				? setBlending( NoBlending )
				: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

			depthBuffer.setFunc( material.depthFunc );
			depthBuffer.setTest( material.depthTest );
			depthBuffer.setMask( material.depthWrite );
			colorBuffer.setMask( material.colorWrite );

			setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

		}

		//

		function setFlipSided( flipSided ) {

			if ( currentFlipSided !== flipSided ) {

				if ( flipSided ) {

					gl.frontFace( 2304 );

				} else {

					gl.frontFace( 2305 );

				}

				currentFlipSided = flipSided;

			}

		}

		function setCullFace( cullFace ) {

			if ( cullFace !== CullFaceNone ) {

				enable( 2884 );

				if ( cullFace !== currentCullFace ) {

					if ( cullFace === CullFaceBack ) {

						gl.cullFace( 1029 );

					} else if ( cullFace === CullFaceFront ) {

						gl.cullFace( 1028 );

					} else {

						gl.cullFace( 1032 );

					}

				}

			} else {

				disable( 2884 );

			}

			currentCullFace = cullFace;

		}

		function setLineWidth( width ) {

			if ( width !== currentLineWidth ) {

				if ( lineWidthAvailable ) gl.lineWidth( width );

				currentLineWidth = width;

			}

		}

		function setPolygonOffset( polygonOffset, factor, units ) {

			if ( polygonOffset ) {

				enable( 32823 );

				if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

					gl.polygonOffset( factor, units );

					currentPolygonOffsetFactor = factor;
					currentPolygonOffsetUnits = units;

				}

			} else {

				disable( 32823 );

			}

		}

		function setScissorTest( scissorTest ) {

			if ( scissorTest ) {

				enable( 3089 );

			} else {

				disable( 3089 );

			}

		}

		// texture

		function activeTexture( webglSlot ) {

			if ( webglSlot === undefined ) webglSlot = 33984 + maxTextures - 1;

			if ( currentTextureSlot !== webglSlot ) {

				gl.activeTexture( webglSlot );
				currentTextureSlot = webglSlot;

			}

		}

		function bindTexture( webglType, webglTexture ) {

			if ( currentTextureSlot === null ) {

				activeTexture();

			}

			var boundTexture = currentBoundTextures[ currentTextureSlot ];

			if ( boundTexture === undefined ) {

				boundTexture = { type: undefined, texture: undefined };
				currentBoundTextures[ currentTextureSlot ] = boundTexture;

			}

			if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

				gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;

			}

		}

		function compressedTexImage2D() {

			try {

				gl.compressedTexImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texImage2D() {

			try {

				gl.texImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texImage3D() {

			try {

				gl.texImage3D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		//

		function scissor( scissor ) {

			if ( currentScissor.equals( scissor ) === false ) {

				gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
				currentScissor.copy( scissor );

			}

		}

		function viewport( viewport ) {

			if ( currentViewport.equals( viewport ) === false ) {

				gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
				currentViewport.copy( viewport );

			}

		}

		//

		function reset() {

			for ( var i = 0; i < enabledAttributes.length; i ++ ) {

				if ( enabledAttributes[ i ] === 1 ) {

					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;

				}

			}

			enabledCapabilities = {};

			compressedTextureFormats = null;

			currentTextureSlot = null;
			currentBoundTextures = {};

			currentProgram = null;

			currentBlending = null;

			currentFlipSided = null;
			currentCullFace = null;

			colorBuffer.reset();
			depthBuffer.reset();
			stencilBuffer.reset();

		}

		return {

			buffers: {
				color: colorBuffer,
				depth: depthBuffer,
				stencil: stencilBuffer
			},

			initAttributes: initAttributes,
			enableAttribute: enableAttribute,
			enableAttributeAndDivisor: enableAttributeAndDivisor,
			disableUnusedAttributes: disableUnusedAttributes,
			enable: enable,
			disable: disable,
			getCompressedTextureFormats: getCompressedTextureFormats,

			useProgram: useProgram,

			setBlending: setBlending,
			setMaterial: setMaterial,

			setFlipSided: setFlipSided,
			setCullFace: setCullFace,

			setLineWidth: setLineWidth,
			setPolygonOffset: setPolygonOffset,

			setScissorTest: setScissorTest,

			activeTexture: activeTexture,
			bindTexture: bindTexture,
			compressedTexImage2D: compressedTexImage2D,
			texImage2D: texImage2D,
			texImage3D: texImage3D,

			scissor: scissor,
			viewport: viewport,

			reset: reset

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

		var _videoTextures = {};
		var _canvas;

		//

		var useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined';

		function createCanvas( width, height ) {

			// Use OffscreenCanvas when available. Specially needed in web workers

			return useOffscreenCanvas ?
				new OffscreenCanvas( width, height ) :
				document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

		}

		function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {

			var scale = 1;

			// handle case if texture exceeds max size

			if ( image.width > maxSize || image.height > maxSize ) {

				scale = maxSize / Math.max( image.width, image.height );

			}

			// only perform resize if necessary

			if ( scale < 1 || needsPowerOfTwo === true ) {

				// only perform resize for certain image types

				if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
					( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
					( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

					var floor = needsPowerOfTwo ? _Math.floorPowerOfTwo : Math.floor;

					var width = floor( scale * image.width );
					var height = floor( scale * image.height );

					if ( _canvas === undefined ) _canvas = createCanvas( width, height );

					// cube textures can't reuse the same canvas

					var canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

					canvas.width = width;
					canvas.height = height;

					var context = canvas.getContext( '2d' );
					context.drawImage( image, 0, 0, width, height );

					console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );

					return canvas;

				} else {

					if ( 'data' in image ) {

						console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );

					}

					return image;

				}

			}

			return image;

		}

		function isPowerOfTwo( image ) {

			return _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );

		}

		function textureNeedsPowerOfTwo( texture ) {

			if ( capabilities.isWebGL2 ) return false;

			return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
				( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

		}

		function textureNeedsGenerateMipmaps( texture, supportsMips ) {

			return texture.generateMipmaps && supportsMips &&
				texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

		}

		function generateMipmap( target, texture, width, height ) {

			_gl.generateMipmap( target );

			var textureProperties = properties.get( texture );

			// Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11
			textureProperties.__maxMipLevel = Math.log( Math.max( width, height ) ) * Math.LOG2E;

		}

		function getInternalFormat( glFormat, glType ) {

			if ( ! capabilities.isWebGL2 ) return glFormat;

			var internalFormat = glFormat;

			if ( glFormat === 6403 ) {

				if ( glType === 5126 ) internalFormat = 33326;
				if ( glType === 5131 ) internalFormat = 33325;
				if ( glType === 5121 ) internalFormat = 33321;

			}

			if ( glFormat === 6407 ) {

				if ( glType === 5126 ) internalFormat = 34837;
				if ( glType === 5131 ) internalFormat = 34843;
				if ( glType === 5121 ) internalFormat = 32849;

			}

			if ( glFormat === 6408 ) {

				if ( glType === 5126 ) internalFormat = 34836;
				if ( glType === 5131 ) internalFormat = 34842;
				if ( glType === 5121 ) internalFormat = 32856;

			}

			if ( internalFormat === 33325 || internalFormat === 33326 ||
				internalFormat === 34842 || internalFormat === 34836 ) {

				extensions.get( 'EXT_color_buffer_float' );

			} else if ( internalFormat === 34843 || internalFormat === 34837 ) {

				console.warn( 'THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.' );

			}

			return internalFormat;

		}

		// Fallback filters for non-power-of-2 textures

		function filterFallback( f ) {

			if ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {

				return 9728;

			}

			return 9729;

		}

		//

		function onTextureDispose( event ) {

			var texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			deallocateTexture( texture );

			if ( texture.isVideoTexture ) {

				delete _videoTextures[ texture.id ];

			}

			info.memory.textures --;

		}

		function onRenderTargetDispose( event ) {

			var renderTarget = event.target;

			renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

			deallocateRenderTarget( renderTarget );

			info.memory.textures --;

		}

		//

		function deallocateTexture( texture ) {

			var textureProperties = properties.get( texture );

			if ( textureProperties.__webglInit === undefined ) return;

			_gl.deleteTexture( textureProperties.__webglTexture );

			properties.remove( texture );

		}

		function deallocateRenderTarget( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );
			var textureProperties = properties.get( renderTarget.texture );

			if ( ! renderTarget ) return;

			if ( textureProperties.__webglTexture !== undefined ) {

				_gl.deleteTexture( textureProperties.__webglTexture );

			}

			if ( renderTarget.depthTexture ) {

				renderTarget.depthTexture.dispose();

			}

			if ( renderTarget.isWebGLRenderTargetCube ) {

				for ( var i = 0; i < 6; i ++ ) {

					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
					if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

				}

			} else {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );

			}

			properties.remove( renderTarget.texture );
			properties.remove( renderTarget );

		}

		//

		var textureUnits = 0;

		function resetTextureUnits() {

			textureUnits = 0;

		}

		function allocateTextureUnit() {

			var textureUnit = textureUnits;

			if ( textureUnit >= capabilities.maxTextures ) {

				console.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

			}

			textureUnits += 1;

			return textureUnit;

		}

		//

		function setTexture2D( texture, slot ) {

			var textureProperties = properties.get( texture );

			if ( texture.isVideoTexture ) updateVideoTexture( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				var image = texture.image;

				if ( image === undefined ) {

					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' );

				} else if ( image.complete === false ) {

					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );

				} else {

					uploadTexture( textureProperties, texture, slot );
					return;

				}

			}

			state.activeTexture( 33984 + slot );
			state.bindTexture( 3553, textureProperties.__webglTexture );

		}

		function setTexture2DArray( texture, slot ) {

			var textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

			state.activeTexture( 33984 + slot );
			state.bindTexture( 35866, textureProperties.__webglTexture );

		}

		function setTexture3D( texture, slot ) {

			var textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

			state.activeTexture( 33984 + slot );
			state.bindTexture( 32879, textureProperties.__webglTexture );

		}

		function setTextureCube( texture, slot ) {

			var textureProperties = properties.get( texture );

			if ( texture.image.length === 6 ) {

				if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

					initTexture( textureProperties, texture );

					state.activeTexture( 33984 + slot );
					state.bindTexture( 34067, textureProperties.__webglTexture );

					_gl.pixelStorei( 37440, texture.flipY );

					var isCompressed = ( texture && texture.isCompressedTexture );
					var isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

					var cubeImage = [];

					for ( var i = 0; i < 6; i ++ ) {

						if ( ! isCompressed && ! isDataTexture ) {

							cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, capabilities.maxCubemapSize );

						} else {

							cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

						}

					}

					var image = cubeImage[ 0 ],
						supportsMips = isPowerOfTwo( image ) || capabilities.isWebGL2,
						glFormat = utils.convert( texture.format ),
						glType = utils.convert( texture.type ),
						glInternalFormat = getInternalFormat( glFormat, glType );

					setTextureParameters( 34067, texture, supportsMips );

					for ( var i = 0; i < 6; i ++ ) {

						if ( ! isCompressed ) {

							if ( isDataTexture ) {

								state.texImage2D( 34069 + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

							} else {

								state.texImage2D( 34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

							}

						} else {

							var mipmap, mipmaps = cubeImage[ i ].mipmaps;

							for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

								mipmap = mipmaps[ j ];

								if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

									if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

										state.compressedTexImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

									} else {

										console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

									}

								} else {

									state.texImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

								}

							}

						}

					}

					if ( ! isCompressed ) {

						textureProperties.__maxMipLevel = 0;

					} else {

						textureProperties.__maxMipLevel = mipmaps.length - 1;

					}

					if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

						// We assume images for cube map have the same size.
						generateMipmap( 34067, texture, image.width, image.height );

					}

					textureProperties.__version = texture.version;

					if ( texture.onUpdate ) texture.onUpdate( texture );

				} else {

					state.activeTexture( 33984 + slot );
					state.bindTexture( 34067, textureProperties.__webglTexture );

				}

			}

		}

		function setTextureCubeDynamic( texture, slot ) {

			state.activeTexture( 33984 + slot );
			state.bindTexture( 34067, properties.get( texture ).__webglTexture );

		}

		function setTextureParameters( textureType, texture, supportsMips ) {

			var extension;

			if ( supportsMips ) {

				_gl.texParameteri( textureType, 10242, utils.convert( texture.wrapS ) );
				_gl.texParameteri( textureType, 10243, utils.convert( texture.wrapT ) );

				if ( textureType === 32879 || textureType === 35866 ) {

					_gl.texParameteri( textureType, 32882, utils.convert( texture.wrapR ) );

				}

				_gl.texParameteri( textureType, 10240, utils.convert( texture.magFilter ) );
				_gl.texParameteri( textureType, 10241, utils.convert( texture.minFilter ) );

			} else {

				_gl.texParameteri( textureType, 10242, 33071 );
				_gl.texParameteri( textureType, 10243, 33071 );

				if ( textureType === 32879 || textureType === 35866 ) {

					_gl.texParameteri( textureType, 32882, 33071 );

				}

				if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );

				}

				_gl.texParameteri( textureType, 10240, filterFallback( texture.magFilter ) );
				_gl.texParameteri( textureType, 10241, filterFallback( texture.minFilter ) );

				if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );

				}

			}

			extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( extension ) {

				if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
				if ( texture.type === HalfFloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_half_float_linear' ) ) === null ) return;

				if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

					_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
					properties.get( texture ).__currentAnisotropy = texture.anisotropy;

				}

			}

		}

		function initTexture( textureProperties, texture ) {

			if ( textureProperties.__webglInit === undefined ) {

				textureProperties.__webglInit = true;

				texture.addEventListener( 'dispose', onTextureDispose );

				textureProperties.__webglTexture = _gl.createTexture();

				info.memory.textures ++;

			}

		}

		function uploadTexture( textureProperties, texture, slot ) {

			var textureType = 3553;

			if ( texture.isDataTexture2DArray ) textureType = 35866;
			if ( texture.isDataTexture3D ) textureType = 32879;

			initTexture( textureProperties, texture );

			state.activeTexture( 33984 + slot );
			state.bindTexture( textureType, textureProperties.__webglTexture );

			_gl.pixelStorei( 37440, texture.flipY );
			_gl.pixelStorei( 37441, texture.premultiplyAlpha );
			_gl.pixelStorei( 3317, texture.unpackAlignment );

			var needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false;
			var image = resizeImage( texture.image, needsPowerOfTwo, false, capabilities.maxTextureSize );

			var supportsMips = isPowerOfTwo( image ) || capabilities.isWebGL2,
				glFormat = utils.convert( texture.format ),
				glType = utils.convert( texture.type ),
				glInternalFormat = getInternalFormat( glFormat, glType );

			setTextureParameters( textureType, texture, supportsMips );

			var mipmap, mipmaps = texture.mipmaps;

			if ( texture.isDepthTexture ) {

				// populate depth texture with dummy data

				glInternalFormat = 6402;

				if ( texture.type === FloatType ) {

					if ( ! capabilities.isWebGL2 ) throw new Error( 'Float Depth Texture only supported in WebGL2.0' );
					glInternalFormat = 36012;

				} else if ( capabilities.isWebGL2 ) {

					// WebGL 2.0 requires signed internalformat for glTexImage2D
					glInternalFormat = 33189;

				}

				if ( texture.format === DepthFormat && glInternalFormat === 6402 ) {

					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

						console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

						texture.type = UnsignedShortType;
						glType = utils.convert( texture.type );

					}

				}

				// Depth stencil textures need the DEPTH_STENCIL internal format
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				if ( texture.format === DepthStencilFormat ) {

					glInternalFormat = 34041;

					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.type !== UnsignedInt248Type ) {

						console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

						texture.type = UnsignedInt248Type;
						glType = utils.convert( texture.type );

					}

				}

				state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

			} else if ( texture.isDataTexture ) {

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && supportsMips ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

					texture.generateMipmaps = false;
					textureProperties.__maxMipLevel = mipmaps.length - 1;

				} else {

					state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );
					textureProperties.__maxMipLevel = 0;

				}

			} else if ( texture.isCompressedTexture ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];

					if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

						if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

							state.compressedTexImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

						} else {

							console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

						}

					} else {

						state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

				}

				textureProperties.__maxMipLevel = mipmaps.length - 1;

			} else if ( texture.isDataTexture2DArray ) {

				state.texImage3D( 35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
				textureProperties.__maxMipLevel = 0;

			} else if ( texture.isDataTexture3D ) {

				state.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
				textureProperties.__maxMipLevel = 0;

			} else {

				// regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && supportsMips ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						state.texImage2D( 3553, i, glInternalFormat, glFormat, glType, mipmap );

					}

					texture.generateMipmaps = false;
					textureProperties.__maxMipLevel = mipmaps.length - 1;

				} else {

					state.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image );
					textureProperties.__maxMipLevel = 0;

				}

			}

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				generateMipmap( 3553, texture, image.width, image.height );

			}

			textureProperties.__version = texture.version;

			if ( texture.onUpdate ) texture.onUpdate( texture );

		}

		// Render targets

		// Setup storage for target texture and bind it to correct framebuffer
		function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

			var glFormat = utils.convert( renderTarget.texture.format );
			var glType = utils.convert( renderTarget.texture.type );
			var glInternalFormat = getInternalFormat( glFormat, glType );
			state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
			_gl.bindFramebuffer( 36160, framebuffer );
			_gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
			_gl.bindFramebuffer( 36160, null );

		}

		// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
		function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

			_gl.bindRenderbuffer( 36161, renderbuffer );

			if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

				if ( isMultisample ) {

					var samples = getRenderTargetSamples( renderTarget );

					_gl.renderbufferStorageMultisample( 36161, samples, 33189, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorage( 36161, 33189, renderTarget.width, renderTarget.height );

				}

				_gl.framebufferRenderbuffer( 36160, 36096, 36161, renderbuffer );

			} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

				if ( isMultisample ) {

					var samples = getRenderTargetSamples( renderTarget );

					_gl.renderbufferStorageMultisample( 36161, samples, 34041, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorage( 36161, 34041, renderTarget.width, renderTarget.height );

				}


				_gl.framebufferRenderbuffer( 36160, 33306, 36161, renderbuffer );

			} else {

				var glFormat = utils.convert( renderTarget.texture.format );
				var glType = utils.convert( renderTarget.texture.type );
				var glInternalFormat = getInternalFormat( glFormat, glType );

				if ( isMultisample ) {

					var samples = getRenderTargetSamples( renderTarget );

					_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

				}

			}

			_gl.bindRenderbuffer( 36161, null );

		}

		// Setup resources for a Depth Texture for a FBO (needs an extension)
		function setupDepthTexture( framebuffer, renderTarget ) {

			var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
			if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

			_gl.bindFramebuffer( 36160, framebuffer );

			if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

				throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

			}

			// upload an empty depth texture with framebuffer size
			if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
					renderTarget.depthTexture.image.width !== renderTarget.width ||
					renderTarget.depthTexture.image.height !== renderTarget.height ) {

				renderTarget.depthTexture.image.width = renderTarget.width;
				renderTarget.depthTexture.image.height = renderTarget.height;
				renderTarget.depthTexture.needsUpdate = true;

			}

			setTexture2D( renderTarget.depthTexture, 0 );

			var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

			if ( renderTarget.depthTexture.format === DepthFormat ) {

				_gl.framebufferTexture2D( 36160, 36096, 3553, webglDepthTexture, 0 );

			} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

				_gl.framebufferTexture2D( 36160, 33306, 3553, webglDepthTexture, 0 );

			} else {

				throw new Error( 'Unknown depthTexture format' );

			}

		}

		// Setup GL resources for a non-texture depth buffer
		function setupDepthRenderbuffer( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );

			var isCube = ( renderTarget.isWebGLRenderTargetCube === true );

			if ( renderTarget.depthTexture ) {

				if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

				setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

			} else {

				if ( isCube ) {

					renderTargetProperties.__webglDepthbuffer = [];

					for ( var i = 0; i < 6; i ++ ) {

						_gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer[ i ] );
						renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );

					}

				} else {

					_gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
					renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );

				}

			}

			_gl.bindFramebuffer( 36160, null );

		}

		// Set up GL resources for the render target
		function setupRenderTarget( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );
			var textureProperties = properties.get( renderTarget.texture );

			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

			textureProperties.__webglTexture = _gl.createTexture();

			info.memory.textures ++;

			var isCube = ( renderTarget.isWebGLRenderTargetCube === true );
			var isMultisample = ( renderTarget.isWebGLMultisampleRenderTarget === true );
			var supportsMips = isPowerOfTwo( renderTarget ) || capabilities.isWebGL2;

			// Setup framebuffer

			if ( isCube ) {

				renderTargetProperties.__webglFramebuffer = [];

				for ( var i = 0; i < 6; i ++ ) {

					renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

				}

			} else {

				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

				if ( isMultisample ) {

					if ( capabilities.isWebGL2 ) {

						renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
						renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

						_gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer );
						var glFormat = utils.convert( renderTarget.texture.format );
						var glType = utils.convert( renderTarget.texture.type );
						var glInternalFormat = getInternalFormat( glFormat, glType );
						var samples = getRenderTargetSamples( renderTarget );
						_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

						_gl.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );
						_gl.framebufferRenderbuffer( 36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer );
						_gl.bindRenderbuffer( 36161, null );

						if ( renderTarget.depthBuffer ) {

							renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
							setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

						}

						_gl.bindFramebuffer( 36160, null );


					} else {

						console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

					}

				}

			}

			// Setup color buffer

			if ( isCube ) {

				state.bindTexture( 34067, textureProperties.__webglTexture );
				setTextureParameters( 34067, renderTarget.texture, supportsMips );

				for ( var i = 0; i < 6; i ++ ) {

					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, 36064, 34069 + i );

				}

				if ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) {

					generateMipmap( 34067, renderTarget.texture, renderTarget.width, renderTarget.height );

				}

				state.bindTexture( 34067, null );

			} else {

				state.bindTexture( 3553, textureProperties.__webglTexture );
				setTextureParameters( 3553, renderTarget.texture, supportsMips );
				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553 );

				if ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) {

					generateMipmap( 3553, renderTarget.texture, renderTarget.width, renderTarget.height );

				}

				state.bindTexture( 3553, null );

			}

			// Setup depth and stencil buffers

			if ( renderTarget.depthBuffer ) {

				setupDepthRenderbuffer( renderTarget );

			}

		}

		function updateRenderTargetMipmap( renderTarget ) {

			var texture = renderTarget.texture;
			var supportsMips = isPowerOfTwo( renderTarget ) || capabilities.isWebGL2;

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				var target = renderTarget.isWebGLRenderTargetCube ? 34067 : 3553;
				var webglTexture = properties.get( texture ).__webglTexture;

				state.bindTexture( target, webglTexture );
				generateMipmap( target, texture, renderTarget.width, renderTarget.height );
				state.bindTexture( target, null );

			}

		}

		function updateMultisampleRenderTarget( renderTarget ) {

			if ( renderTarget.isWebGLMultisampleRenderTarget ) {

				if ( capabilities.isWebGL2 ) {

					var renderTargetProperties = properties.get( renderTarget );

					_gl.bindFramebuffer( 36008, renderTargetProperties.__webglMultisampledFramebuffer );
					_gl.bindFramebuffer( 36009, renderTargetProperties.__webglFramebuffer );

					var width = renderTarget.width;
					var height = renderTarget.height;
					var mask = 16384;

					if ( renderTarget.depthBuffer ) mask |= 256;
					if ( renderTarget.stencilBuffer ) mask |= 1024;

					_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, 9728 );

				} else {

					console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

				}

			}

		}

		function getRenderTargetSamples( renderTarget ) {

			return ( capabilities.isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ) ?
				Math.min( capabilities.maxSamples, renderTarget.samples ) : 0;

		}

		function updateVideoTexture( texture ) {

			var id = texture.id;
			var frame = info.render.frame;

			// Check the last frame we updated the VideoTexture

			if ( _videoTextures[ id ] !== frame ) {

				_videoTextures[ id ] = frame;
				texture.update();

			}

		}

		// backwards compatibility

		var warnedTexture2D = false;
		var warnedTextureCube = false;

		function safeSetTexture2D( texture, slot ) {

			if ( texture && texture.isWebGLRenderTarget ) {

				if ( warnedTexture2D === false ) {

					console.warn( "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead." );
					warnedTexture2D = true;

				}

				texture = texture.texture;

			}

			setTexture2D( texture, slot );

		}

		function safeSetTextureCube( texture, slot ) {

			if ( texture && texture.isWebGLRenderTargetCube ) {

				if ( warnedTextureCube === false ) {

					console.warn( "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
					warnedTextureCube = true;

				}

				texture = texture.texture;

			}

			// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
			// TODO: unify these code paths
			if ( ( texture && texture.isCubeTexture ) ||
				( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

				// CompressedTexture can have Array in image :/

				// this function alone should take care of cube textures
				setTextureCube( texture, slot );

			} else {

				// assumed: texture property of THREE.WebGLRenderTargetCube
				setTextureCubeDynamic( texture, slot );

			}

		}

		//

		this.allocateTextureUnit = allocateTextureUnit;
		this.resetTextureUnits = resetTextureUnits;

		this.setTexture2D = setTexture2D;
		this.setTexture2DArray = setTexture2DArray;
		this.setTexture3D = setTexture3D;
		this.setTextureCube = setTextureCube;
		this.setTextureCubeDynamic = setTextureCubeDynamic;
		this.setupRenderTarget = setupRenderTarget;
		this.updateRenderTargetMipmap = updateRenderTargetMipmap;
		this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;

		this.safeSetTexture2D = safeSetTexture2D;
		this.safeSetTextureCube = safeSetTextureCube;

	}

	/**
	 * @author thespite / http://www.twitter.com/thespite
	 */

	function WebGLUtils( gl, extensions, capabilities ) {

		function convert( p ) {

			var extension;

			if ( p === RepeatWrapping ) return 10497;
			if ( p === ClampToEdgeWrapping ) return 33071;
			if ( p === MirroredRepeatWrapping ) return 33648;

			if ( p === NearestFilter ) return 9728;
			if ( p === NearestMipMapNearestFilter ) return 9984;
			if ( p === NearestMipMapLinearFilter ) return 9986;

			if ( p === LinearFilter ) return 9729;
			if ( p === LinearMipMapNearestFilter ) return 9985;
			if ( p === LinearMipMapLinearFilter ) return 9987;

			if ( p === UnsignedByteType ) return 5121;
			if ( p === UnsignedShort4444Type ) return 32819;
			if ( p === UnsignedShort5551Type ) return 32820;
			if ( p === UnsignedShort565Type ) return 33635;

			if ( p === ByteType ) return 5120;
			if ( p === ShortType ) return 5122;
			if ( p === UnsignedShortType ) return 5123;
			if ( p === IntType ) return 5124;
			if ( p === UnsignedIntType ) return 5125;
			if ( p === FloatType ) return 5126;

			if ( p === HalfFloatType ) {

				if ( capabilities.isWebGL2 ) return 5131;

				extension = extensions.get( 'OES_texture_half_float' );

				if ( extension !== null ) return extension.HALF_FLOAT_OES;

			}

			if ( p === AlphaFormat ) return 6406;
			if ( p === RGBFormat ) return 6407;
			if ( p === RGBAFormat ) return 6408;
			if ( p === LuminanceFormat ) return 6409;
			if ( p === LuminanceAlphaFormat ) return 6410;
			if ( p === DepthFormat ) return 6402;
			if ( p === DepthStencilFormat ) return 34041;
			if ( p === RedFormat ) return 6403;

			if ( p === AddEquation ) return 32774;
			if ( p === SubtractEquation ) return 32778;
			if ( p === ReverseSubtractEquation ) return 32779;

			if ( p === ZeroFactor ) return 0;
			if ( p === OneFactor ) return 1;
			if ( p === SrcColorFactor ) return 768;
			if ( p === OneMinusSrcColorFactor ) return 769;
			if ( p === SrcAlphaFactor ) return 770;
			if ( p === OneMinusSrcAlphaFactor ) return 771;
			if ( p === DstAlphaFactor ) return 772;
			if ( p === OneMinusDstAlphaFactor ) return 773;

			if ( p === DstColorFactor ) return 774;
			if ( p === OneMinusDstColorFactor ) return 775;
			if ( p === SrcAlphaSaturateFactor ) return 776;

			if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
				p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

				if ( extension !== null ) {

					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

				}

			}

			if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
				p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

				if ( extension !== null ) {

					if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

				}

			}

			if ( p === RGB_ETC1_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

				if ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;

			}

			if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
				p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
				p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
				p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
				p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_astc' );

				if ( extension !== null ) {

					return p;

				}

			}

			if ( p === MinEquation || p === MaxEquation ) {

				if ( capabilities.isWebGL2 ) {

					if ( p === MinEquation ) return 32775;
					if ( p === MaxEquation ) return 32776;

				}

				extension = extensions.get( 'EXT_blend_minmax' );

				if ( extension !== null ) {

					if ( p === MinEquation ) return extension.MIN_EXT;
					if ( p === MaxEquation ) return extension.MAX_EXT;

				}

			}

			if ( p === UnsignedInt248Type ) {

				if ( capabilities.isWebGL2 ) return 34042;

				extension = extensions.get( 'WEBGL_depth_texture' );

				if ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;

			}

			return 0;

		}

		return { convert: convert };

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Group() {

		Object3D.call( this );

		this.type = 'Group';

	}

	Group.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Group,

		isGroup: true

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	function Camera() {

		Object3D.call( this );

		this.type = 'Camera';

		this.matrixWorldInverse = new Matrix4();

		this.projectionMatrix = new Matrix4();
		this.projectionMatrixInverse = new Matrix4();

	}

	Camera.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Camera,

		isCamera: true,

		copy: function ( source, recursive ) {

			Object3D.prototype.copy.call( this, source, recursive );

			this.matrixWorldInverse.copy( source.matrixWorldInverse );

			this.projectionMatrix.copy( source.projectionMatrix );
			this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

			return this;

		},

		getWorldDirection: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Camera: .getWorldDirection() target is now required' );
				target = new Vector3();

			}

			this.updateMatrixWorld( true );

			var e = this.matrixWorld.elements;

			return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();

		},

		updateMatrixWorld: function ( force ) {

			Object3D.prototype.updateMatrixWorld.call( this, force );

			this.matrixWorldInverse.getInverse( this.matrixWorld );

		},

		clone: function () {

			return new this.constructor().copy( this );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author greggman / http://games.greggman.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author tschw
	 */

	function PerspectiveCamera( fov, aspect, near, far ) {

		Camera.call( this );

		this.type = 'PerspectiveCamera';

		this.fov = fov !== undefined ? fov : 50;
		this.zoom = 1;

		this.near = near !== undefined ? near : 0.1;
		this.far = far !== undefined ? far : 2000;
		this.focus = 10;

		this.aspect = aspect !== undefined ? aspect : 1;
		this.view = null;

		this.filmGauge = 35;	// width of the film (default in millimeters)
		this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

		this.updateProjectionMatrix();

	}

	PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

		constructor: PerspectiveCamera,

		isPerspectiveCamera: true,

		copy: function ( source, recursive ) {

			Camera.prototype.copy.call( this, source, recursive );

			this.fov = source.fov;
			this.zoom = source.zoom;

			this.near = source.near;
			this.far = source.far;
			this.focus = source.focus;

			this.aspect = source.aspect;
			this.view = source.view === null ? null : Object.assign( {}, source.view );

			this.filmGauge = source.filmGauge;
			this.filmOffset = source.filmOffset;

			return this;

		},

		/**
		 * Sets the FOV by focal length in respect to the current .filmGauge.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * Values for focal length and film gauge must have the same unit.
		 */
		setFocalLength: function ( focalLength ) {

			// see http://www.bobatkins.com/photography/technical/field_of_view.html
			var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

			this.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );
			this.updateProjectionMatrix();

		},

		/**
		 * Calculates the focal length from the current .fov and .filmGauge.
		 */
		getFocalLength: function () {

			var vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );

			return 0.5 * this.getFilmHeight() / vExtentSlope;

		},

		getEffectiveFOV: function () {

			return _Math.RAD2DEG * 2 * Math.atan(
				Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );

		},

		getFilmWidth: function () {

			// film not completely covered in portrait format (aspect < 1)
			return this.filmGauge * Math.min( this.aspect, 1 );

		},

		getFilmHeight: function () {

			// film not completely covered in landscape format (aspect > 1)
			return this.filmGauge / Math.max( this.aspect, 1 );

		},

		/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *
		 *   +---+---+---+
		 *   | A | B | C |
		 *   +---+---+---+
		 *   | D | E | F |
		 *   +---+---+---+
		 *
		 * then for each monitor you would call it like this
		 *
		 *   var w = 1920;
		 *   var h = 1080;
		 *   var fullWidth = w * 3;
		 *   var fullHeight = h * 2;
		 *
		 *   --A--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 *   --B--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 *   --C--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 *   --D--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 *   --E--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 *   --F--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 *
		 *   Note there is no reason monitors have to be the same size or in a grid.
		 */
		setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

			this.aspect = fullWidth / fullHeight;

			if ( this.view === null ) {

				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};

			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;

			this.updateProjectionMatrix();

		},

		clearViewOffset: function () {

			if ( this.view !== null ) {

				this.view.enabled = false;

			}

			this.updateProjectionMatrix();

		},

		updateProjectionMatrix: function () {

			var near = this.near,
				top = near * Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,
				height = 2 * top,
				width = this.aspect * height,
				left = - 0.5 * width,
				view = this.view;

			if ( this.view !== null && this.view.enabled ) {

				var fullWidth = view.fullWidth,
					fullHeight = view.fullHeight;

				left += view.offsetX * width / fullWidth;
				top -= view.offsetY * height / fullHeight;
				width *= view.width / fullWidth;
				height *= view.height / fullHeight;

			}

			var skew = this.filmOffset;
			if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

			this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

			this.projectionMatrixInverse.getInverse( this.projectionMatrix );

		},

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			data.object.fov = this.fov;
			data.object.zoom = this.zoom;

			data.object.near = this.near;
			data.object.far = this.far;
			data.object.focus = this.focus;

			data.object.aspect = this.aspect;

			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

			data.object.filmGauge = this.filmGauge;
			data.object.filmOffset = this.filmOffset;

			return data;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function ArrayCamera( array ) {

		PerspectiveCamera.call( this );

		this.cameras = array || [];

	}

	ArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {

		constructor: ArrayCamera,

		isArrayCamera: true

	} );

	/**
	 * @author jsantell / https://www.jsantell.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	var cameraLPos = new Vector3();
	var cameraRPos = new Vector3();

	/**
	 * Assumes 2 cameras that are parallel and share an X-axis, and that
	 * the cameras' projection and world matrices have already been set.
	 * And that near and far planes are identical for both cameras.
	 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
	 */
	function setProjectionFromUnion( camera, cameraL, cameraR ) {

		cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
		cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

		var ipd = cameraLPos.distanceTo( cameraRPos );

		var projL = cameraL.projectionMatrix.elements;
		var projR = cameraR.projectionMatrix.elements;

		// VR systems will have identical far and near planes, and
		// most likely identical top and bottom frustum extents.
		// Use the left camera for these values.
		var near = projL[ 14 ] / ( projL[ 10 ] - 1 );
		var far = projL[ 14 ] / ( projL[ 10 ] + 1 );
		var topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
		var bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

		var leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
		var rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
		var left = near * leftFov;
		var right = near * rightFov;

		// Calculate the new camera's position offset from the
		// left camera. xOffset should be roughly half `ipd`.
		var zOffset = ipd / ( - leftFov + rightFov );
		var xOffset = zOffset * - leftFov;

		// TODO: Better way to apply this offset?
		cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
		camera.translateX( xOffset );
		camera.translateZ( zOffset );
		camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		// Find the union of the frustum values of the cameras and scale
		// the values so that the near plane's position does not change in world space,
		// although must now be relative to the new union camera.
		var near2 = near + zOffset;
		var far2 = far + zOffset;
		var left2 = left - xOffset;
		var right2 = right + ( ipd - xOffset );
		var top2 = topFov * far / far2 * near2;
		var bottom2 = bottomFov * far / far2 * near2;

		camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebVRManager( renderer ) {

		var scope = this;

		var device = null;
		var frameData = null;

		var poseTarget = null;

		var controllers = [];
		var standingMatrix = new Matrix4();
		var standingMatrixInverse = new Matrix4();

		var framebufferScaleFactor = 1.0;

		var frameOfReferenceType = 'stage';

		if ( typeof window !== 'undefined' && 'VRFrameData' in window ) {

			frameData = new window.VRFrameData();
			window.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false );

		}

		var matrixWorldInverse = new Matrix4();
		var tempQuaternion = new Quaternion();
		var tempPosition = new Vector3();

		var cameraL = new PerspectiveCamera();
		cameraL.bounds = new Vector4( 0.0, 0.0, 0.5, 1.0 );
		cameraL.layers.enable( 1 );

		var cameraR = new PerspectiveCamera();
		cameraR.bounds = new Vector4( 0.5, 0.0, 0.5, 1.0 );
		cameraR.layers.enable( 2 );

		var cameraVR = new ArrayCamera( [ cameraL, cameraR ] );
		cameraVR.layers.enable( 1 );
		cameraVR.layers.enable( 2 );

		//

		function isPresenting() {

			return device !== null && device.isPresenting === true;

		}

		var currentSize = new Vector2(), currentPixelRatio;

		function onVRDisplayPresentChange() {

			if ( isPresenting() ) {

				var eyeParameters = device.getEyeParameters( 'left' );
				var renderWidth = eyeParameters.renderWidth * framebufferScaleFactor;
				var renderHeight = eyeParameters.renderHeight * framebufferScaleFactor;

				currentPixelRatio = renderer.getPixelRatio();
				renderer.getSize( currentSize );

				renderer.setDrawingBufferSize( renderWidth * 2, renderHeight, 1 );

				animation.start();

			} else {

				if ( scope.enabled ) {

					renderer.setDrawingBufferSize( currentSize.width, currentSize.height, currentPixelRatio );

				}

				animation.stop();

			}

		}

		//

		var triggers = [];

		function findGamepad( id ) {

			var gamepads = navigator.getGamepads && navigator.getGamepads();

			for ( var i = 0, j = 0, l = gamepads.length; i < l; i ++ ) {

				var gamepad = gamepads[ i ];

				if ( gamepad && ( gamepad.id === 'Daydream Controller' ||
					gamepad.id === 'Gear VR Controller' || gamepad.id === 'Oculus Go Controller' ||
					gamepad.id === 'OpenVR Gamepad' || gamepad.id.startsWith( 'Oculus Touch' ) ||
					gamepad.id.startsWith( 'Spatial Controller' ) ) ) {

					if ( j === id ) return gamepad;

					j ++;

				}

			}

		}

		function updateControllers() {

			for ( var i = 0; i < controllers.length; i ++ ) {

				var controller = controllers[ i ];

				var gamepad = findGamepad( i );

				if ( gamepad !== undefined && gamepad.pose !== undefined ) {

					if ( gamepad.pose === null ) return;

					//  Pose

					var pose = gamepad.pose;

					if ( pose.hasPosition === false ) controller.position.set( 0.2, - 0.6, - 0.05 );

					if ( pose.position !== null ) controller.position.fromArray( pose.position );
					if ( pose.orientation !== null ) controller.quaternion.fromArray( pose.orientation );
					controller.matrix.compose( controller.position, controller.quaternion, controller.scale );
					controller.matrix.premultiply( standingMatrix );
					controller.matrix.decompose( controller.position, controller.quaternion, controller.scale );
					controller.matrixWorldNeedsUpdate = true;
					controller.visible = true;

					//  Trigger

					var buttonId = gamepad.id === 'Daydream Controller' ? 0 : 1;

					if ( triggers[ i ] !== gamepad.buttons[ buttonId ].pressed ) {

						triggers[ i ] = gamepad.buttons[ buttonId ].pressed;

						if ( triggers[ i ] === true ) {

							controller.dispatchEvent( { type: 'selectstart' } );

						} else {

							controller.dispatchEvent( { type: 'selectend' } );
							controller.dispatchEvent( { type: 'select' } );

						}

					}

				} else {

					controller.visible = false;

				}

			}

		}

		//

		this.enabled = false;

		this.getController = function ( id ) {

			var controller = controllers[ id ];

			if ( controller === undefined ) {

				controller = new Group();
				controller.matrixAutoUpdate = false;
				controller.visible = false;

				controllers[ id ] = controller;

			}

			return controller;

		};

		this.getDevice = function () {

			return device;

		};

		this.setDevice = function ( value ) {

			if ( value !== undefined ) device = value;

			animation.setContext( value );

		};

		this.setFramebufferScaleFactor = function ( value ) {

			framebufferScaleFactor = value;

		};

		this.setFrameOfReferenceType = function ( value ) {

			frameOfReferenceType = value;

		};

		this.setPoseTarget = function ( object ) {

			if ( object !== undefined ) poseTarget = object;

		};

		this.getCamera = function ( camera ) {

			var userHeight = frameOfReferenceType === 'stage' ? 1.6 : 0;

			if ( isPresenting() === false ) {

				camera.position.set( 0, userHeight, 0 );
				camera.rotation.set( 0, 0, 0 );

				return camera;

			}

			device.depthNear = camera.near;
			device.depthFar = camera.far;

			device.getFrameData( frameData );

			//

			if ( frameOfReferenceType === 'stage' ) {

				var stageParameters = device.stageParameters;

				if ( stageParameters ) {

					standingMatrix.fromArray( stageParameters.sittingToStandingTransform );

				} else {

					standingMatrix.makeTranslation( 0, userHeight, 0 );

				}

			}


			var pose = frameData.pose;
			var poseObject = poseTarget !== null ? poseTarget : camera;

			// We want to manipulate poseObject by its position and quaternion components since users may rely on them.
			poseObject.matrix.copy( standingMatrix );
			poseObject.matrix.decompose( poseObject.position, poseObject.quaternion, poseObject.scale );

			if ( pose.orientation !== null ) {

				tempQuaternion.fromArray( pose.orientation );
				poseObject.quaternion.multiply( tempQuaternion );

			}

			if ( pose.position !== null ) {

				tempQuaternion.setFromRotationMatrix( standingMatrix );
				tempPosition.fromArray( pose.position );
				tempPosition.applyQuaternion( tempQuaternion );
				poseObject.position.add( tempPosition );

			}

			poseObject.updateMatrixWorld();

			//

			cameraL.near = camera.near;
			cameraR.near = camera.near;

			cameraL.far = camera.far;
			cameraR.far = camera.far;

			cameraL.matrixWorldInverse.fromArray( frameData.leftViewMatrix );
			cameraR.matrixWorldInverse.fromArray( frameData.rightViewMatrix );

			// TODO (mrdoob) Double check this code

			standingMatrixInverse.getInverse( standingMatrix );

			if ( frameOfReferenceType === 'stage' ) {

				cameraL.matrixWorldInverse.multiply( standingMatrixInverse );
				cameraR.matrixWorldInverse.multiply( standingMatrixInverse );

			}

			var parent = poseObject.parent;

			if ( parent !== null ) {

				matrixWorldInverse.getInverse( parent.matrixWorld );

				cameraL.matrixWorldInverse.multiply( matrixWorldInverse );
				cameraR.matrixWorldInverse.multiply( matrixWorldInverse );

			}

			// envMap and Mirror needs camera.matrixWorld

			cameraL.matrixWorld.getInverse( cameraL.matrixWorldInverse );
			cameraR.matrixWorld.getInverse( cameraR.matrixWorldInverse );

			cameraL.projectionMatrix.fromArray( frameData.leftProjectionMatrix );
			cameraR.projectionMatrix.fromArray( frameData.rightProjectionMatrix );

			setProjectionFromUnion( cameraVR, cameraL, cameraR );

			//

			var layers = device.getLayers();

			if ( layers.length ) {

				var layer = layers[ 0 ];

				if ( layer.leftBounds !== null && layer.leftBounds.length === 4 ) {

					cameraL.bounds.fromArray( layer.leftBounds );

				}

				if ( layer.rightBounds !== null && layer.rightBounds.length === 4 ) {

					cameraR.bounds.fromArray( layer.rightBounds );

				}

			}

			updateControllers();

			return cameraVR;

		};

		this.getStandingMatrix = function () {

			return standingMatrix;

		};

		this.isPresenting = isPresenting;

		// Animation Loop

		var animation = new WebGLAnimation();

		this.setAnimationLoop = function ( callback ) {

			animation.setAnimationLoop( callback );

			if ( isPresenting() ) animation.start();

		};

		this.submitFrame = function () {

			if ( isPresenting() ) device.submitFrame();

		};

		this.dispose = function () {

			if ( typeof window !== 'undefined' ) {

				window.removeEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange );

			}

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebXRManager( renderer ) {

		var gl = renderer.context;

		var device = null;
		var session = null;

		var framebufferScaleFactor = 1.0;

		var frameOfReference = null;
		var frameOfReferenceType = 'stage';

		var pose = null;

		var controllers = [];
		var inputSources = [];

		function isPresenting() {

			return session !== null && frameOfReference !== null;

		}

		//

		var cameraL = new PerspectiveCamera();
		cameraL.layers.enable( 1 );
		cameraL.viewport = new Vector4();

		var cameraR = new PerspectiveCamera();
		cameraR.layers.enable( 2 );
		cameraR.viewport = new Vector4();

		var cameraVR = new ArrayCamera( [ cameraL, cameraR ] );
		cameraVR.layers.enable( 1 );
		cameraVR.layers.enable( 2 );

		//

		this.enabled = false;

		this.getController = function ( id ) {

			var controller = controllers[ id ];

			if ( controller === undefined ) {

				controller = new Group();
				controller.matrixAutoUpdate = false;
				controller.visible = false;

				controllers[ id ] = controller;

			}

			return controller;

		};

		this.getDevice = function () {

			return device;

		};

		this.setDevice = function ( value ) {

			if ( value !== undefined ) device = value;
			if ( value instanceof XRDevice ) gl.setCompatibleXRDevice( value );

		};

		//

		function onSessionEvent( event ) {

			var controller = controllers[ inputSources.indexOf( event.inputSource ) ];
			if ( controller ) controller.dispatchEvent( { type: event.type } );

		}

		function onSessionEnd() {

			renderer.setFramebuffer( null );
			renderer.setRenderTarget( renderer.getRenderTarget() ); // Hack #15830
			animation.stop();

		}

		this.setFramebufferScaleFactor = function ( value ) {

			framebufferScaleFactor = value;

		};

		this.setFrameOfReferenceType = function ( value ) {

			frameOfReferenceType = value;

		};

		this.setSession = function ( value ) {

			session = value;

			if ( session !== null ) {

				session.addEventListener( 'select', onSessionEvent );
				session.addEventListener( 'selectstart', onSessionEvent );
				session.addEventListener( 'selectend', onSessionEvent );
				session.addEventListener( 'end', onSessionEnd );

				session.baseLayer = new XRWebGLLayer( session, gl, { framebufferScaleFactor: framebufferScaleFactor } );
				session.requestFrameOfReference( frameOfReferenceType ).then( function ( value ) {

					frameOfReference = value;

					renderer.setFramebuffer( session.baseLayer.framebuffer );

					animation.setContext( session );
					animation.start();

				} );

				//

				inputSources = session.getInputSources();

				session.addEventListener( 'inputsourceschange', function () {

					inputSources = session.getInputSources();
					console.log( inputSources );

					for ( var i = 0; i < controllers.length; i ++ ) {

						var controller = controllers[ i ];
						controller.userData.inputSource = inputSources[ i ];

					}

				} );

			}

		};

		function updateCamera( camera, parent ) {

			if ( parent === null ) {

				camera.matrixWorld.copy( camera.matrix );

			} else {

				camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

			}

			camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		}

		this.getCamera = function ( camera ) {

			if ( isPresenting() ) {

				var parent = camera.parent;
				var cameras = cameraVR.cameras;

				updateCamera( cameraVR, parent );

				for ( var i = 0; i < cameras.length; i ++ ) {

					updateCamera( cameras[ i ], parent );

				}

				// update camera and its children

				camera.matrixWorld.copy( cameraVR.matrixWorld );

				var children = camera.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					children[ i ].updateMatrixWorld( true );

				}

				setProjectionFromUnion( cameraVR, cameraL, cameraR );

				return cameraVR;

			}

			return camera;

		};

		this.isPresenting = isPresenting;

		// Animation Loop

		var onAnimationFrameCallback = null;

		function onAnimationFrame( time, frame ) {

			pose = frame.getDevicePose( frameOfReference );

			if ( pose !== null ) {

				var layer = session.baseLayer;
				var views = frame.views;

				for ( var i = 0; i < views.length; i ++ ) {

					var view = views[ i ];
					var viewport = layer.getViewport( view );
					var viewMatrix = pose.getViewMatrix( view );

					var camera = cameraVR.cameras[ i ];
					camera.matrix.fromArray( viewMatrix ).getInverse( camera.matrix );
					camera.projectionMatrix.fromArray( view.projectionMatrix );
					camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

					if ( i === 0 ) {

						cameraVR.matrix.copy( camera.matrix );

					}

				}

			}

			//

			for ( var i = 0; i < controllers.length; i ++ ) {

				var controller = controllers[ i ];

				var inputSource = inputSources[ i ];

				if ( inputSource ) {

					var inputPose = frame.getInputPose( inputSource, frameOfReference );

					if ( inputPose !== null ) {

						if ( 'targetRay' in inputPose ) {

							controller.matrix.elements = inputPose.targetRay.transformMatrix;

						} else if ( 'pointerMatrix' in inputPose ) {

							// DEPRECATED

							controller.matrix.elements = inputPose.pointerMatrix;

						}

						controller.matrix.decompose( controller.position, controller.rotation, controller.scale );
						controller.visible = true;

						continue;

					}

				}

				controller.visible = false;

			}

			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

		}

		var animation = new WebGLAnimation();
		animation.setAnimationLoop( onAnimationFrame );

		this.setAnimationLoop = function ( callback ) {

			onAnimationFrameCallback = callback;

		};

		this.dispose = function () {};

		// DEPRECATED

		this.getStandingMatrix = function () {

			console.warn( 'THREE.WebXRManager: getStandingMatrix() is no longer needed.' );
			return new Matrix4();

		};

		this.submitFrame = function () {};

	}

	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 * @author tschw
	 */

	function WebGLRenderer( parameters ) {

		console.log( 'THREE.WebGLRenderer', REVISION );

		parameters = parameters || {};

		var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
			_context = parameters.context !== undefined ? parameters.context : null,

			_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
			_depth = parameters.depth !== undefined ? parameters.depth : true,
			_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
			_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
			_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
			_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
			_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default';

		var currentRenderList = null;
		var currentRenderState = null;

		// public properties

		this.domElement = _canvas;
		this.context = null;

		// clearing

		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;

		// scene graph

		this.sortObjects = true;

		// user-defined clipping

		this.clippingPlanes = [];
		this.localClippingEnabled = false;

		// physically based shading

		this.gammaFactor = 2.0;	// for backwards compatibility
		this.gammaInput = false;
		this.gammaOutput = false;

		// physical lights

		this.physicallyCorrectLights = false;

		// tone mapping

		this.toneMapping = LinearToneMapping;
		this.toneMappingExposure = 1.0;
		this.toneMappingWhitePoint = 1.0;

		// morphs

		this.maxMorphTargets = 8;
		this.maxMorphNormals = 4;

		// internal properties

		var _this = this,

			_isContextLost = false,

			// internal state cache

			_framebuffer = null,

			_currentRenderTarget = null,
			_currentFramebuffer = null,
			_currentMaterialId = - 1,

			// geometry and program caching

			_currentGeometryProgram = {
				geometry: null,
				program: null,
				wireframe: false
			},

			_currentCamera = null,
			_currentArrayCamera = null,

			_currentViewport = new Vector4(),
			_currentScissor = new Vector4(),
			_currentScissorTest = null,

			//

			_width = _canvas.width,
			_height = _canvas.height,

			_pixelRatio = 1,

			_viewport = new Vector4( 0, 0, _width, _height ),
			_scissor = new Vector4( 0, 0, _width, _height ),
			_scissorTest = false,

			// frustum

			_frustum = new Frustum(),

			// clipping

			_clipping = new WebGLClipping(),
			_clippingEnabled = false,
			_localClippingEnabled = false,

			// camera matrices cache

			_projScreenMatrix = new Matrix4(),

			_vector3 = new Vector3();

		function getTargetPixelRatio() {

			return _currentRenderTarget === null ? _pixelRatio : 1;

		}

		// initialize

		var _gl;

		try {

			var contextAttributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer,
				powerPreference: _powerPreference
			};

			// event listeners must be registered before WebGL context is created, see #12753

			_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
			_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );

			_gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );

			if ( _gl === null ) {

				if ( _canvas.getContext( 'webgl' ) !== null ) {

					throw new Error( 'Error creating WebGL context with your selected attributes.' );

				} else {

					throw new Error( 'Error creating WebGL context.' );

				}

			}

			// Some experimental-webgl implementations do not have getShaderPrecisionFormat

			if ( _gl.getShaderPrecisionFormat === undefined ) {

				_gl.getShaderPrecisionFormat = function () {

					return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

				};

			}

		} catch ( error ) {

			console.error( 'THREE.WebGLRenderer: ' + error.message );
			throw error;

		}

		var extensions, capabilities, state, info;
		var properties, textures, attributes, geometries, objects;
		var programCache, renderLists, renderStates;

		var background, morphtargets, bufferRenderer, indexedBufferRenderer;

		var utils;

		function initGLContext() {

			extensions = new WebGLExtensions( _gl );

			capabilities = new WebGLCapabilities( _gl, extensions, parameters );

			if ( ! capabilities.isWebGL2 ) {

				extensions.get( 'WEBGL_depth_texture' );
				extensions.get( 'OES_texture_float' );
				extensions.get( 'OES_texture_half_float' );
				extensions.get( 'OES_texture_half_float_linear' );
				extensions.get( 'OES_standard_derivatives' );
				extensions.get( 'OES_element_index_uint' );
				extensions.get( 'ANGLE_instanced_arrays' );

			}

			extensions.get( 'OES_texture_float_linear' );

			utils = new WebGLUtils( _gl, extensions, capabilities );

			state = new WebGLState( _gl, extensions, utils, capabilities );
			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

			info = new WebGLInfo( _gl );
			properties = new WebGLProperties();
			textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
			attributes = new WebGLAttributes( _gl );
			geometries = new WebGLGeometries( _gl, attributes, info );
			objects = new WebGLObjects( geometries, info );
			morphtargets = new WebGLMorphtargets( _gl );
			programCache = new WebGLPrograms( _this, extensions, capabilities, textures );
			renderLists = new WebGLRenderLists();
			renderStates = new WebGLRenderStates();

			background = new WebGLBackground( _this, state, objects, _premultipliedAlpha );

			bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );
			indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );

			info.programs = programCache.programs;

			_this.context = _gl;
			_this.capabilities = capabilities;
			_this.extensions = extensions;
			_this.properties = properties;
			_this.renderLists = renderLists;
			_this.state = state;
			_this.info = info;

		}

		initGLContext();

		// vr

		var vr = null;

		if ( typeof navigator !== 'undefined' ) {

			vr = ( 'xr' in navigator ) ? new WebXRManager( _this ) : new WebVRManager( _this );

		}

		this.vr = vr;

		// shadow map

		var shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );

		this.shadowMap = shadowMap;

		// API

		this.getContext = function () {

			return _gl;

		};

		this.getContextAttributes = function () {

			return _gl.getContextAttributes();

		};

		this.forceContextLoss = function () {

			var extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) extension.loseContext();

		};

		this.forceContextRestore = function () {

			var extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) extension.restoreContext();

		};

		this.getPixelRatio = function () {

			return _pixelRatio;

		};

		this.setPixelRatio = function ( value ) {

			if ( value === undefined ) return;

			_pixelRatio = value;

			this.setSize( _width, _height, false );

		};

		this.getSize = function ( target ) {

			if ( target === undefined ) {

				console.warn( 'WebGLRenderer: .getsize() now requires a Vector2 as an argument' );

				target = new Vector2();

			}

			return target.set( _width, _height );

		};

		this.setSize = function ( width, height, updateStyle ) {

			if ( vr.isPresenting() ) {

				console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
				return;

			}

			_width = width;
			_height = height;

			_canvas.width = width * _pixelRatio;
			_canvas.height = height * _pixelRatio;

			if ( updateStyle !== false ) {

				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';

			}

			this.setViewport( 0, 0, width, height );

		};

		this.getDrawingBufferSize = function ( target ) {

			if ( target === undefined ) {

				console.warn( 'WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument' );

				target = new Vector2();

			}

			return target.set( _width * _pixelRatio, _height * _pixelRatio );

		};

		this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

			_width = width;
			_height = height;

			_pixelRatio = pixelRatio;

			_canvas.width = width * pixelRatio;
			_canvas.height = height * pixelRatio;

			this.setViewport( 0, 0, width, height );

		};

		this.getCurrentViewport = function ( target ) {

			if ( target === undefined ) {

				console.warn( 'WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument' );

				target = new Vector4();

			}

			return target.copy( _currentViewport );

		};

		this.getViewport = function ( target ) {

			return target.copy( _viewport );

		};

		this.setViewport = function ( x, y, width, height ) {

			if ( x.isVector4 ) {

				_viewport.set( x.x, x.y, x.z, x.w );

			} else {

				_viewport.set( x, y, width, height );

			}

			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

		};

		this.getScissor = function ( target ) {

			return target.copy( _scissor );

		};

		this.setScissor = function ( x, y, width, height ) {

			if ( x.isVector4 ) {

				_scissor.set( x.x, x.y, x.z, x.w );

			} else {

				_scissor.set( x, y, width, height );

			}

			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );

		};

		this.getScissorTest = function () {

			return _scissorTest;

		};

		this.setScissorTest = function ( boolean ) {

			state.setScissorTest( _scissorTest = boolean );

		};

		// Clearing

		this.getClearColor = function () {

			return background.getClearColor();

		};

		this.setClearColor = function () {

			background.setClearColor.apply( background, arguments );

		};

		this.getClearAlpha = function () {

			return background.getClearAlpha();

		};

		this.setClearAlpha = function () {

			background.setClearAlpha.apply( background, arguments );

		};

		this.clear = function ( color, depth, stencil ) {

			var bits = 0;

			if ( color === undefined || color ) bits |= 16384;
			if ( depth === undefined || depth ) bits |= 256;
			if ( stencil === undefined || stencil ) bits |= 1024;

			_gl.clear( bits );

		};

		this.clearColor = function () {

			this.clear( true, false, false );

		};

		this.clearDepth = function () {

			this.clear( false, true, false );

		};

		this.clearStencil = function () {

			this.clear( false, false, true );

		};

		//

		this.dispose = function () {

			_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
			_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );

			renderLists.dispose();
			renderStates.dispose();
			properties.dispose();
			objects.dispose();

			vr.dispose();

			animation.stop();

		};

		// Events

		function onContextLost( event ) {

			event.preventDefault();

			console.log( 'THREE.WebGLRenderer: Context Lost.' );

			_isContextLost = true;

		}

		function onContextRestore( /* event */ ) {

			console.log( 'THREE.WebGLRenderer: Context Restored.' );

			_isContextLost = false;

			initGLContext();

		}

		function onMaterialDispose( event ) {

			var material = event.target;

			material.removeEventListener( 'dispose', onMaterialDispose );

			deallocateMaterial( material );

		}

		// Buffer deallocation

		function deallocateMaterial( material ) {

			releaseMaterialProgramReference( material );

			properties.remove( material );

		}


		function releaseMaterialProgramReference( material ) {

			var programInfo = properties.get( material ).program;

			material.program = undefined;

			if ( programInfo !== undefined ) {

				programCache.releaseProgram( programInfo );

			}

		}

		// Buffer rendering

		function renderObjectImmediate( object, program ) {

			object.render( function ( object ) {

				_this.renderBufferImmediate( object, program );

			} );

		}

		this.renderBufferImmediate = function ( object, program ) {

			state.initAttributes();

			var buffers = properties.get( object );

			if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
			if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
			if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
			if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

			var programAttributes = program.getAttributes();

			if ( object.hasPositions ) {

				_gl.bindBuffer( 34962, buffers.position );
				_gl.bufferData( 34962, object.positionArray, 35048 );

				state.enableAttribute( programAttributes.position );
				_gl.vertexAttribPointer( programAttributes.position, 3, 5126, false, 0, 0 );

			}

			if ( object.hasNormals ) {

				_gl.bindBuffer( 34962, buffers.normal );
				_gl.bufferData( 34962, object.normalArray, 35048 );

				state.enableAttribute( programAttributes.normal );
				_gl.vertexAttribPointer( programAttributes.normal, 3, 5126, false, 0, 0 );

			}

			if ( object.hasUvs ) {

				_gl.bindBuffer( 34962, buffers.uv );
				_gl.bufferData( 34962, object.uvArray, 35048 );

				state.enableAttribute( programAttributes.uv );
				_gl.vertexAttribPointer( programAttributes.uv, 2, 5126, false, 0, 0 );

			}

			if ( object.hasColors ) {

				_gl.bindBuffer( 34962, buffers.color );
				_gl.bufferData( 34962, object.colorArray, 35048 );

				state.enableAttribute( programAttributes.color );
				_gl.vertexAttribPointer( programAttributes.color, 3, 5126, false, 0, 0 );

			}

			state.disableUnusedAttributes();

			_gl.drawArrays( 4, 0, object.count );

			object.count = 0;

		};

		this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {

			var frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

			state.setMaterial( material, frontFaceCW );

			var program = setProgram( camera, fog, material, object );

			var updateBuffers = false;

			if ( _currentGeometryProgram.geometry !== geometry.id ||
				_currentGeometryProgram.program !== program.id ||
				_currentGeometryProgram.wireframe !== ( material.wireframe === true ) ) {

				_currentGeometryProgram.geometry = geometry.id;
				_currentGeometryProgram.program = program.id;
				_currentGeometryProgram.wireframe = material.wireframe === true;
				updateBuffers = true;

			}

			if ( object.morphTargetInfluences ) {

				morphtargets.update( object, geometry, material, program );

				updateBuffers = true;

			}

			//

			var index = geometry.index;
			var position = geometry.attributes.position;
			var rangeFactor = 1;

			if ( material.wireframe === true ) {

				index = geometries.getWireframeAttribute( geometry );
				rangeFactor = 2;

			}

			var attribute;
			var renderer = bufferRenderer;

			if ( index !== null ) {

				attribute = attributes.get( index );

				renderer = indexedBufferRenderer;
				renderer.setIndex( attribute );

			}

			if ( updateBuffers ) {

				setupVertexAttributes( material, program, geometry );

				if ( index !== null ) {

					_gl.bindBuffer( 34963, attribute.buffer );

				}

			}

			//

			var dataCount = Infinity;

			if ( index !== null ) {

				dataCount = index.count;

			} else if ( position !== undefined ) {

				dataCount = position.count;

			}

			var rangeStart = geometry.drawRange.start * rangeFactor;
			var rangeCount = geometry.drawRange.count * rangeFactor;

			var groupStart = group !== null ? group.start * rangeFactor : 0;
			var groupCount = group !== null ? group.count * rangeFactor : Infinity;

			var drawStart = Math.max( rangeStart, groupStart );
			var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

			var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

			if ( drawCount === 0 ) return;

			//

			if ( object.isMesh ) {

				if ( material.wireframe === true ) {

					state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
					renderer.setMode( 1 );

				} else {

					switch ( object.drawMode ) {

						case TrianglesDrawMode:
							renderer.setMode( 4 );
							break;

						case TriangleStripDrawMode:
							renderer.setMode( 5 );
							break;

						case TriangleFanDrawMode:
							renderer.setMode( 6 );
							break;

					}

				}


			} else if ( object.isLine ) {

				var lineWidth = material.linewidth;

				if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

				state.setLineWidth( lineWidth * getTargetPixelRatio() );

				if ( object.isLineSegments ) {

					renderer.setMode( 1 );

				} else if ( object.isLineLoop ) {

					renderer.setMode( 2 );

				} else {

					renderer.setMode( 3 );

				}

			} else if ( object.isPoints ) {

				renderer.setMode( 0 );

			} else if ( object.isSprite ) {

				renderer.setMode( 4 );

			}

			if ( geometry && geometry.isInstancedBufferGeometry ) {

				if ( geometry.maxInstancedCount > 0 ) {

					renderer.renderInstances( geometry, drawStart, drawCount );

				}

			} else {

				renderer.render( drawStart, drawCount );

			}

		};

		function setupVertexAttributes( material, program, geometry ) {

			if ( geometry && geometry.isInstancedBufferGeometry && ! capabilities.isWebGL2 ) {

				if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) {

					console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

			}

			state.initAttributes();

			var geometryAttributes = geometry.attributes;

			var programAttributes = program.getAttributes();

			var materialDefaultAttributeValues = material.defaultAttributeValues;

			for ( var name in programAttributes ) {

				var programAttribute = programAttributes[ name ];

				if ( programAttribute >= 0 ) {

					var geometryAttribute = geometryAttributes[ name ];

					if ( geometryAttribute !== undefined ) {

						var normalized = geometryAttribute.normalized;
						var size = geometryAttribute.itemSize;

						var attribute = attributes.get( geometryAttribute );

						// TODO Attribute may not be available on context restore

						if ( attribute === undefined ) continue;

						var buffer = attribute.buffer;
						var type = attribute.type;
						var bytesPerElement = attribute.bytesPerElement;

						if ( geometryAttribute.isInterleavedBufferAttribute ) {

							var data = geometryAttribute.data;
							var stride = data.stride;
							var offset = geometryAttribute.offset;

							if ( data && data.isInstancedInterleavedBuffer ) {

								state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );

								if ( geometry.maxInstancedCount === undefined ) {

									geometry.maxInstancedCount = data.meshPerAttribute * data.count;

								}

							} else {

								state.enableAttribute( programAttribute );

							}

							_gl.bindBuffer( 34962, buffer );
							_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement );

						} else {

							if ( geometryAttribute.isInstancedBufferAttribute ) {

								state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );

								if ( geometry.maxInstancedCount === undefined ) {

									geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

								}

							} else {

								state.enableAttribute( programAttribute );

							}

							_gl.bindBuffer( 34962, buffer );
							_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, 0 );

						}

					} else if ( materialDefaultAttributeValues !== undefined ) {

						var value = materialDefaultAttributeValues[ name ];

						if ( value !== undefined ) {

							switch ( value.length ) {

								case 2:
									_gl.vertexAttrib2fv( programAttribute, value );
									break;

								case 3:
									_gl.vertexAttrib3fv( programAttribute, value );
									break;

								case 4:
									_gl.vertexAttrib4fv( programAttribute, value );
									break;

								default:
									_gl.vertexAttrib1fv( programAttribute, value );

							}

						}

					}

				}

			}

			state.disableUnusedAttributes();

		}

		// Compile

		this.compile = function ( scene, camera ) {

			currentRenderState = renderStates.get( scene, camera );
			currentRenderState.init();

			scene.traverse( function ( object ) {

				if ( object.isLight ) {

					currentRenderState.pushLight( object );

					if ( object.castShadow ) {

						currentRenderState.pushShadow( object );

					}

				}

			} );

			currentRenderState.setupLights( camera );

			scene.traverse( function ( object ) {

				if ( object.material ) {

					if ( Array.isArray( object.material ) ) {

						for ( var i = 0; i < object.material.length; i ++ ) {

							initMaterial( object.material[ i ], scene.fog, object );

						}

					} else {

						initMaterial( object.material, scene.fog, object );

					}

				}

			} );

		};

		// Animation Loop

		var onAnimationFrameCallback = null;

		function onAnimationFrame( time ) {

			if ( vr.isPresenting() ) return;
			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

		}

		var animation = new WebGLAnimation();
		animation.setAnimationLoop( onAnimationFrame );

		if ( typeof window !== 'undefined' ) animation.setContext( window );

		this.setAnimationLoop = function ( callback ) {

			onAnimationFrameCallback = callback;
			vr.setAnimationLoop( callback );

			animation.start();

		};

		// Rendering

		this.render = function ( scene, camera ) {

			var renderTarget, forceClear;

			if ( arguments[ 2 ] !== undefined ) {

				console.warn( 'THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.' );
				renderTarget = arguments[ 2 ];

			}

			if ( arguments[ 3 ] !== undefined ) {

				console.warn( 'THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.' );
				forceClear = arguments[ 3 ];

			}

			if ( ! ( camera && camera.isCamera ) ) {

				console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
				return;

			}

			if ( _isContextLost ) return;

			// reset caching for this frame

			_currentGeometryProgram.geometry = null;
			_currentGeometryProgram.program = null;
			_currentGeometryProgram.wireframe = false;
			_currentMaterialId = - 1;
			_currentCamera = null;

			// update scene graph

			if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

			// update camera matrices and frustum

			if ( camera.parent === null ) camera.updateMatrixWorld();

			if ( vr.enabled ) {

				camera = vr.getCamera( camera );

			}

			//

			currentRenderState = renderStates.get( scene, camera );
			currentRenderState.init();

			scene.onBeforeRender( _this, scene, camera, renderTarget || _currentRenderTarget );

			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromMatrix( _projScreenMatrix );

			_localClippingEnabled = this.localClippingEnabled;
			_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

			currentRenderList = renderLists.get( scene, camera );
			currentRenderList.init();

			projectObject( scene, camera, 0, _this.sortObjects );

			if ( _this.sortObjects === true ) {

				currentRenderList.sort();

			}

			//

			if ( _clippingEnabled ) _clipping.beginShadows();

			var shadowsArray = currentRenderState.state.shadowsArray;

			shadowMap.render( shadowsArray, scene, camera );

			currentRenderState.setupLights( camera );

			if ( _clippingEnabled ) _clipping.endShadows();

			//

			if ( this.info.autoReset ) this.info.reset();

			if ( renderTarget !== undefined ) {

				this.setRenderTarget( renderTarget );

			}

			//

			background.render( currentRenderList, scene, camera, forceClear );

			// render scene

			var opaqueObjects = currentRenderList.opaque;
			var transparentObjects = currentRenderList.transparent;

			if ( scene.overrideMaterial ) {

				var overrideMaterial = scene.overrideMaterial;

				if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera, overrideMaterial );
				if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera, overrideMaterial );

			} else {

				// opaque pass (front-to-back order)

				if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera );

				// transparent pass (back-to-front order)

				if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera );

			}

			//

			scene.onAfterRender( _this, scene, camera );

			//

			if ( _currentRenderTarget !== null ) {

				// Generate mipmap if we're using any kind of mipmap filtering

				textures.updateRenderTargetMipmap( _currentRenderTarget );

				// resolve multisample renderbuffers to a single-sample texture if necessary

				textures.updateMultisampleRenderTarget( _currentRenderTarget );

			}

			// Ensure depth buffer writing is enabled so it can be cleared on next render

			state.buffers.depth.setTest( true );
			state.buffers.depth.setMask( true );
			state.buffers.color.setMask( true );

			state.setPolygonOffset( false );

			if ( vr.enabled ) {

				vr.submitFrame();

			}

			// _gl.finish();

			currentRenderList = null;
			currentRenderState = null;

		};

		function projectObject( object, camera, groupOrder, sortObjects ) {

			if ( object.visible === false ) return;

			var visible = object.layers.test( camera.layers );

			if ( visible ) {

				if ( object.isGroup ) {

					groupOrder = object.renderOrder;

				} else if ( object.isLight ) {

					currentRenderState.pushLight( object );

					if ( object.castShadow ) {

						currentRenderState.pushShadow( object );

					}

				} else if ( object.isSprite ) {

					if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

						if ( sortObjects ) {

							_vector3.setFromMatrixPosition( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );

						}

						var geometry = objects.update( object );
						var material = object.material;

						if ( material.visible ) {

							currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

						}

					}

				} else if ( object.isImmediateRenderObject ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					currentRenderList.push( object, null, object.material, groupOrder, _vector3.z, null );

				} else if ( object.isMesh || object.isLine || object.isPoints ) {

					if ( object.isSkinnedMesh ) {

						object.skeleton.update();

					}

					if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

						if ( sortObjects ) {

							_vector3.setFromMatrixPosition( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );

						}

						var geometry = objects.update( object );
						var material = object.material;

						if ( Array.isArray( material ) ) {

							var groups = geometry.groups;

							for ( var i = 0, l = groups.length; i < l; i ++ ) {

								var group = groups[ i ];
								var groupMaterial = material[ group.materialIndex ];

								if ( groupMaterial && groupMaterial.visible ) {

									currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );

								}

							}

						} else if ( material.visible ) {

							currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

						}

					}

				}

			}

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				projectObject( children[ i ], camera, groupOrder, sortObjects );

			}

		}

		function renderObjects( renderList, scene, camera, overrideMaterial ) {

			for ( var i = 0, l = renderList.length; i < l; i ++ ) {

				var renderItem = renderList[ i ];

				var object = renderItem.object;
				var geometry = renderItem.geometry;
				var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
				var group = renderItem.group;

				if ( camera.isArrayCamera ) {

					_currentArrayCamera = camera;

					var cameras = camera.cameras;

					for ( var j = 0, jl = cameras.length; j < jl; j ++ ) {

						var camera2 = cameras[ j ];

						if ( object.layers.test( camera2.layers ) ) {

							if ( 'viewport' in camera2 ) { // XR

								state.viewport( _currentViewport.copy( camera2.viewport ) );

							} else {

								var bounds = camera2.bounds;

								var x = bounds.x * _width;
								var y = bounds.y * _height;
								var width = bounds.z * _width;
								var height = bounds.w * _height;

								state.viewport( _currentViewport.set( x, y, width, height ).multiplyScalar( _pixelRatio ) );

							}

							currentRenderState.setupLights( camera2 );

							renderObject( object, scene, camera2, geometry, material, group );

						}

					}

				} else {

					_currentArrayCamera = null;

					renderObject( object, scene, camera, geometry, material, group );

				}

			}

		}

		function renderObject( object, scene, camera, geometry, material, group ) {

			object.onBeforeRender( _this, scene, camera, geometry, material, group );
			currentRenderState = renderStates.get( scene, _currentArrayCamera || camera );

			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

			if ( object.isImmediateRenderObject ) {

				state.setMaterial( material );

				var program = setProgram( camera, scene.fog, material, object );

				_currentGeometryProgram.geometry = null;
				_currentGeometryProgram.program = null;
				_currentGeometryProgram.wireframe = false;

				renderObjectImmediate( object, program );

			} else {

				_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );

			}

			object.onAfterRender( _this, scene, camera, geometry, material, group );
			currentRenderState = renderStates.get( scene, _currentArrayCamera || camera );

		}

		function initMaterial( material, fog, object ) {

			var materialProperties = properties.get( material );

			var lights = currentRenderState.state.lights;
			var shadowsArray = currentRenderState.state.shadowsArray;

			var lightsHash = materialProperties.lightsHash;
			var lightsStateHash = lights.state.hash;

			var parameters = programCache.getParameters(
				material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object );

			var code = programCache.getProgramCode( material, parameters );

			var program = materialProperties.program;
			var programChange = true;

			if ( program === undefined ) {

				// new material
				material.addEventListener( 'dispose', onMaterialDispose );

			} else if ( program.code !== code ) {

				// changed glsl or parameters
				releaseMaterialProgramReference( material );

			} else if ( lightsHash.stateID !== lightsStateHash.stateID ||
				lightsHash.directionalLength !== lightsStateHash.directionalLength ||
				lightsHash.pointLength !== lightsStateHash.pointLength ||
				lightsHash.spotLength !== lightsStateHash.spotLength ||
				lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength ||
				lightsHash.hemiLength !== lightsStateHash.hemiLength ||
				lightsHash.shadowsLength !== lightsStateHash.shadowsLength ) {

				lightsHash.stateID = lightsStateHash.stateID;
				lightsHash.directionalLength = lightsStateHash.directionalLength;
				lightsHash.pointLength = lightsStateHash.pointLength;
				lightsHash.spotLength = lightsStateHash.spotLength;
				lightsHash.rectAreaLength = lightsStateHash.rectAreaLength;
				lightsHash.hemiLength = lightsStateHash.hemiLength;
				lightsHash.shadowsLength = lightsStateHash.shadowsLength;

				programChange = false;

			} else if ( parameters.shaderID !== undefined ) {

				// same glsl and uniform list
				return;

			} else {

				// only rebuild uniform list
				programChange = false;

			}

			if ( programChange ) {

				if ( parameters.shaderID ) {

					var shader = ShaderLib[ parameters.shaderID ];

					materialProperties.shader = {
						name: material.type,
						uniforms: cloneUniforms( shader.uniforms ),
						vertexShader: shader.vertexShader,
						fragmentShader: shader.fragmentShader
					};

				} else {

					materialProperties.shader = {
						name: material.type,
						uniforms: material.uniforms,
						vertexShader: material.vertexShader,
						fragmentShader: material.fragmentShader
					};

				}

				material.onBeforeCompile( materialProperties.shader, _this );

				// Computing code again as onBeforeCompile may have changed the shaders
				code = programCache.getProgramCode( material, parameters );

				program = programCache.acquireProgram( material, materialProperties.shader, parameters, code );

				materialProperties.program = program;
				material.program = program;

			}

			var programAttributes = program.getAttributes();

			if ( material.morphTargets ) {

				material.numSupportedMorphTargets = 0;

				for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

					if ( programAttributes[ 'morphTarget' + i ] >= 0 ) {

						material.numSupportedMorphTargets ++;

					}

				}

			}

			if ( material.morphNormals ) {

				material.numSupportedMorphNormals = 0;

				for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {

					if ( programAttributes[ 'morphNormal' + i ] >= 0 ) {

						material.numSupportedMorphNormals ++;

					}

				}

			}

			var uniforms = materialProperties.shader.uniforms;

			if ( ! material.isShaderMaterial &&
				! material.isRawShaderMaterial ||
				material.clipping === true ) {

				materialProperties.numClippingPlanes = _clipping.numPlanes;
				materialProperties.numIntersection = _clipping.numIntersection;
				uniforms.clippingPlanes = _clipping.uniform;

			}

			materialProperties.fog = fog;

			// store the light setup it was created for
			if ( lightsHash === undefined ) {

				materialProperties.lightsHash = lightsHash = {};

			}

			lightsHash.stateID = lightsStateHash.stateID;
			lightsHash.directionalLength = lightsStateHash.directionalLength;
			lightsHash.pointLength = lightsStateHash.pointLength;
			lightsHash.spotLength = lightsStateHash.spotLength;
			lightsHash.rectAreaLength = lightsStateHash.rectAreaLength;
			lightsHash.hemiLength = lightsStateHash.hemiLength;
			lightsHash.shadowsLength = lightsStateHash.shadowsLength;

			if ( material.lights ) {

				// wire up the material to this renderer's lighting state

				uniforms.ambientLightColor.value = lights.state.ambient;
				uniforms.directionalLights.value = lights.state.directional;
				uniforms.spotLights.value = lights.state.spot;
				uniforms.rectAreaLights.value = lights.state.rectArea;
				uniforms.pointLights.value = lights.state.point;
				uniforms.hemisphereLights.value = lights.state.hemi;

				uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
				uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
				uniforms.spotShadowMap.value = lights.state.spotShadowMap;
				uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
				uniforms.pointShadowMap.value = lights.state.pointShadowMap;
				uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
				// TODO (abelnation): add area lights shadow info to uniforms

			}

			var progUniforms = materialProperties.program.getUniforms(),
				uniformsList =
					WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

			materialProperties.uniformsList = uniformsList;

		}

		function setProgram( camera, fog, material, object ) {

			textures.resetTextureUnits();

			var materialProperties = properties.get( material );
			var lights = currentRenderState.state.lights;

			var lightsHash = materialProperties.lightsHash;
			var lightsStateHash = lights.state.hash;

			if ( _clippingEnabled ) {

				if ( _localClippingEnabled || camera !== _currentCamera ) {

					var useCache =
						camera === _currentCamera &&
						material.id === _currentMaterialId;

					// we might want to call this function with some ClippingGroup
					// object instead of the material, once it becomes feasible
					// (#8465, #8379)
					_clipping.setState(
						material.clippingPlanes, material.clipIntersection, material.clipShadows,
						camera, materialProperties, useCache );

				}

			}

			if ( material.needsUpdate === false ) {

				if ( materialProperties.program === undefined ) {

					material.needsUpdate = true;

				} else if ( material.fog && materialProperties.fog !== fog ) {

					material.needsUpdate = true;

				} else if ( material.lights && ( lightsHash.stateID !== lightsStateHash.stateID ||
					lightsHash.directionalLength !== lightsStateHash.directionalLength ||
					lightsHash.pointLength !== lightsStateHash.pointLength ||
					lightsHash.spotLength !== lightsStateHash.spotLength ||
					lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength ||
					lightsHash.hemiLength !== lightsStateHash.hemiLength ||
					lightsHash.shadowsLength !== lightsStateHash.shadowsLength ) ) {

					material.needsUpdate = true;

				} else if ( materialProperties.numClippingPlanes !== undefined &&
					( materialProperties.numClippingPlanes !== _clipping.numPlanes ||
					materialProperties.numIntersection !== _clipping.numIntersection ) ) {

					material.needsUpdate = true;

				}

			}

			if ( material.needsUpdate ) {

				initMaterial( material, fog, object );
				material.needsUpdate = false;

			}

			var refreshProgram = false;
			var refreshMaterial = false;
			var refreshLights = false;

			var program = materialProperties.program,
				p_uniforms = program.getUniforms(),
				m_uniforms = materialProperties.shader.uniforms;

			if ( state.useProgram( program.program ) ) {

				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;

			}

			if ( material.id !== _currentMaterialId ) {

				_currentMaterialId = material.id;

				refreshMaterial = true;

			}

			if ( refreshProgram || _currentCamera !== camera ) {

				p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

				if ( capabilities.logarithmicDepthBuffer ) {

					p_uniforms.setValue( _gl, 'logDepthBufFC',
						2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

				}

				if ( _currentCamera !== camera ) {

					_currentCamera = camera;

					// lighting uniforms depend on the camera so enforce an update
					// now, in case this material supports lights - or later, when
					// the next material that does gets activated:

					refreshMaterial = true;		// set to true on material change
					refreshLights = true;		// remains set until update done

				}

				// load material specific uniforms
				// (shader material also gets them for the sake of genericity)

				if ( material.isShaderMaterial ||
					material.isMeshPhongMaterial ||
					material.isMeshStandardMaterial ||
					material.envMap ) {

					var uCamPos = p_uniforms.map.cameraPosition;

					if ( uCamPos !== undefined ) {

						uCamPos.setValue( _gl,
							_vector3.setFromMatrixPosition( camera.matrixWorld ) );

					}

				}

				if ( material.isMeshPhongMaterial ||
					material.isMeshLambertMaterial ||
					material.isMeshBasicMaterial ||
					material.isMeshStandardMaterial ||
					material.isShaderMaterial ||
					material.skinning ) {

					p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

				}

			}

			// skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// not sure why, but otherwise weird things happen

			if ( material.skinning ) {

				p_uniforms.setOptional( _gl, object, 'bindMatrix' );
				p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

				var skeleton = object.skeleton;

				if ( skeleton ) {

					var bones = skeleton.bones;

					if ( capabilities.floatVertexTextures ) {

						if ( skeleton.boneTexture === undefined ) {

							// layout (1 matrix = 4 pixels)
							//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
							//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
							//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
							//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
							//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


							var size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix
							size = _Math.ceilPowerOfTwo( size );
							size = Math.max( size, 4 );

							var boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
							boneMatrices.set( skeleton.boneMatrices ); // copy current values

							var boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );
							boneTexture.needsUpdate = true;

							skeleton.boneMatrices = boneMatrices;
							skeleton.boneTexture = boneTexture;
							skeleton.boneTextureSize = size;

						}

						p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );
						p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

					} else {

						p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

					}

				}

			}

			if ( refreshMaterial ) {

				p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );
				p_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint );

				if ( material.lights ) {

					// the current material requires lighting info

					// note: all lighting uniforms are always set correctly
					// they simply reference the renderer's state for their
					// values
					//
					// use the current material's .needsUpdate flags to set
					// the GL state when required

					markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

				}

				// refresh uniforms common to several materials

				if ( fog && material.fog ) {

					refreshUniformsFog( m_uniforms, fog );

				}

				if ( material.isMeshBasicMaterial ) {

					refreshUniformsCommon( m_uniforms, material );

				} else if ( material.isMeshLambertMaterial ) {

					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsLambert( m_uniforms, material );

				} else if ( material.isMeshPhongMaterial ) {

					refreshUniformsCommon( m_uniforms, material );

					if ( material.isMeshToonMaterial ) {

						refreshUniformsToon( m_uniforms, material );

					} else {

						refreshUniformsPhong( m_uniforms, material );

					}

				} else if ( material.isMeshStandardMaterial ) {

					refreshUniformsCommon( m_uniforms, material );

					if ( material.isMeshPhysicalMaterial ) {

						refreshUniformsPhysical( m_uniforms, material );

					} else {

						refreshUniformsStandard( m_uniforms, material );

					}

				} else if ( material.isMeshMatcapMaterial ) {

					refreshUniformsCommon( m_uniforms, material );

					refreshUniformsMatcap( m_uniforms, material );

				} else if ( material.isMeshDepthMaterial ) {

					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsDepth( m_uniforms, material );

				} else if ( material.isMeshDistanceMaterial ) {

					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsDistance( m_uniforms, material );

				} else if ( material.isMeshNormalMaterial ) {

					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsNormal( m_uniforms, material );

				} else if ( material.isLineBasicMaterial ) {

					refreshUniformsLine( m_uniforms, material );

					if ( material.isLineDashedMaterial ) {

						refreshUniformsDash( m_uniforms, material );

					}

				} else if ( material.isPointsMaterial ) {

					refreshUniformsPoints( m_uniforms, material );

				} else if ( material.isSpriteMaterial ) {

					refreshUniformsSprites( m_uniforms, material );

				} else if ( material.isShadowMaterial ) {

					m_uniforms.color.value = material.color;
					m_uniforms.opacity.value = material.opacity;

				}

				// RectAreaLight Texture
				// TODO (mrdoob): Find a nicer implementation

				if ( m_uniforms.ltc_1 !== undefined ) m_uniforms.ltc_1.value = UniformsLib.LTC_1;
				if ( m_uniforms.ltc_2 !== undefined ) m_uniforms.ltc_2.value = UniformsLib.LTC_2;

				WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );

			}

			if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

				WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );
				material.uniformsNeedUpdate = false;

			}

			if ( material.isSpriteMaterial ) {

				p_uniforms.setValue( _gl, 'center', object.center );

			}

			// common matrices

			p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
			p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
			p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

			return program;

		}

		// Uniforms (refresh uniforms objects)

		function refreshUniformsCommon( uniforms, material ) {

			uniforms.opacity.value = material.opacity;

			if ( material.color ) {

				uniforms.diffuse.value = material.color;

			}

			if ( material.emissive ) {

				uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

			}

			if ( material.map ) {

				uniforms.map.value = material.map;

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

			}

			if ( material.specularMap ) {

				uniforms.specularMap.value = material.specularMap;

			}

			if ( material.envMap ) {

				uniforms.envMap.value = material.envMap;

				// don't flip CubeTexture envMaps, flip everything else:
				//  WebGLRenderTargetCube will be flipped for backwards compatibility
				//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
				// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
				uniforms.flipEnvMap.value = material.envMap.isCubeTexture ? - 1 : 1;

				uniforms.reflectivity.value = material.reflectivity;
				uniforms.refractionRatio.value = material.refractionRatio;

				uniforms.maxMipLevel.value = properties.get( material.envMap ).__maxMipLevel;

			}

			if ( material.lightMap ) {

				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;

			}

			if ( material.aoMap ) {

				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;

			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. normal map
			// 4. bump map
			// 5. alpha map
			// 6. emissive map

			var uvScaleMap;

			if ( material.map ) {

				uvScaleMap = material.map;

			} else if ( material.specularMap ) {

				uvScaleMap = material.specularMap;

			} else if ( material.displacementMap ) {

				uvScaleMap = material.displacementMap;

			} else if ( material.normalMap ) {

				uvScaleMap = material.normalMap;

			} else if ( material.bumpMap ) {

				uvScaleMap = material.bumpMap;

			} else if ( material.roughnessMap ) {

				uvScaleMap = material.roughnessMap;

			} else if ( material.metalnessMap ) {

				uvScaleMap = material.metalnessMap;

			} else if ( material.alphaMap ) {

				uvScaleMap = material.alphaMap;

			} else if ( material.emissiveMap ) {

				uvScaleMap = material.emissiveMap;

			}

			if ( uvScaleMap !== undefined ) {

				// backwards compatibility
				if ( uvScaleMap.isWebGLRenderTarget ) {

					uvScaleMap = uvScaleMap.texture;

				}

				if ( uvScaleMap.matrixAutoUpdate === true ) {

					uvScaleMap.updateMatrix();

				}

				uniforms.uvTransform.value.copy( uvScaleMap.matrix );

			}

		}

		function refreshUniformsLine( uniforms, material ) {

			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;

		}

		function refreshUniformsDash( uniforms, material ) {

			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;

		}

		function refreshUniformsPoints( uniforms, material ) {

			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size * _pixelRatio;
			uniforms.scale.value = _height * 0.5;

			uniforms.map.value = material.map;

			if ( material.map !== null ) {

				if ( material.map.matrixAutoUpdate === true ) {

					material.map.updateMatrix();

				}

				uniforms.uvTransform.value.copy( material.map.matrix );

			}

		}

		function refreshUniformsSprites( uniforms, material ) {

			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;
			uniforms.rotation.value = material.rotation;
			uniforms.map.value = material.map;

			if ( material.map !== null ) {

				if ( material.map.matrixAutoUpdate === true ) {

					material.map.updateMatrix();

				}

				uniforms.uvTransform.value.copy( material.map.matrix );

			}

		}

		function refreshUniformsFog( uniforms, fog ) {

			uniforms.fogColor.value = fog.color;

			if ( fog.isFog ) {

				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;

			} else if ( fog.isFogExp2 ) {

				uniforms.fogDensity.value = fog.density;

			}

		}

		function refreshUniformsLambert( uniforms, material ) {

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

		}

		function refreshUniformsPhong( uniforms, material ) {

			uniforms.specular.value = material.specular;
			uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		function refreshUniformsToon( uniforms, material ) {

			refreshUniformsPhong( uniforms, material );

			if ( material.gradientMap ) {

				uniforms.gradientMap.value = material.gradientMap;

			}

		}

		function refreshUniformsStandard( uniforms, material ) {

			uniforms.roughness.value = material.roughness;
			uniforms.metalness.value = material.metalness;

			if ( material.roughnessMap ) {

				uniforms.roughnessMap.value = material.roughnessMap;

			}

			if ( material.metalnessMap ) {

				uniforms.metalnessMap.value = material.metalnessMap;

			}

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

			if ( material.envMap ) {

				//uniforms.envMap.value = material.envMap; // part of uniforms common
				uniforms.envMapIntensity.value = material.envMapIntensity;

			}

		}

		function refreshUniformsPhysical( uniforms, material ) {

			refreshUniformsStandard( uniforms, material );

			uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

			uniforms.clearCoat.value = material.clearCoat;
			uniforms.clearCoatRoughness.value = material.clearCoatRoughness;

		}

		function refreshUniformsMatcap( uniforms, material ) {

			if ( material.matcap ) {

				uniforms.matcap.value = material.matcap;

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		function refreshUniformsDepth( uniforms, material ) {

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		function refreshUniformsDistance( uniforms, material ) {

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

			uniforms.referencePosition.value.copy( material.referencePosition );
			uniforms.nearDistance.value = material.nearDistance;
			uniforms.farDistance.value = material.farDistance;

		}

		function refreshUniformsNormal( uniforms, material ) {

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		// If uniforms are marked as clean, they don't need to be loaded to the GPU.

		function markUniformsLightsNeedsUpdate( uniforms, value ) {

			uniforms.ambientLightColor.needsUpdate = value;

			uniforms.directionalLights.needsUpdate = value;
			uniforms.pointLights.needsUpdate = value;
			uniforms.spotLights.needsUpdate = value;
			uniforms.rectAreaLights.needsUpdate = value;
			uniforms.hemisphereLights.needsUpdate = value;

		}

		//

		this.setFramebuffer = function ( value ) {

			_framebuffer = value;

		};

		this.getRenderTarget = function () {

			return _currentRenderTarget;

		};

		this.setRenderTarget = function ( renderTarget, activeCubeFace, activeMipMapLevel ) {

			_currentRenderTarget = renderTarget;

			if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

				textures.setupRenderTarget( renderTarget );

			}

			var framebuffer = _framebuffer;
			var isCube = false;

			if ( renderTarget ) {

				var __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

				if ( renderTarget.isWebGLRenderTargetCube ) {

					framebuffer = __webglFramebuffer[ activeCubeFace || 0 ];
					isCube = true;

				} else if ( renderTarget.isWebGLMultisampleRenderTarget ) {

					framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

				} else {

					framebuffer = __webglFramebuffer;

				}

				_currentViewport.copy( renderTarget.viewport );
				_currentScissor.copy( renderTarget.scissor );
				_currentScissorTest = renderTarget.scissorTest;

			} else {

				_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );
				_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
				_currentScissorTest = _scissorTest;

			}

			if ( _currentFramebuffer !== framebuffer ) {

				_gl.bindFramebuffer( 36160, framebuffer );
				_currentFramebuffer = framebuffer;

			}

			state.viewport( _currentViewport );
			state.scissor( _currentScissor );
			state.setScissorTest( _currentScissorTest );

			if ( isCube ) {

				var textureProperties = properties.get( renderTarget.texture );
				_gl.framebufferTexture2D( 36160, 36064, 34069 + ( activeCubeFace || 0 ), textureProperties.__webglTexture, activeMipMapLevel || 0 );

			}

		};

		this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {

			if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
				return;

			}

			var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

			if ( framebuffer ) {

				var restore = false;

				if ( framebuffer !== _currentFramebuffer ) {

					_gl.bindFramebuffer( 36160, framebuffer );

					restore = true;

				}

				try {

					var texture = renderTarget.texture;
					var textureFormat = texture.format;
					var textureType = texture.type;

					if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( 35739 ) ) {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
						return;

					}

					if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( 35738 ) && // IE11, Edge and Chrome Mac < 52 (#9513)
						! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
						! ( textureType === HalfFloatType && ( capabilities.isWebGL2 ? extensions.get( 'EXT_color_buffer_float' ) : extensions.get( 'EXT_color_buffer_half_float' ) ) ) ) {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
						return;

					}

					if ( _gl.checkFramebufferStatus( 36160 ) === 36053 ) {

						// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

						if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

							_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

						}

					} else {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

					}

				} finally {

					if ( restore ) {

						_gl.bindFramebuffer( 36160, _currentFramebuffer );

					}

				}

			}

		};

		this.copyFramebufferToTexture = function ( position, texture, level ) {

			var width = texture.image.width;
			var height = texture.image.height;
			var glFormat = utils.convert( texture.format );

			textures.setTexture2D( texture, 0 );

			_gl.copyTexImage2D( 3553, level || 0, glFormat, position.x, position.y, width, height, 0 );

		};

		this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level ) {

			var width = srcTexture.image.width;
			var height = srcTexture.image.height;
			var glFormat = utils.convert( dstTexture.format );
			var glType = utils.convert( dstTexture.type );

			textures.setTexture2D( dstTexture, 0 );

			if ( srcTexture.isDataTexture ) {

				_gl.texSubImage2D( 3553, level || 0, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );

			} else {

				_gl.texSubImage2D( 3553, level || 0, position.x, position.y, glFormat, glType, srcTexture.image );

			}

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function FogExp2( color, density ) {

		this.name = '';

		this.color = new Color( color );
		this.density = ( density !== undefined ) ? density : 0.00025;

	}

	Object.assign( FogExp2.prototype, {

		isFogExp2: true,

		clone: function () {

			return new FogExp2( this.color, this.density );

		},

		toJSON: function ( /* meta */ ) {

			return {
				type: 'FogExp2',
				color: this.color.getHex(),
				density: this.density
			};

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Fog( color, near, far ) {

		this.name = '';

		this.color = new Color( color );

		this.near = ( near !== undefined ) ? near : 1;
		this.far = ( far !== undefined ) ? far : 1000;

	}

	Object.assign( Fog.prototype, {

		isFog: true,

		clone: function () {

			return new Fog( this.color, this.near, this.far );

		},

		toJSON: function ( /* meta */ ) {

			return {
				type: 'Fog',
				color: this.color.getHex(),
				near: this.near,
				far: this.far
			};

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Scene() {

		Object3D.call( this );

		this.type = 'Scene';

		this.background = null;
		this.fog = null;
		this.overrideMaterial = null;

		this.autoUpdate = true; // checked by the renderer

	}

	Scene.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Scene,

		isScene: true,

		copy: function ( source, recursive ) {

			Object3D.prototype.copy.call( this, source, recursive );

			if ( source.background !== null ) this.background = source.background.clone();
			if ( source.fog !== null ) this.fog = source.fog.clone();
			if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

			this.autoUpdate = source.autoUpdate;
			this.matrixAutoUpdate = source.matrixAutoUpdate;

			return this;

		},

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
			if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

			return data;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InterleavedBuffer( array, stride ) {

		this.array = array;
		this.stride = stride;
		this.count = array !== undefined ? array.length / stride : 0;

		this.dynamic = false;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

	}

	Object.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {

		set: function ( value ) {

			if ( value === true ) this.version ++;

		}

	} );

	Object.assign( InterleavedBuffer.prototype, {

		isInterleavedBuffer: true,

		onUploadCallback: function () {},

		setArray: function ( array ) {

			if ( Array.isArray( array ) ) {

				throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

			}

			this.count = array !== undefined ? array.length / this.stride : 0;
			this.array = array;

			return this;

		},

		setDynamic: function ( value ) {

			this.dynamic = value;

			return this;

		},

		copy: function ( source ) {

			this.array = new source.array.constructor( source.array );
			this.count = source.count;
			this.stride = source.stride;
			this.dynamic = source.dynamic;

			return this;

		},

		copyAt: function ( index1, attribute, index2 ) {

			index1 *= this.stride;
			index2 *= attribute.stride;

			for ( var i = 0, l = this.stride; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		},

		set: function ( value, offset ) {

			if ( offset === undefined ) offset = 0;

			this.array.set( value, offset );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		onUpload: function ( callback ) {

			this.onUploadCallback = callback;

			return this;

		}

	} );

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {

		this.data = interleavedBuffer;
		this.itemSize = itemSize;
		this.offset = offset;

		this.normalized = normalized === true;

	}

	Object.defineProperties( InterleavedBufferAttribute.prototype, {

		count: {

			get: function () {

				return this.data.count;

			}

		},

		array: {

			get: function () {

				return this.data.array;

			}

		}

	} );

	Object.assign( InterleavedBufferAttribute.prototype, {

		isInterleavedBufferAttribute: true,

		setX: function ( index, x ) {

			this.data.array[ index * this.data.stride + this.offset ] = x;

			return this;

		},

		setY: function ( index, y ) {

			this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

			return this;

		},

		setZ: function ( index, z ) {

			this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

			return this;

		},

		setW: function ( index, w ) {

			this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

			return this;

		},

		getX: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset ];

		},

		getY: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 1 ];

		},

		getZ: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 2 ];

		},

		getW: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 3 ];

		},

		setXY: function ( index, x, y ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;

			return this;

		},

		setXYZ: function ( index, x, y, z ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;

			return this;

		},

		setXYZW: function ( index, x, y, z, w ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;
			this.data.array[ index + 3 ] = w;

			return this;

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  map: new THREE.Texture( <Image> ),
	 *  rotation: <float>,
	 *  sizeAttenuation: <bool>
	 * }
	 */

	function SpriteMaterial( parameters ) {

		Material.call( this );

		this.type = 'SpriteMaterial';

		this.color = new Color( 0xffffff );
		this.map = null;

		this.rotation = 0;

		this.sizeAttenuation = true;

		this.lights = false;
		this.transparent = true;

		this.setValues( parameters );

	}

	SpriteMaterial.prototype = Object.create( Material.prototype );
	SpriteMaterial.prototype.constructor = SpriteMaterial;
	SpriteMaterial.prototype.isSpriteMaterial = true;

	SpriteMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );
		this.map = source.map;

		this.rotation = source.rotation;

		this.sizeAttenuation = source.sizeAttenuation;

		return this;

	};

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	var geometry;

	function Sprite( material ) {

		Object3D.call( this );

		this.type = 'Sprite';

		if ( geometry === undefined ) {

			geometry = new BufferGeometry();

			var float32Array = new Float32Array( [
				- 0.5, - 0.5, 0, 0, 0,
				0.5, - 0.5, 0, 1, 0,
				0.5, 0.5, 0, 1, 1,
				- 0.5, 0.5, 0, 0, 1
			] );

			var interleavedBuffer = new InterleavedBuffer( float32Array, 5 );

			geometry.setIndex( [ 0, 1, 2,	0, 2, 3 ] );
			geometry.addAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );
			geometry.addAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );

		}

		this.geometry = geometry;
		this.material = ( material !== undefined ) ? material : new SpriteMaterial();

		this.center = new Vector2( 0.5, 0.5 );

	}

	Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Sprite,

		isSprite: true,

		raycast: ( function () {

			var intersectPoint = new Vector3();
			var worldScale = new Vector3();
			var mvPosition = new Vector3();

			var alignedPosition = new Vector2();
			var rotatedPosition = new Vector2();
			var viewWorldMatrix = new Matrix4();

			var vA = new Vector3();
			var vB = new Vector3();
			var vC = new Vector3();

			var uvA = new Vector2();
			var uvB = new Vector2();
			var uvC = new Vector2();

			function transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {

				// compute position in camera space
				alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );

				// to check if rotation is not zero
				if ( sin !== undefined ) {

					rotatedPosition.x = ( cos * alignedPosition.x ) - ( sin * alignedPosition.y );
					rotatedPosition.y = ( sin * alignedPosition.x ) + ( cos * alignedPosition.y );

				} else {

					rotatedPosition.copy( alignedPosition );

				}


				vertexPosition.copy( mvPosition );
				vertexPosition.x += rotatedPosition.x;
				vertexPosition.y += rotatedPosition.y;

				// transform to world space
				vertexPosition.applyMatrix4( viewWorldMatrix );

			}

			return function raycast( raycaster, intersects ) {

				worldScale.setFromMatrixScale( this.matrixWorld );
				viewWorldMatrix.getInverse( this.modelViewMatrix ).premultiply( this.matrixWorld );
				mvPosition.setFromMatrixPosition( this.modelViewMatrix );

				var rotation = this.material.rotation;
				var sin, cos;
				if ( rotation !== 0 ) {

					cos = Math.cos( rotation );
					sin = Math.sin( rotation );

				}

				var center = this.center;

				transformVertex( vA.set( - 0.5, - 0.5, 0 ), mvPosition, center, worldScale, sin, cos );
				transformVertex( vB.set( 0.5, - 0.5, 0 ), mvPosition, center, worldScale, sin, cos );
				transformVertex( vC.set( 0.5, 0.5, 0 ), mvPosition, center, worldScale, sin, cos );

				uvA.set( 0, 0 );
				uvB.set( 1, 0 );
				uvC.set( 1, 1 );

				// check first triangle
				var intersect = raycaster.ray.intersectTriangle( vA, vB, vC, false, intersectPoint );

				if ( intersect === null ) {

					// check second triangle
					transformVertex( vB.set( - 0.5, 0.5, 0 ), mvPosition, center, worldScale, sin, cos );
					uvB.set( 0, 1 );

					intersect = raycaster.ray.intersectTriangle( vA, vC, vB, false, intersectPoint );
					if ( intersect === null ) {

						return;

					}

				}

				var distance = raycaster.ray.origin.distanceTo( intersectPoint );

				if ( distance < raycaster.near || distance > raycaster.far ) return;

				intersects.push( {

					distance: distance,
					point: intersectPoint.clone(),
					uv: Triangle.getUV( intersectPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2() ),
					face: null,
					object: this

				} );

			};

		}() ),

		clone: function () {

			return new this.constructor( this.material ).copy( this );

		},

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source );

			if ( source.center !== undefined ) this.center.copy( source.center );

			return this;

		}


	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	function LOD() {

		Object3D.call( this );

		this.type = 'LOD';

		Object.defineProperties( this, {
			levels: {
				enumerable: true,
				value: []
			}
		} );

	}

	LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: LOD,

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source, false );

			var levels = source.levels;

			for ( var i = 0, l = levels.length; i < l; i ++ ) {

				var level = levels[ i ];

				this.addLevel( level.object.clone(), level.distance );

			}

			return this;

		},

		addLevel: function ( object, distance ) {

			if ( distance === undefined ) distance = 0;

			distance = Math.abs( distance );

			var levels = this.levels;

			for ( var l = 0; l < levels.length; l ++ ) {

				if ( distance < levels[ l ].distance ) {

					break;

				}

			}

			levels.splice( l, 0, { distance: distance, object: object } );

			this.add( object );

		},

		getObjectForDistance: function ( distance ) {

			var levels = this.levels;

			for ( var i = 1, l = levels.length; i < l; i ++ ) {

				if ( distance < levels[ i ].distance ) {

					break;

				}

			}

			return levels[ i - 1 ].object;

		},

		raycast: ( function () {

			var matrixPosition = new Vector3();

			return function raycast( raycaster, intersects ) {

				matrixPosition.setFromMatrixPosition( this.matrixWorld );

				var distance = raycaster.ray.origin.distanceTo( matrixPosition );

				this.getObjectForDistance( distance ).raycast( raycaster, intersects );

			};

		}() ),

		update: function () {

			var v1 = new Vector3();
			var v2 = new Vector3();

			return function update( camera ) {

				var levels = this.levels;

				if ( levels.length > 1 ) {

					v1.setFromMatrixPosition( camera.matrixWorld );
					v2.setFromMatrixPosition( this.matrixWorld );

					var distance = v1.distanceTo( v2 );

					levels[ 0 ].object.visible = true;

					for ( var i = 1, l = levels.length; i < l; i ++ ) {

						if ( distance >= levels[ i ].distance ) {

							levels[ i - 1 ].object.visible = false;
							levels[ i ].object.visible = true;

						} else {

							break;

						}

					}

					for ( ; i < l; i ++ ) {

						levels[ i ].object.visible = false;

					}

				}

			};

		}(),

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			data.object.levels = [];

			var levels = this.levels;

			for ( var i = 0, l = levels.length; i < l; i ++ ) {

				var level = levels[ i ];

				data.object.levels.push( {
					object: level.object.uuid,
					distance: level.distance
				} );

			}

			return data;

		}

	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */

	function SkinnedMesh( geometry, material ) {

		if ( geometry && geometry.isGeometry ) {

			console.error( 'THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		}

		Mesh.call( this, geometry, material );

		this.type = 'SkinnedMesh';

		this.bindMode = 'attached';
		this.bindMatrix = new Matrix4();
		this.bindMatrixInverse = new Matrix4();

	}

	SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

		constructor: SkinnedMesh,

		isSkinnedMesh: true,

		bind: function ( skeleton, bindMatrix ) {

			this.skeleton = skeleton;

			if ( bindMatrix === undefined ) {

				this.updateMatrixWorld( true );

				this.skeleton.calculateInverses();

				bindMatrix = this.matrixWorld;

			}

			this.bindMatrix.copy( bindMatrix );
			this.bindMatrixInverse.getInverse( bindMatrix );

		},

		pose: function () {

			this.skeleton.pose();

		},

		normalizeSkinWeights: function () {

			var vector = new Vector4();

			var skinWeight = this.geometry.attributes.skinWeight;

			for ( var i = 0, l = skinWeight.count; i < l; i ++ ) {

				vector.x = skinWeight.getX( i );
				vector.y = skinWeight.getY( i );
				vector.z = skinWeight.getZ( i );
				vector.w = skinWeight.getW( i );

				var scale = 1.0 / vector.manhattanLength();

				if ( scale !== Infinity ) {

					vector.multiplyScalar( scale );

				} else {

					vector.set( 1, 0, 0, 0 ); // do something reasonable

				}

				skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );

			}

		},

		updateMatrixWorld: function ( force ) {

			Mesh.prototype.updateMatrixWorld.call( this, force );

			if ( this.bindMode === 'attached' ) {

				this.bindMatrixInverse.getInverse( this.matrixWorld );

			} else if ( this.bindMode === 'detached' ) {

				this.bindMatrixInverse.getInverse( this.bindMatrix );

			} else {

				console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

			}

		},

		clone: function () {

			return new this.constructor( this.geometry, this.material ).copy( this );

		}

	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author michael guerrero / http://realitymeltdown.com
	 * @author ikerr / http://verold.com
	 */

	function Skeleton( bones, boneInverses ) {

		// copy the bone array

		bones = bones || [];

		this.bones = bones.slice( 0 );
		this.boneMatrices = new Float32Array( this.bones.length * 16 );

		// use the supplied bone inverses or calculate the inverses

		if ( boneInverses === undefined ) {

			this.calculateInverses();

		} else {

			if ( this.bones.length === boneInverses.length ) {

				this.boneInverses = boneInverses.slice( 0 );

			} else {

				console.warn( 'THREE.Skeleton boneInverses is the wrong length.' );

				this.boneInverses = [];

				for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

					this.boneInverses.push( new Matrix4() );

				}

			}

		}

	}

	Object.assign( Skeleton.prototype, {

		calculateInverses: function () {

			this.boneInverses = [];

			for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

				var inverse = new Matrix4();

				if ( this.bones[ i ] ) {

					inverse.getInverse( this.bones[ i ].matrixWorld );

				}

				this.boneInverses.push( inverse );

			}

		},

		pose: function () {

			var bone, i, il;

			// recover the bind-time world matrices

			for ( i = 0, il = this.bones.length; i < il; i ++ ) {

				bone = this.bones[ i ];

				if ( bone ) {

					bone.matrixWorld.getInverse( this.boneInverses[ i ] );

				}

			}

			// compute the local matrices, positions, rotations and scales

			for ( i = 0, il = this.bones.length; i < il; i ++ ) {

				bone = this.bones[ i ];

				if ( bone ) {

					if ( bone.parent && bone.parent.isBone ) {

						bone.matrix.getInverse( bone.parent.matrixWorld );
						bone.matrix.multiply( bone.matrixWorld );

					} else {

						bone.matrix.copy( bone.matrixWorld );

					}

					bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

				}

			}

		},

		update: ( function () {

			var offsetMatrix = new Matrix4();
			var identityMatrix = new Matrix4();

			return function update() {

				var bones = this.bones;
				var boneInverses = this.boneInverses;
				var boneMatrices = this.boneMatrices;
				var boneTexture = this.boneTexture;

				// flatten bone matrices to array

				for ( var i = 0, il = bones.length; i < il; i ++ ) {

					// compute the offset between the current and the original transform

					var matrix = bones[ i ] ? bones[ i ].matrixWorld : identityMatrix;

					offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
					offsetMatrix.toArray( boneMatrices, i * 16 );

				}

				if ( boneTexture !== undefined ) {

					boneTexture.needsUpdate = true;

				}

			};

		} )(),

		clone: function () {

			return new Skeleton( this.bones, this.boneInverses );

		},

		getBoneByName: function ( name ) {

			for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

				var bone = this.bones[ i ];

				if ( bone.name === name ) {

					return bone;

				}

			}

			return undefined;

		}

	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */

	function Bone() {

		Object3D.call( this );

		this.type = 'Bone';

	}

	Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Bone,

		isBone: true

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *  linecap: "round",
	 *  linejoin: "round"
	 * }
	 */

	function LineBasicMaterial( parameters ) {

		Material.call( this );

		this.type = 'LineBasicMaterial';

		this.color = new Color( 0xffffff );

		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';

		this.lights = false;

		this.setValues( parameters );

	}

	LineBasicMaterial.prototype = Object.create( Material.prototype );
	LineBasicMaterial.prototype.constructor = LineBasicMaterial;

	LineBasicMaterial.prototype.isLineBasicMaterial = true;

	LineBasicMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;

		return this;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Line( geometry, material, mode ) {

		if ( mode === 1 ) {

			console.error( 'THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.' );

		}

		Object3D.call( this );

		this.type = 'Line';

		this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
		this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );

	}

	Line.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Line,

		isLine: true,

		computeLineDistances: ( function () {

			var start = new Vector3();
			var end = new Vector3();

			return function computeLineDistances() {

				var geometry = this.geometry;

				if ( geometry.isBufferGeometry ) {

					// we assume non-indexed geometry

					if ( geometry.index === null ) {

						var positionAttribute = geometry.attributes.position;
						var lineDistances = [ 0 ];

						for ( var i = 1, l = positionAttribute.count; i < l; i ++ ) {

							start.fromBufferAttribute( positionAttribute, i - 1 );
							end.fromBufferAttribute( positionAttribute, i );

							lineDistances[ i ] = lineDistances[ i - 1 ];
							lineDistances[ i ] += start.distanceTo( end );

						}

						geometry.addAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

					} else {

						console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

					}

				} else if ( geometry.isGeometry ) {

					var vertices = geometry.vertices;
					var lineDistances = geometry.lineDistances;

					lineDistances[ 0 ] = 0;

					for ( var i = 1, l = vertices.length; i < l; i ++ ) {

						lineDistances[ i ] = lineDistances[ i - 1 ];
						lineDistances[ i ] += vertices[ i - 1 ].distanceTo( vertices[ i ] );

					}

				}

				return this;

			};

		}() ),

		raycast: ( function () {

			var inverseMatrix = new Matrix4();
			var ray = new Ray();
			var sphere = new Sphere();

			return function raycast( raycaster, intersects ) {

				var precision = raycaster.linePrecision;

				var geometry = this.geometry;
				var matrixWorld = this.matrixWorld;

				// Checking boundingSphere distance to ray

				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( matrixWorld );
				sphere.radius += precision;

				if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

				//

				inverseMatrix.getInverse( matrixWorld );
				ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

				var localPrecision = precision / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
				var localPrecisionSq = localPrecision * localPrecision;

				var vStart = new Vector3();
				var vEnd = new Vector3();
				var interSegment = new Vector3();
				var interRay = new Vector3();
				var step = ( this && this.isLineSegments ) ? 2 : 1;

				if ( geometry.isBufferGeometry ) {

					var index = geometry.index;
					var attributes = geometry.attributes;
					var positions = attributes.position.array;

					if ( index !== null ) {

						var indices = index.array;

						for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

							var a = indices[ i ];
							var b = indices[ i + 1 ];

							vStart.fromArray( positions, a * 3 );
							vEnd.fromArray( positions, b * 3 );

							var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

							if ( distSq > localPrecisionSq ) continue;

							interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

							var distance = raycaster.ray.origin.distanceTo( interRay );

							if ( distance < raycaster.near || distance > raycaster.far ) continue;

							intersects.push( {

								distance: distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4( this.matrixWorld ),
								index: i,
								face: null,
								faceIndex: null,
								object: this

							} );

						}

					} else {

						for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

							vStart.fromArray( positions, 3 * i );
							vEnd.fromArray( positions, 3 * i + 3 );

							var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

							if ( distSq > localPrecisionSq ) continue;

							interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

							var distance = raycaster.ray.origin.distanceTo( interRay );

							if ( distance < raycaster.near || distance > raycaster.far ) continue;

							intersects.push( {

								distance: distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4( this.matrixWorld ),
								index: i,
								face: null,
								faceIndex: null,
								object: this

							} );

						}

					}

				} else if ( geometry.isGeometry ) {

					var vertices = geometry.vertices;
					var nbVertices = vertices.length;

					for ( var i = 0; i < nbVertices - 1; i += step ) {

						var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

						if ( distSq > localPrecisionSq ) continue;

						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

						var distance = raycaster.ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				}

			};

		}() ),

		clone: function () {

			return new this.constructor( this.geometry, this.material ).copy( this );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function LineSegments( geometry, material ) {

		Line.call( this, geometry, material );

		this.type = 'LineSegments';

	}

	LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {

		constructor: LineSegments,

		isLineSegments: true,

		computeLineDistances: ( function () {

			var start = new Vector3();
			var end = new Vector3();

			return function computeLineDistances() {

				var geometry = this.geometry;

				if ( geometry.isBufferGeometry ) {

					// we assume non-indexed geometry

					if ( geometry.index === null ) {

						var positionAttribute = geometry.attributes.position;
						var lineDistances = [];

						for ( var i = 0, l = positionAttribute.count; i < l; i += 2 ) {

							start.fromBufferAttribute( positionAttribute, i );
							end.fromBufferAttribute( positionAttribute, i + 1 );

							lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
							lineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end );

						}

						geometry.addAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

					} else {

						console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

					}

				} else if ( geometry.isGeometry ) {

					var vertices = geometry.vertices;
					var lineDistances = geometry.lineDistances;

					for ( var i = 0, l = vertices.length; i < l; i += 2 ) {

						start.copy( vertices[ i ] );
						end.copy( vertices[ i + 1 ] );

						lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
						lineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end );

					}

				}

				return this;

			};

		}() )

	} );

	/**
	 * @author mgreter / http://github.com/mgreter
	 */

	function LineLoop( geometry, material ) {

		Line.call( this, geometry, material );

		this.type = 'LineLoop';

	}

	LineLoop.prototype = Object.assign( Object.create( Line.prototype ), {

		constructor: LineLoop,

		isLineLoop: true,

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  size: <float>,
	 *  sizeAttenuation: <bool>
	 *
	 *  morphTargets: <bool>
	 * }
	 */

	function PointsMaterial( parameters ) {

		Material.call( this );

		this.type = 'PointsMaterial';

		this.color = new Color( 0xffffff );

		this.map = null;

		this.size = 1;
		this.sizeAttenuation = true;

		this.morphTargets = false;

		this.lights = false;

		this.setValues( parameters );

	}

	PointsMaterial.prototype = Object.create( Material.prototype );
	PointsMaterial.prototype.constructor = PointsMaterial;

	PointsMaterial.prototype.isPointsMaterial = true;

	PointsMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.map = source.map;

		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;

		this.morphTargets = source.morphTargets;

		return this;

	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Points( geometry, material ) {

		Object3D.call( this );

		this.type = 'Points';

		this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
		this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );

	}

	Points.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Points,

		isPoints: true,

		raycast: ( function () {

			var inverseMatrix = new Matrix4();
			var ray = new Ray();
			var sphere = new Sphere();

			return function raycast( raycaster, intersects ) {

				var object = this;
				var geometry = this.geometry;
				var matrixWorld = this.matrixWorld;
				var threshold = raycaster.params.Points.threshold;

				// Checking boundingSphere distance to ray

				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( matrixWorld );
				sphere.radius += threshold;

				if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

				//

				inverseMatrix.getInverse( matrixWorld );
				ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

				var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
				var localThresholdSq = localThreshold * localThreshold;
				var position = new Vector3();
				var intersectPoint = new Vector3();

				function testPoint( point, index ) {

					var rayPointDistanceSq = ray.distanceSqToPoint( point );

					if ( rayPointDistanceSq < localThresholdSq ) {

						ray.closestPointToPoint( point, intersectPoint );
						intersectPoint.applyMatrix4( matrixWorld );

						var distance = raycaster.ray.origin.distanceTo( intersectPoint );

						if ( distance < raycaster.near || distance > raycaster.far ) return;

						intersects.push( {

							distance: distance,
							distanceToRay: Math.sqrt( rayPointDistanceSq ),
							point: intersectPoint.clone(),
							index: index,
							face: null,
							object: object

						} );

					}

				}

				if ( geometry.isBufferGeometry ) {

					var index = geometry.index;
					var attributes = geometry.attributes;
					var positions = attributes.position.array;

					if ( index !== null ) {

						var indices = index.array;

						for ( var i = 0, il = indices.length; i < il; i ++ ) {

							var a = indices[ i ];

							position.fromArray( positions, a * 3 );

							testPoint( position, a );

						}

					} else {

						for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

							position.fromArray( positions, i * 3 );

							testPoint( position, i );

						}

					}

				} else {

					var vertices = geometry.vertices;

					for ( var i = 0, l = vertices.length; i < l; i ++ ) {

						testPoint( vertices[ i ], i );

					}

				}

			};

		}() ),

		clone: function () {

			return new this.constructor( this.geometry, this.material ).copy( this );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.format = format !== undefined ? format : RGBFormat;

		this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
		this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;

		this.generateMipmaps = false;

	}

	VideoTexture.prototype = Object.assign( Object.create( Texture.prototype ), {

		constructor: VideoTexture,

		isVideoTexture: true,

		update: function () {

			var video = this.image;

			if ( video.readyState >= video.HAVE_CURRENT_DATA ) {

				this.needsUpdate = true;

			}

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

		Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.image = { width: width, height: height };
		this.mipmaps = mipmaps;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		this.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		this.generateMipmaps = false;

	}

	CompressedTexture.prototype = Object.create( Texture.prototype );
	CompressedTexture.prototype.constructor = CompressedTexture;

	CompressedTexture.prototype.isCompressedTexture = true;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.needsUpdate = true;

	}

	CanvasTexture.prototype = Object.create( Texture.prototype );
	CanvasTexture.prototype.constructor = CanvasTexture;
	CanvasTexture.prototype.isCanvasTexture = true;

	/**
	 * @author Matt DesLauriers / @mattdesl
	 * @author atix / arthursilber.de
	 */

	function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

		format = format !== undefined ? format : DepthFormat;

		if ( format !== DepthFormat && format !== DepthStencilFormat ) {

			throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

		}

		if ( type === undefined && format === DepthFormat ) type = UnsignedShortType;
		if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

		Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.image = { width: width, height: height };

		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

		this.flipY = false;
		this.generateMipmaps	= false;

	}

	DepthTexture.prototype = Object.create( Texture.prototype );
	DepthTexture.prototype.constructor = DepthTexture;
	DepthTexture.prototype.isDepthTexture = true;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function WireframeGeometry( geometry ) {

		BufferGeometry.call( this );

		this.type = 'WireframeGeometry';

		// buffer

		var vertices = [];

		// helper variables

		var i, j, l, o, ol;
		var edge = [ 0, 0 ], edges = {}, e, edge1, edge2;
		var key, keys = [ 'a', 'b', 'c' ];
		var vertex;

		// different logic for Geometry and BufferGeometry

		if ( geometry && geometry.isGeometry ) {

			// create a data structure that contains all edges without duplicates

			var faces = geometry.faces;

			for ( i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				for ( j = 0; j < 3; j ++ ) {

					edge1 = face[ keys[ j ] ];
					edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
					edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
					edge[ 1 ] = Math.max( edge1, edge2 );

					key = edge[ 0 ] + ',' + edge[ 1 ];

					if ( edges[ key ] === undefined ) {

						edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

					}

				}

			}

			// generate vertices

			for ( key in edges ) {

				e = edges[ key ];

				vertex = geometry.vertices[ e.index1 ];
				vertices.push( vertex.x, vertex.y, vertex.z );

				vertex = geometry.vertices[ e.index2 ];
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		} else if ( geometry && geometry.isBufferGeometry ) {

			var position, indices, groups;
			var group, start, count;
			var index1, index2;

			vertex = new Vector3();

			if ( geometry.index !== null ) {

				// indexed BufferGeometry

				position = geometry.attributes.position;
				indices = geometry.index;
				groups = geometry.groups;

				if ( groups.length === 0 ) {

					groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];

				}

				// create a data structure that contains all eges without duplicates

				for ( o = 0, ol = groups.length; o < ol; ++ o ) {

					group = groups[ o ];

					start = group.start;
					count = group.count;

					for ( i = start, l = ( start + count ); i < l; i += 3 ) {

						for ( j = 0; j < 3; j ++ ) {

							edge1 = indices.getX( i + j );
							edge2 = indices.getX( i + ( j + 1 ) % 3 );
							edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
							edge[ 1 ] = Math.max( edge1, edge2 );

							key = edge[ 0 ] + ',' + edge[ 1 ];

							if ( edges[ key ] === undefined ) {

								edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

							}

						}

					}

				}

				// generate vertices

				for ( key in edges ) {

					e = edges[ key ];

					vertex.fromBufferAttribute( position, e.index1 );
					vertices.push( vertex.x, vertex.y, vertex.z );

					vertex.fromBufferAttribute( position, e.index2 );
					vertices.push( vertex.x, vertex.y, vertex.z );

				}

			} else {

				// non-indexed BufferGeometry

				position = geometry.attributes.position;

				for ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {

					for ( j = 0; j < 3; j ++ ) {

						// three edges per triangle, an edge is represented as (index1, index2)
						// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

						index1 = 3 * i + j;
						vertex.fromBufferAttribute( position, index1 );
						vertices.push( vertex.x, vertex.y, vertex.z );

						index2 = 3 * i + ( ( j + 1 ) % 3 );
						vertex.fromBufferAttribute( position, index2 );
						vertices.push( vertex.x, vertex.y, vertex.z );

					}

				}

			}

		}

		// build geometry

		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

	}

	WireframeGeometry.prototype = Object.create( BufferGeometry.prototype );
	WireframeGeometry.prototype.constructor = WireframeGeometry;

	/**
	 * @author zz85 / https://github.com/zz85
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
	 */

	// ParametricGeometry

	function ParametricGeometry( func, slices, stacks ) {

		Geometry.call( this );

		this.type = 'ParametricGeometry';

		this.parameters = {
			func: func,
			slices: slices,
			stacks: stacks
		};

		this.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );
		this.mergeVertices();

	}

	ParametricGeometry.prototype = Object.create( Geometry.prototype );
	ParametricGeometry.prototype.constructor = ParametricGeometry;

	// ParametricBufferGeometry

	function ParametricBufferGeometry( func, slices, stacks ) {

		BufferGeometry.call( this );

		this.type = 'ParametricBufferGeometry';

		this.parameters = {
			func: func,
			slices: slices,
			stacks: stacks
		};

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		var EPS = 0.00001;

		var normal = new Vector3();

		var p0 = new Vector3(), p1 = new Vector3();
		var pu = new Vector3(), pv = new Vector3();

		var i, j;

		if ( func.length < 3 ) {

			console.error( 'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.' );

		}

		// generate vertices, normals and uvs

		var sliceCount = slices + 1;

		for ( i = 0; i <= stacks; i ++ ) {

			var v = i / stacks;

			for ( j = 0; j <= slices; j ++ ) {

				var u = j / slices;

				// vertex

				func( u, v, p0 );
				vertices.push( p0.x, p0.y, p0.z );

				// normal

				// approximate tangent vectors via finite differences

				if ( u - EPS >= 0 ) {

					func( u - EPS, v, p1 );
					pu.subVectors( p0, p1 );

				} else {

					func( u + EPS, v, p1 );
					pu.subVectors( p1, p0 );

				}

				if ( v - EPS >= 0 ) {

					func( u, v - EPS, p1 );
					pv.subVectors( p0, p1 );

				} else {

					func( u, v + EPS, p1 );
					pv.subVectors( p1, p0 );

				}

				// cross product of tangent vectors returns surface normal

				normal.crossVectors( pu, pv ).normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u, v );

			}

		}

		// generate indices

		for ( i = 0; i < stacks; i ++ ) {

			for ( j = 0; j < slices; j ++ ) {

				var a = i * sliceCount + j;
				var b = i * sliceCount + j + 1;
				var c = ( i + 1 ) * sliceCount + j + 1;
				var d = ( i + 1 ) * sliceCount + j;

				// faces one and two

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;

	/**
	 * @author clockworkgeek / https://github.com/clockworkgeek
	 * @author timothypratley / https://github.com/timothypratley
	 * @author WestLangley / http://github.com/WestLangley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// PolyhedronGeometry

	function PolyhedronGeometry( vertices, indices, radius, detail ) {

		Geometry.call( this );

		this.type = 'PolyhedronGeometry';

		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );
		this.mergeVertices();

	}

	PolyhedronGeometry.prototype = Object.create( Geometry.prototype );
	PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

	// PolyhedronBufferGeometry

	function PolyhedronBufferGeometry( vertices, indices, radius, detail ) {

		BufferGeometry.call( this );

		this.type = 'PolyhedronBufferGeometry';

		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		radius = radius || 1;
		detail = detail || 0;

		// default buffer data

		var vertexBuffer = [];
		var uvBuffer = [];

		// the subdivision creates the vertex buffer data

		subdivide( detail );

		// all vertices should lie on a conceptual sphere with a given radius

		appplyRadius( radius );

		// finally, create the uv data

		generateUVs();

		// build non-indexed geometry

		this.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );

		if ( detail === 0 ) {

			this.computeVertexNormals(); // flat normals

		} else {

			this.normalizeNormals(); // smooth normals

		}

		// helper functions

		function subdivide( detail ) {

			var a = new Vector3();
			var b = new Vector3();
			var c = new Vector3();

			// iterate over all faces and apply a subdivison with the given detail value

			for ( var i = 0; i < indices.length; i += 3 ) {

				// get the vertices of the face

				getVertexByIndex( indices[ i + 0 ], a );
				getVertexByIndex( indices[ i + 1 ], b );
				getVertexByIndex( indices[ i + 2 ], c );

				// perform subdivision

				subdivideFace( a, b, c, detail );

			}

		}

		function subdivideFace( a, b, c, detail ) {

			var cols = Math.pow( 2, detail );

			// we use this multidimensional array as a data structure for creating the subdivision

			var v = [];

			var i, j;

			// construct all of the vertices for this subdivision

			for ( i = 0; i <= cols; i ++ ) {

				v[ i ] = [];

				var aj = a.clone().lerp( c, i / cols );
				var bj = b.clone().lerp( c, i / cols );

				var rows = cols - i;

				for ( j = 0; j <= rows; j ++ ) {

					if ( j === 0 && i === cols ) {

						v[ i ][ j ] = aj;

					} else {

						v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

					}

				}

			}

			// construct all of the faces

			for ( i = 0; i < cols; i ++ ) {

				for ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

					var k = Math.floor( j / 2 );

					if ( j % 2 === 0 ) {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );
						pushVertex( v[ i ][ k ] );

					} else {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );

					}

				}

			}

		}

		function appplyRadius( radius ) {

			var vertex = new Vector3();

			// iterate over the entire buffer and apply the radius to each vertex

			for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				vertex.normalize().multiplyScalar( radius );

				vertexBuffer[ i + 0 ] = vertex.x;
				vertexBuffer[ i + 1 ] = vertex.y;
				vertexBuffer[ i + 2 ] = vertex.z;

			}

		}

		function generateUVs() {

			var vertex = new Vector3();

			for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				var u = azimuth( vertex ) / 2 / Math.PI + 0.5;
				var v = inclination( vertex ) / Math.PI + 0.5;
				uvBuffer.push( u, 1 - v );

			}

			correctUVs();

			correctSeam();

		}

		function correctSeam() {

			// handle case when face straddles the seam, see #3269

			for ( var i = 0; i < uvBuffer.length; i += 6 ) {

				// uv data of a single face

				var x0 = uvBuffer[ i + 0 ];
				var x1 = uvBuffer[ i + 2 ];
				var x2 = uvBuffer[ i + 4 ];

				var max = Math.max( x0, x1, x2 );
				var min = Math.min( x0, x1, x2 );

				// 0.9 is somewhat arbitrary

				if ( max > 0.9 && min < 0.1 ) {

					if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
					if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
					if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

				}

			}

		}

		function pushVertex( vertex ) {

			vertexBuffer.push( vertex.x, vertex.y, vertex.z );

		}

		function getVertexByIndex( index, vertex ) {

			var stride = index * 3;

			vertex.x = vertices[ stride + 0 ];
			vertex.y = vertices[ stride + 1 ];
			vertex.z = vertices[ stride + 2 ];

		}

		function correctUVs() {

			var a = new Vector3();
			var b = new Vector3();
			var c = new Vector3();

			var centroid = new Vector3();

			var uvA = new Vector2();
			var uvB = new Vector2();
			var uvC = new Vector2();

			for ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

				a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
				b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
				c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

				uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
				uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
				uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

				centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

				var azi = azimuth( centroid );

				correctUV( uvA, j + 0, a, azi );
				correctUV( uvB, j + 2, b, azi );
				correctUV( uvC, j + 4, c, azi );

			}

		}

		function correctUV( uv, stride, vector, azimuth ) {

			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

				uvBuffer[ stride ] = uv.x - 1;

			}

			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

				uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

			}

		}

		// Angle around the Y axis, counter-clockwise when looking from above.

		function azimuth( vector ) {

			return Math.atan2( vector.z, - vector.x );

		}


		// Angle above the XZ plane.

		function inclination( vector ) {

			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

		}

	}

	PolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// TetrahedronGeometry

	function TetrahedronGeometry( radius, detail ) {

		Geometry.call( this );

		this.type = 'TetrahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();

	}

	TetrahedronGeometry.prototype = Object.create( Geometry.prototype );
	TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;

	// TetrahedronBufferGeometry

	function TetrahedronBufferGeometry( radius, detail ) {

		var vertices = [
			1, 1, 1, 	- 1, - 1, 1, 	- 1, 1, - 1, 	1, - 1, - 1
		];

		var indices = [
			2, 1, 0, 	0, 3, 2,	1, 3, 0,	2, 3, 1
		];

		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'TetrahedronBufferGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	TetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
	TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// OctahedronGeometry

	function OctahedronGeometry( radius, detail ) {

		Geometry.call( this );

		this.type = 'OctahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();

	}

	OctahedronGeometry.prototype = Object.create( Geometry.prototype );
	OctahedronGeometry.prototype.constructor = OctahedronGeometry;

	// OctahedronBufferGeometry

	function OctahedronBufferGeometry( radius, detail ) {

		var vertices = [
			1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
			0, - 1, 0, 	0, 0, 1,	0, 0, - 1
		];

		var indices = [
			0, 2, 4,	0, 4, 3,	0, 3, 5,
			0, 5, 2,	1, 2, 5,	1, 5, 3,
			1, 3, 4,	1, 4, 2
		];

		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'OctahedronBufferGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	OctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
	OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// IcosahedronGeometry

	function IcosahedronGeometry( radius, detail ) {

		Geometry.call( this );

		this.type = 'IcosahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();

	}

	IcosahedronGeometry.prototype = Object.create( Geometry.prototype );
	IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;

	// IcosahedronBufferGeometry

	function IcosahedronBufferGeometry( radius, detail ) {

		var t = ( 1 + Math.sqrt( 5 ) ) / 2;

		var vertices = [
			- 1, t, 0, 	1, t, 0, 	- 1, - t, 0, 	1, - t, 0,
			 0, - 1, t, 	0, 1, t,	0, - 1, - t, 	0, 1, - t,
			 t, 0, - 1, 	t, 0, 1, 	- t, 0, - 1, 	- t, 0, 1
		];

		var indices = [
			 0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
			 1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
			 3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
			 4, 9, 5, 	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
		];

		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'IcosahedronBufferGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	IcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
	IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;

	/**
	 * @author Abe Pazos / https://hamoid.com
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// DodecahedronGeometry

	function DodecahedronGeometry( radius, detail ) {

		Geometry.call( this );

		this.type = 'DodecahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();

	}

	DodecahedronGeometry.prototype = Object.create( Geometry.prototype );
	DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;

	// DodecahedronBufferGeometry

	function DodecahedronBufferGeometry( radius, detail ) {

		var t = ( 1 + Math.sqrt( 5 ) ) / 2;
		var r = 1 / t;

		var vertices = [

			// (1, 1, 1)
			- 1, - 1, - 1,	- 1, - 1, 1,
			- 1, 1, - 1, - 1, 1, 1,
			1, - 1, - 1, 1, - 1, 1,
			1, 1, - 1, 1, 1, 1,

			// (0, 1/, )
			 0, - r, - t, 0, - r, t,
			 0, r, - t, 0, r, t,

			// (1/, , 0)
			- r, - t, 0, - r, t, 0,
			 r, - t, 0, r, t, 0,

			// (, 0, 1/)
			- t, 0, - r, t, 0, - r,
			- t, 0, r, t, 0, r
		];

		var indices = [
			3, 11, 7, 	3, 7, 15, 	3, 15, 13,
			7, 19, 17, 	7, 17, 6, 	7, 6, 15,
			17, 4, 8, 	17, 8, 10, 	17, 10, 6,
			8, 0, 16, 	8, 16, 2, 	8, 2, 10,
			0, 12, 1, 	0, 1, 18, 	0, 18, 16,
			6, 10, 2, 	6, 2, 13, 	6, 13, 15,
			2, 16, 18, 	2, 18, 3, 	2, 3, 13,
			18, 1, 9, 	18, 9, 11, 	18, 11, 3,
			4, 14, 12, 	4, 12, 0, 	4, 0, 8,
			11, 9, 5, 	11, 5, 19, 	11, 19, 7,
			19, 5, 14, 	19, 14, 4, 	19, 4, 17,
			1, 12, 14, 	1, 14, 5, 	1, 5, 9
		];

		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'DodecahedronBufferGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	DodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
	DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;

	/**
	 * @author oosmoxiecode / https://github.com/oosmoxiecode
	 * @author WestLangley / https://github.com/WestLangley
	 * @author zz85 / https://github.com/zz85
	 * @author miningold / https://github.com/miningold
	 * @author jonobr1 / https://github.com/jonobr1
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 */

	// TubeGeometry

	function TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {

		Geometry.call( this );

		this.type = 'TubeGeometry';

		this.parameters = {
			path: path,
			tubularSegments: tubularSegments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};

		if ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );

		var bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );

		// expose internals

		this.tangents = bufferGeometry.tangents;
		this.normals = bufferGeometry.normals;
		this.binormals = bufferGeometry.binormals;

		// create geometry

		this.fromBufferGeometry( bufferGeometry );
		this.mergeVertices();

	}

	TubeGeometry.prototype = Object.create( Geometry.prototype );
	TubeGeometry.prototype.constructor = TubeGeometry;

	// TubeBufferGeometry

	function TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {

		BufferGeometry.call( this );

		this.type = 'TubeBufferGeometry';

		this.parameters = {
			path: path,
			tubularSegments: tubularSegments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};

		tubularSegments = tubularSegments || 64;
		radius = radius || 1;
		radialSegments = radialSegments || 8;
		closed = closed || false;

		var frames = path.computeFrenetFrames( tubularSegments, closed );

		// expose internals

		this.tangents = frames.tangents;
		this.normals = frames.normals;
		this.binormals = frames.binormals;

		// helper variables

		var vertex = new Vector3();
		var normal = new Vector3();
		var uv = new Vector2();
		var P = new Vector3();

		var i, j;

		// buffer

		var vertices = [];
		var normals = [];
		var uvs = [];
		var indices = [];

		// create buffer data

		generateBufferData();

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// functions

		function generateBufferData() {

			for ( i = 0; i < tubularSegments; i ++ ) {

				generateSegment( i );

			}

			// if the geometry is not closed, generate the last row of vertices and normals
			// at the regular position on the given path
			//
			// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

			generateSegment( ( closed === false ) ? tubularSegments : 0 );

			// uvs are generated in a separate function.
			// this makes it easy compute correct values for closed geometries

			generateUVs();

			// finally create faces

			generateIndices();

		}

		function generateSegment( i ) {

			// we use getPointAt to sample evenly distributed points from the given path

			P = path.getPointAt( i / tubularSegments, P );

			// retrieve corresponding normal and binormal

			var N = frames.normals[ i ];
			var B = frames.binormals[ i ];

			// generate normals and vertices for the current segment

			for ( j = 0; j <= radialSegments; j ++ ) {

				var v = j / radialSegments * Math.PI * 2;

				var sin = Math.sin( v );
				var cos = - Math.cos( v );

				// normal

				normal.x = ( cos * N.x + sin * B.x );
				normal.y = ( cos * N.y + sin * B.y );
				normal.z = ( cos * N.z + sin * B.z );
				normal.normalize();

				normals.push( normal.x, normal.y, normal.z );

				// vertex

				vertex.x = P.x + radius * normal.x;
				vertex.y = P.y + radius * normal.y;
				vertex.z = P.z + radius * normal.z;

				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		}

		function generateIndices() {

			for ( j = 1; j <= tubularSegments; j ++ ) {

				for ( i = 1; i <= radialSegments; i ++ ) {

					var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
					var b = ( radialSegments + 1 ) * j + ( i - 1 );
					var c = ( radialSegments + 1 ) * j + i;
					var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

		}

		function generateUVs() {

			for ( i = 0; i <= tubularSegments; i ++ ) {

				for ( j = 0; j <= radialSegments; j ++ ) {

					uv.x = i / tubularSegments;
					uv.y = j / radialSegments;

					uvs.push( uv.x, uv.y );

				}

			}

		}

	}

	TubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;

	TubeBufferGeometry.prototype.toJSON = function () {

		var data = BufferGeometry.prototype.toJSON.call( this );

		data.path = this.parameters.path.toJSON();

		return data;

	};

	/**
	 * @author oosmoxiecode
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * based on http://www.blackpawn.com/texts/pqtorus/
	 */

	// TorusKnotGeometry

	function TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {

		Geometry.call( this );

		this.type = 'TorusKnotGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};

		if ( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );

		this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
		this.mergeVertices();

	}

	TorusKnotGeometry.prototype = Object.create( Geometry.prototype );
	TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;

	// TorusKnotBufferGeometry

	function TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {

		BufferGeometry.call( this );

		this.type = 'TorusKnotBufferGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};

		radius = radius || 1;
		tube = tube || 0.4;
		tubularSegments = Math.floor( tubularSegments ) || 64;
		radialSegments = Math.floor( radialSegments ) || 8;
		p = p || 2;
		q = q || 3;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var i, j;

		var vertex = new Vector3();
		var normal = new Vector3();

		var P1 = new Vector3();
		var P2 = new Vector3();

		var B = new Vector3();
		var T = new Vector3();
		var N = new Vector3();

		// generate vertices, normals and uvs

		for ( i = 0; i <= tubularSegments; ++ i ) {

			// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

			var u = i / tubularSegments * p * Math.PI * 2;

			// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
			// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

			calculatePositionOnCurve( u, p, q, radius, P1 );
			calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

			// calculate orthonormal basis

			T.subVectors( P2, P1 );
			N.addVectors( P2, P1 );
			B.crossVectors( T, N );
			N.crossVectors( B, T );

			// normalize B, N. T can be ignored, we don't use it

			B.normalize();
			N.normalize();

			for ( j = 0; j <= radialSegments; ++ j ) {

				// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
				// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

				var v = j / radialSegments * Math.PI * 2;
				var cx = - tube * Math.cos( v );
				var cy = tube * Math.sin( v );

				// now calculate the final vertex position.
				// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

				vertex.x = P1.x + ( cx * N.x + cy * B.x );
				vertex.y = P1.y + ( cx * N.y + cy * B.y );
				vertex.z = P1.z + ( cx * N.z + cy * B.z );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

				normal.subVectors( vertex, P1 ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( j = 1; j <= tubularSegments; j ++ ) {

			for ( i = 1; i <= radialSegments; i ++ ) {

				// indices

				var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
				var b = ( radialSegments + 1 ) * j + ( i - 1 );
				var c = ( radialSegments + 1 ) * j + i;
				var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// this function calculates the current position on the torus curve

		function calculatePositionOnCurve( u, p, q, radius, position ) {

			var cu = Math.cos( u );
			var su = Math.sin( u );
			var quOverP = q / p * u;
			var cs = Math.cos( quOverP );

			position.x = radius * ( 2 + cs ) * 0.5 * cu;
			position.y = radius * ( 2 + cs ) * su * 0.5;
			position.z = radius * Math.sin( quOverP ) * 0.5;

		}

	}

	TorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;

	/**
	 * @author oosmoxiecode
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// TorusGeometry

	function TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

		Geometry.call( this );

		this.type = 'TorusGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );
		this.mergeVertices();

	}

	TorusGeometry.prototype = Object.create( Geometry.prototype );
	TorusGeometry.prototype.constructor = TorusGeometry;

	// TorusBufferGeometry

	function TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

		BufferGeometry.call( this );

		this.type = 'TorusBufferGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		radius = radius || 1;
		tube = tube || 0.4;
		radialSegments = Math.floor( radialSegments ) || 8;
		tubularSegments = Math.floor( tubularSegments ) || 6;
		arc = arc || Math.PI * 2;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var center = new Vector3();
		var vertex = new Vector3();
		var normal = new Vector3();

		var j, i;

		// generate vertices, normals and uvs

		for ( j = 0; j <= radialSegments; j ++ ) {

			for ( i = 0; i <= tubularSegments; i ++ ) {

				var u = i / tubularSegments * arc;
				var v = j / radialSegments * Math.PI * 2;

				// vertex

				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = tube * Math.sin( v );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				center.x = radius * Math.cos( u );
				center.y = radius * Math.sin( u );
				normal.subVectors( vertex, center ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( j = 1; j <= radialSegments; j ++ ) {

			for ( i = 1; i <= tubularSegments; i ++ ) {

				// indices

				var a = ( tubularSegments + 1 ) * j + i - 1;
				var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
				var d = ( tubularSegments + 1 ) * j + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	TorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 * Port from https://github.com/mapbox/earcut (v2.1.2)
	 */

	var Earcut = {

		triangulate: function ( data, holeIndices, dim ) {

			dim = dim || 2;

			var hasHoles = holeIndices && holeIndices.length,
				outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length,
				outerNode = linkedList( data, 0, outerLen, dim, true ),
				triangles = [];

			if ( ! outerNode ) return triangles;

			var minX, minY, maxX, maxY, x, y, invSize;

			if ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );

			// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox

			if ( data.length > 80 * dim ) {

				minX = maxX = data[ 0 ];
				minY = maxY = data[ 1 ];

				for ( var i = dim; i < outerLen; i += dim ) {

					x = data[ i ];
					y = data[ i + 1 ];
					if ( x < minX ) minX = x;
					if ( y < minY ) minY = y;
					if ( x > maxX ) maxX = x;
					if ( y > maxY ) maxY = y;

				}

				// minX, minY and invSize are later used to transform coords into integers for z-order calculation

				invSize = Math.max( maxX - minX, maxY - minY );
				invSize = invSize !== 0 ? 1 / invSize : 0;

			}

			earcutLinked( outerNode, triangles, dim, minX, minY, invSize );

			return triangles;

		}

	};

	// create a circular doubly linked list from polygon points in the specified winding order

	function linkedList( data, start, end, dim, clockwise ) {

		var i, last;

		if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {

			for ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

		} else {

			for ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

		}

		if ( last && equals( last, last.next ) ) {

			removeNode( last );
			last = last.next;

		}

		return last;

	}

	// eliminate colinear or duplicate points

	function filterPoints( start, end ) {

		if ( ! start ) return start;
		if ( ! end ) end = start;

		var p = start, again;

		do {

			again = false;

			if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {

				removeNode( p );
				p = end = p.prev;
				if ( p === p.next ) break;
				again = true;

			} else {

				p = p.next;

			}

		} while ( again || p !== end );

		return end;

	}

	// main ear slicing loop which triangulates a polygon (given as a linked list)

	function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {

		if ( ! ear ) return;

		// interlink polygon nodes in z-order

		if ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );

		var stop = ear, prev, next;

		// iterate through ears, slicing them one by one

		while ( ear.prev !== ear.next ) {

			prev = ear.prev;
			next = ear.next;

			if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {

				// cut off the triangle
				triangles.push( prev.i / dim );
				triangles.push( ear.i / dim );
				triangles.push( next.i / dim );

				removeNode( ear );

				// skipping the next vertice leads to less sliver triangles
				ear = next.next;
				stop = next.next;

				continue;

			}

			ear = next;

			// if we looped through the whole remaining polygon and can't find any more ears

			if ( ear === stop ) {

				// try filtering points and slicing again

				if ( ! pass ) {

					earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );

					// if this didn't work, try curing all small self-intersections locally

				} else if ( pass === 1 ) {

					ear = cureLocalIntersections( ear, triangles, dim );
					earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );

					// as a last resort, try splitting the remaining polygon into two

				} else if ( pass === 2 ) {

					splitEarcut( ear, triangles, dim, minX, minY, invSize );

				}

				break;

			}

		}

	}

	// check whether a polygon node forms a valid ear with adjacent nodes

	function isEar( ear ) {

		var a = ear.prev,
			b = ear,
			c = ear.next;

		if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

		// now make sure we don't have other points inside the potential ear
		var p = ear.next.next;

		while ( p !== ear.prev ) {

			if ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) {

				return false;

			}

			p = p.next;

		}

		return true;

	}

	function isEarHashed( ear, minX, minY, invSize ) {

		var a = ear.prev,
			b = ear,
			c = ear.next;

		if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

		// triangle bbox; min & max are calculated like this for speed

		var minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),
			minTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),
			maxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),
			maxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );

		// z-order range for the current triangle bbox;

		var minZ = zOrder( minTX, minTY, minX, minY, invSize ),
			maxZ = zOrder( maxTX, maxTY, minX, minY, invSize );

		// first look for points inside the triangle in increasing z-order

		var p = ear.nextZ;

		while ( p && p.z <= maxZ ) {

			if ( p !== ear.prev && p !== ear.next &&
					pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
					area( p.prev, p, p.next ) >= 0 ) return false;
			p = p.nextZ;

		}

		// then look for points in decreasing z-order

		p = ear.prevZ;

		while ( p && p.z >= minZ ) {

			if ( p !== ear.prev && p !== ear.next &&
					pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
					area( p.prev, p, p.next ) >= 0 ) return false;

			p = p.prevZ;

		}

		return true;

	}

	// go through all polygon nodes and cure small local self-intersections

	function cureLocalIntersections( start, triangles, dim ) {

		var p = start;

		do {

			var a = p.prev, b = p.next.next;

			if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {

				triangles.push( a.i / dim );
				triangles.push( p.i / dim );
				triangles.push( b.i / dim );

				// remove two nodes involved

				removeNode( p );
				removeNode( p.next );

				p = start = b;

			}

			p = p.next;

		} while ( p !== start );

		return p;

	}

	// try splitting polygon into two and triangulate them independently

	function splitEarcut( start, triangles, dim, minX, minY, invSize ) {

		// look for a valid diagonal that divides the polygon into two

		var a = start;

		do {

			var b = a.next.next;

			while ( b !== a.prev ) {

				if ( a.i !== b.i && isValidDiagonal( a, b ) ) {

					// split the polygon in two by the diagonal

					var c = splitPolygon( a, b );

					// filter colinear points around the cuts

					a = filterPoints( a, a.next );
					c = filterPoints( c, c.next );

					// run earcut on each half

					earcutLinked( a, triangles, dim, minX, minY, invSize );
					earcutLinked( c, triangles, dim, minX, minY, invSize );
					return;

				}

				b = b.next;

			}

			a = a.next;

		} while ( a !== start );

	}

	// link every hole into the outer loop, producing a single-ring polygon without holes

	function eliminateHoles( data, holeIndices, outerNode, dim ) {

		var queue = [], i, len, start, end, list;

		for ( i = 0, len = holeIndices.length; i < len; i ++ ) {

			start = holeIndices[ i ] * dim;
			end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
			list = linkedList( data, start, end, dim, false );
			if ( list === list.next ) list.steiner = true;
			queue.push( getLeftmost( list ) );

		}

		queue.sort( compareX );

		// process holes from left to right

		for ( i = 0; i < queue.length; i ++ ) {

			eliminateHole( queue[ i ], outerNode );
			outerNode = filterPoints( outerNode, outerNode.next );

		}

		return outerNode;

	}

	function compareX( a, b ) {

		return a.x - b.x;

	}

	// find a bridge between vertices that connects hole with an outer ring and and link it

	function eliminateHole( hole, outerNode ) {

		outerNode = findHoleBridge( hole, outerNode );

		if ( outerNode ) {

			var b = splitPolygon( outerNode, hole );

			filterPoints( b, b.next );

		}

	}

	// David Eberly's algorithm for finding a bridge between hole and outer polygon

	function findHoleBridge( hole, outerNode ) {

		var p = outerNode,
			hx = hole.x,
			hy = hole.y,
			qx = - Infinity,
			m;

		// find a segment intersected by a ray from the hole's leftmost point to the left;
		// segment's endpoint with lesser x will be potential connection point

		do {

			if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {

				var x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );

				if ( x <= hx && x > qx ) {

					qx = x;

					if ( x === hx ) {

						if ( hy === p.y ) return p;
						if ( hy === p.next.y ) return p.next;

					}

					m = p.x < p.next.x ? p : p.next;

				}

			}

			p = p.next;

		} while ( p !== outerNode );

		if ( ! m ) return null;

		if ( hx === qx ) return m.prev; // hole touches outer segment; pick lower endpoint

		// look for points inside the triangle of hole point, segment intersection and endpoint;
		// if there are no points found, we have a valid connection;
		// otherwise choose the point of the minimum angle with the ray as connection point

		var stop = m,
			mx = m.x,
			my = m.y,
			tanMin = Infinity,
			tan;

		p = m.next;

		while ( p !== stop ) {

			if ( hx >= p.x && p.x >= mx && hx !== p.x &&
							pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {

				tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential

				if ( ( tan < tanMin || ( tan === tanMin && p.x > m.x ) ) && locallyInside( p, hole ) ) {

					m = p;
					tanMin = tan;

				}

			}

			p = p.next;

		}

		return m;

	}

	// interlink polygon nodes in z-order

	function indexCurve( start, minX, minY, invSize ) {

		var p = start;

		do {

			if ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );
			p.prevZ = p.prev;
			p.nextZ = p.next;
			p = p.next;

		} while ( p !== start );

		p.prevZ.nextZ = null;
		p.prevZ = null;

		sortLinked( p );

	}

	// Simon Tatham's linked list merge sort algorithm
	// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html

	function sortLinked( list ) {

		var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;

		do {

			p = list;
			list = null;
			tail = null;
			numMerges = 0;

			while ( p ) {

				numMerges ++;
				q = p;
				pSize = 0;

				for ( i = 0; i < inSize; i ++ ) {

					pSize ++;
					q = q.nextZ;
					if ( ! q ) break;

				}

				qSize = inSize;

				while ( pSize > 0 || ( qSize > 0 && q ) ) {

					if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {

						e = p;
						p = p.nextZ;
						pSize --;

					} else {

						e = q;
						q = q.nextZ;
						qSize --;

					}

					if ( tail ) tail.nextZ = e;
					else list = e;

					e.prevZ = tail;
					tail = e;

				}

				p = q;

			}

			tail.nextZ = null;
			inSize *= 2;

		} while ( numMerges > 1 );

		return list;

	}

	// z-order of a point given coords and inverse of the longer side of data bbox

	function zOrder( x, y, minX, minY, invSize ) {

		// coords are transformed into non-negative 15-bit integer range

		x = 32767 * ( x - minX ) * invSize;
		y = 32767 * ( y - minY ) * invSize;

		x = ( x | ( x << 8 ) ) & 0x00FF00FF;
		x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
		x = ( x | ( x << 2 ) ) & 0x33333333;
		x = ( x | ( x << 1 ) ) & 0x55555555;

		y = ( y | ( y << 8 ) ) & 0x00FF00FF;
		y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
		y = ( y | ( y << 2 ) ) & 0x33333333;
		y = ( y | ( y << 1 ) ) & 0x55555555;

		return x | ( y << 1 );

	}

	// find the leftmost node of a polygon ring

	function getLeftmost( start ) {

		var p = start, leftmost = start;

		do {

			if ( p.x < leftmost.x ) leftmost = p;
			p = p.next;

		} while ( p !== start );

		return leftmost;

	}

	// check if a point lies within a convex triangle

	function pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {

		return ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&
		 ( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&
		 ( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;

	}

	// check if a diagonal between two polygon nodes is valid (lies in polygon interior)

	function isValidDiagonal( a, b ) {

		return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) &&
			locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b );

	}

	// signed area of a triangle

	function area( p, q, r ) {

		return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );

	}

	// check if two points are equal

	function equals( p1, p2 ) {

		return p1.x === p2.x && p1.y === p2.y;

	}

	// check if two segments intersect

	function intersects( p1, q1, p2, q2 ) {

		if ( ( equals( p1, q1 ) && equals( p2, q2 ) ) ||
				( equals( p1, q2 ) && equals( p2, q1 ) ) ) return true;

		return area( p1, q1, p2 ) > 0 !== area( p1, q1, q2 ) > 0 &&
					 area( p2, q2, p1 ) > 0 !== area( p2, q2, q1 ) > 0;

	}

	// check if a polygon diagonal intersects any polygon segments

	function intersectsPolygon( a, b ) {

		var p = a;

		do {

			if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
							intersects( p, p.next, a, b ) ) {

				return true;

			}

			p = p.next;

		} while ( p !== a );

		return false;

	}

	// check if a polygon diagonal is locally inside the polygon

	function locallyInside( a, b ) {

		return area( a.prev, a, a.next ) < 0 ?
			area( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :
			area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;

	}

	// check if the middle point of a polygon diagonal is inside the polygon

	function middleInside( a, b ) {

		var p = a,
			inside = false,
			px = ( a.x + b.x ) / 2,
			py = ( a.y + b.y ) / 2;

		do {

			if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
							( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) ) {

				inside = ! inside;

			}

			p = p.next;

		} while ( p !== a );

		return inside;

	}

	// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
	// if one belongs to the outer ring and another to a hole, it merges it into a single ring

	function splitPolygon( a, b ) {

		var a2 = new Node( a.i, a.x, a.y ),
			b2 = new Node( b.i, b.x, b.y ),
			an = a.next,
			bp = b.prev;

		a.next = b;
		b.prev = a;

		a2.next = an;
		an.prev = a2;

		b2.next = a2;
		a2.prev = b2;

		bp.next = b2;
		b2.prev = bp;

		return b2;

	}

	// create a node and optionally link it with previous one (in a circular doubly linked list)

	function insertNode( i, x, y, last ) {

		var p = new Node( i, x, y );

		if ( ! last ) {

			p.prev = p;
			p.next = p;

		} else {

			p.next = last.next;
			p.prev = last;
			last.next.prev = p;
			last.next = p;

		}

		return p;

	}

	function removeNode( p ) {

		p.next.prev = p.prev;
		p.prev.next = p.next;

		if ( p.prevZ ) p.prevZ.nextZ = p.nextZ;
		if ( p.nextZ ) p.nextZ.prevZ = p.prevZ;

	}

	function Node( i, x, y ) {

		// vertice index in coordinates array
		this.i = i;

		// vertex coordinates
		this.x = x;
		this.y = y;

		// previous and next vertice nodes in a polygon ring
		this.prev = null;
		this.next = null;

		// z-order curve value
		this.z = null;

		// previous and next nodes in z-order
		this.prevZ = null;
		this.nextZ = null;

		// indicates whether this is a steiner point
		this.steiner = false;

	}

	function signedArea( data, start, end, dim ) {

		var sum = 0;

		for ( var i = start, j = end - dim; i < end; i += dim ) {

			sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
			j = i;

		}

		return sum;

	}

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	var ShapeUtils = {

		// calculate area of the contour polygon

		area: function ( contour ) {

			var n = contour.length;
			var a = 0.0;

			for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

				a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

			}

			return a * 0.5;

		},

		isClockWise: function ( pts ) {

			return ShapeUtils.area( pts ) < 0;

		},

		triangulateShape: function ( contour, holes ) {

			var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
			var holeIndices = []; // array of hole indices
			var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

			removeDupEndPts( contour );
			addContour( vertices, contour );

			//

			var holeIndex = contour.length;

			holes.forEach( removeDupEndPts );

			for ( var i = 0; i < holes.length; i ++ ) {

				holeIndices.push( holeIndex );
				holeIndex += holes[ i ].length;
				addContour( vertices, holes[ i ] );

			}

			//

			var triangles = Earcut.triangulate( vertices, holeIndices );

			//

			for ( var i = 0; i < triangles.length; i += 3 ) {

				faces.push( triangles.slice( i, i + 3 ) );

			}

			return faces;

		}

	};

	function removeDupEndPts( points ) {

		var l = points.length;

		if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

			points.pop();

		}

	}

	function addContour( vertices, contour ) {

		for ( var i = 0; i < contour.length; i ++ ) {

			vertices.push( contour[ i ].x );
			vertices.push( contour[ i ].y );

		}

	}

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *  curveSegments: <int>, // number of points on the curves
	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	 *  depth: <float>, // Depth to extrude the shape
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into the original shape bevel goes
	 *  bevelSize: <float>, // how far from shape outline is bevel
	 *  bevelSegments: <int>, // number of bevel layers
	 *
	 *  extrudePath: <THREE.Curve> // curve to extrude shape along
	 *
	 *  UVGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 */

	// ExtrudeGeometry

	function ExtrudeGeometry( shapes, options ) {

		Geometry.call( this );

		this.type = 'ExtrudeGeometry';

		this.parameters = {
			shapes: shapes,
			options: options
		};

		this.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );
		this.mergeVertices();

	}

	ExtrudeGeometry.prototype = Object.create( Geometry.prototype );
	ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

	ExtrudeGeometry.prototype.toJSON = function () {

		var data = Geometry.prototype.toJSON.call( this );

		var shapes = this.parameters.shapes;
		var options = this.parameters.options;

		return toJSON( shapes, options, data );

	};

	// ExtrudeBufferGeometry

	function ExtrudeBufferGeometry( shapes, options ) {

		BufferGeometry.call( this );

		this.type = 'ExtrudeBufferGeometry';

		this.parameters = {
			shapes: shapes,
			options: options
		};

		shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

		var scope = this;

		var verticesArray = [];
		var uvArray = [];

		for ( var i = 0, l = shapes.length; i < l; i ++ ) {

			var shape = shapes[ i ];
			addShape( shape );

		}

		// build geometry

		this.addAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );

		this.computeVertexNormals();

		// functions

		function addShape( shape ) {

			var placeholder = [];

			// options

			var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
			var steps = options.steps !== undefined ? options.steps : 1;
			var depth = options.depth !== undefined ? options.depth : 100;

			var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
			var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
			var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
			var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

			var extrudePath = options.extrudePath;

			var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

			// deprecated options

			if ( options.amount !== undefined ) {

				console.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' );
				depth = options.amount;

			}

			//

			var extrudePts, extrudeByPath = false;
			var splineTube, binormal, normal, position2;

			if ( extrudePath ) {

				extrudePts = extrudePath.getSpacedPoints( steps );

				extrudeByPath = true;
				bevelEnabled = false; // bevels not supported for path extrusion

				// SETUP TNB variables

				// TODO1 - have a .isClosed in spline?

				splineTube = extrudePath.computeFrenetFrames( steps, false );

				// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

				binormal = new Vector3();
				normal = new Vector3();
				position2 = new Vector3();

			}

			// Safeguards if bevels are not enabled

			if ( ! bevelEnabled ) {

				bevelSegments = 0;
				bevelThickness = 0;
				bevelSize = 0;

			}

			// Variables initialization

			var ahole, h, hl; // looping of holes

			var shapePoints = shape.extractPoints( curveSegments );

			var vertices = shapePoints.shape;
			var holes = shapePoints.holes;

			var reverse = ! ShapeUtils.isClockWise( vertices );

			if ( reverse ) {

				vertices = vertices.reverse();

				// Maybe we should also check if holes are in the opposite direction, just to be safe ...

				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

					ahole = holes[ h ];

					if ( ShapeUtils.isClockWise( ahole ) ) {

						holes[ h ] = ahole.reverse();

					}

				}

			}


			var faces = ShapeUtils.triangulateShape( vertices, holes );

			/* Vertices */

			var contour = vertices; // vertices has all points but contour has only points of circumference

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];

				vertices = vertices.concat( ahole );

			}


			function scalePt2( pt, vec, size ) {

				if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

				return vec.clone().multiplyScalar( size ).add( pt );

			}

			var b, bs, t, z,
				vert, vlen = vertices.length,
				face, flen = faces.length;


			// Find directions for point movement


			function getBevelVec( inPt, inPrev, inNext ) {

				// computes for inPt the corresponding point inPt' on a new contour
				//   shifted by 1 unit (length of normalized vector) to the left
				// if we walk along contour clockwise, this new contour is outside the old one
				//
				// inPt' is the intersection of the two lines parallel to the two
				//  adjacent edges of inPt at a distance of 1 unit on the left side.

				var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

				// good reading for geometry algorithms (here: line-line intersection)
				// http://geomalgorithms.com/a05-_intersect-1.html

				var v_prev_x = inPt.x - inPrev.x,
					v_prev_y = inPt.y - inPrev.y;
				var v_next_x = inNext.x - inPt.x,
					v_next_y = inNext.y - inPt.y;

				var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

				// check for collinear edges
				var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

				if ( Math.abs( collinear0 ) > Number.EPSILON ) {

					// not collinear

					// length of vectors for normalizing

					var v_prev_len = Math.sqrt( v_prev_lensq );
					var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

					// shift adjacent points by unit vectors to the left

					var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
					var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

					var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
					var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

					// scaling factor for v_prev to intersection point

					var sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
							( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
						( v_prev_x * v_next_y - v_prev_y * v_next_x );

					// vector from inPt to intersection point

					v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
					v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

					// Don't normalize!, otherwise sharp corners become ugly
					//  but prevent crazy spikes
					var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
					if ( v_trans_lensq <= 2 ) {

						return new Vector2( v_trans_x, v_trans_y );

					} else {

						shrink_by = Math.sqrt( v_trans_lensq / 2 );

					}

				} else {

					// handle special case of collinear edges

					var direction_eq = false; // assumes: opposite
					if ( v_prev_x > Number.EPSILON ) {

						if ( v_next_x > Number.EPSILON ) {

							direction_eq = true;

						}

					} else {

						if ( v_prev_x < - Number.EPSILON ) {

							if ( v_next_x < - Number.EPSILON ) {

								direction_eq = true;

							}

						} else {

							if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

								direction_eq = true;

							}

						}

					}

					if ( direction_eq ) {

						// console.log("Warning: lines are a straight sequence");
						v_trans_x = - v_prev_y;
						v_trans_y = v_prev_x;
						shrink_by = Math.sqrt( v_prev_lensq );

					} else {

						// console.log("Warning: lines are a straight spike");
						v_trans_x = v_prev_x;
						v_trans_y = v_prev_y;
						shrink_by = Math.sqrt( v_prev_lensq / 2 );

					}

				}

				return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

			}


			var contourMovements = [];

			for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

				if ( j === il ) j = 0;
				if ( k === il ) k = 0;

				//  (j)---(i)---(k)
				// console.log('i,j,k', i, j , k)

				contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

			}

			var holesMovements = [],
				oneHoleMovements, verticesMovements = contourMovements.concat();

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];

				oneHoleMovements = [];

				for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

					if ( j === il ) j = 0;
					if ( k === il ) k = 0;

					//  (j)---(i)---(k)
					oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

				}

				holesMovements.push( oneHoleMovements );
				verticesMovements = verticesMovements.concat( oneHoleMovements );

			}


			// Loop bevelSegments, 1 for the front, 1 for the back

			for ( b = 0; b < bevelSegments; b ++ ) {

				//for ( b = bevelSegments; b > 0; b -- ) {

				t = b / bevelSegments;
				z = bevelThickness * Math.cos( t * Math.PI / 2 );
				bs = bevelSize * Math.sin( t * Math.PI / 2 );

				// contract shape

				for ( i = 0, il = contour.length; i < il; i ++ ) {

					vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

					v( vert.x, vert.y, - z );

				}

				// expand holes

				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

					ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( i = 0, il = ahole.length; i < il; i ++ ) {

						vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						v( vert.x, vert.y, - z );

					}

				}

			}

			bs = bevelSize;

			// Back facing vertices

			for ( i = 0; i < vlen; i ++ ) {

				vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y, 0 );

				} else {

					// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

					normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

					position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

					v( position2.x, position2.y, position2.z );

				}

			}

			// Add stepped vertices...
			// Including front facing vertices

			var s;

			for ( s = 1; s <= steps; s ++ ) {

				for ( i = 0; i < vlen; i ++ ) {

					vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

					if ( ! extrudeByPath ) {

						v( vert.x, vert.y, depth / steps * s );

					} else {

						// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

						normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
						binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

						position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

						v( position2.x, position2.y, position2.z );

					}

				}

			}


			// Add bevel segments planes

			//for ( b = 1; b <= bevelSegments; b ++ ) {
			for ( b = bevelSegments - 1; b >= 0; b -- ) {

				t = b / bevelSegments;
				z = bevelThickness * Math.cos( t * Math.PI / 2 );
				bs = bevelSize * Math.sin( t * Math.PI / 2 );

				// contract shape

				for ( i = 0, il = contour.length; i < il; i ++ ) {

					vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
					v( vert.x, vert.y, depth + z );

				}

				// expand holes

				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

					ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( i = 0, il = ahole.length; i < il; i ++ ) {

						vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						if ( ! extrudeByPath ) {

							v( vert.x, vert.y, depth + z );

						} else {

							v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

						}

					}

				}

			}

			/* Faces */

			// Top and bottom faces

			buildLidFaces();

			// Sides faces

			buildSideFaces();


			/////  Internal functions

			function buildLidFaces() {

				var start = verticesArray.length / 3;

				if ( bevelEnabled ) {

					var layer = 0; // steps + 1
					var offset = vlen * layer;

					// Bottom faces

					for ( i = 0; i < flen; i ++ ) {

						face = faces[ i ];
						f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

					}

					layer = steps + bevelSegments * 2;
					offset = vlen * layer;

					// Top faces

					for ( i = 0; i < flen; i ++ ) {

						face = faces[ i ];
						f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

					}

				} else {

					// Bottom faces

					for ( i = 0; i < flen; i ++ ) {

						face = faces[ i ];
						f3( face[ 2 ], face[ 1 ], face[ 0 ] );

					}

					// Top faces

					for ( i = 0; i < flen; i ++ ) {

						face = faces[ i ];
						f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

					}

				}

				scope.addGroup( start, verticesArray.length / 3 - start, 0 );

			}

			// Create faces for the z-sides of the shape

			function buildSideFaces() {

				var start = verticesArray.length / 3;
				var layeroffset = 0;
				sidewalls( contour, layeroffset );
				layeroffset += contour.length;

				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

					ahole = holes[ h ];
					sidewalls( ahole, layeroffset );

					//, true
					layeroffset += ahole.length;

				}


				scope.addGroup( start, verticesArray.length / 3 - start, 1 );


			}

			function sidewalls( contour, layeroffset ) {

				var j, k;
				i = contour.length;

				while ( -- i >= 0 ) {

					j = i;
					k = i - 1;
					if ( k < 0 ) k = contour.length - 1;

					//console.log('b', i,j, i-1, k,vertices.length);

					var s = 0,
						sl = steps + bevelSegments * 2;

					for ( s = 0; s < sl; s ++ ) {

						var slen1 = vlen * s;
						var slen2 = vlen * ( s + 1 );

						var a = layeroffset + j + slen1,
							b = layeroffset + k + slen1,
							c = layeroffset + k + slen2,
							d = layeroffset + j + slen2;

						f4( a, b, c, d );

					}

				}

			}

			function v( x, y, z ) {

				placeholder.push( x );
				placeholder.push( y );
				placeholder.push( z );

			}


			function f3( a, b, c ) {

				addVertex( a );
				addVertex( b );
				addVertex( c );

				var nextIndex = verticesArray.length / 3;
				var uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );

			}

			function f4( a, b, c, d ) {

				addVertex( a );
				addVertex( b );
				addVertex( d );

				addVertex( b );
				addVertex( c );
				addVertex( d );


				var nextIndex = verticesArray.length / 3;
				var uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 3 ] );

				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );
				addUV( uvs[ 3 ] );

			}

			function addVertex( index ) {

				verticesArray.push( placeholder[ index * 3 + 0 ] );
				verticesArray.push( placeholder[ index * 3 + 1 ] );
				verticesArray.push( placeholder[ index * 3 + 2 ] );

			}


			function addUV( vector2 ) {

				uvArray.push( vector2.x );
				uvArray.push( vector2.y );

			}

		}

	}

	ExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;

	ExtrudeBufferGeometry.prototype.toJSON = function () {

		var data = BufferGeometry.prototype.toJSON.call( this );

		var shapes = this.parameters.shapes;
		var options = this.parameters.options;

		return toJSON( shapes, options, data );

	};

	//

	var WorldUVGenerator = {

		generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

			var a_x = vertices[ indexA * 3 ];
			var a_y = vertices[ indexA * 3 + 1 ];
			var b_x = vertices[ indexB * 3 ];
			var b_y = vertices[ indexB * 3 + 1 ];
			var c_x = vertices[ indexC * 3 ];
			var c_y = vertices[ indexC * 3 + 1 ];

			return [
				new Vector2( a_x, a_y ),
				new Vector2( b_x, b_y ),
				new Vector2( c_x, c_y )
			];

		},

		generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

			var a_x = vertices[ indexA * 3 ];
			var a_y = vertices[ indexA * 3 + 1 ];
			var a_z = vertices[ indexA * 3 + 2 ];
			var b_x = vertices[ indexB * 3 ];
			var b_y = vertices[ indexB * 3 + 1 ];
			var b_z = vertices[ indexB * 3 + 2 ];
			var c_x = vertices[ indexC * 3 ];
			var c_y = vertices[ indexC * 3 + 1 ];
			var c_z = vertices[ indexC * 3 + 2 ];
			var d_x = vertices[ indexD * 3 ];
			var d_y = vertices[ indexD * 3 + 1 ];
			var d_z = vertices[ indexD * 3 + 2 ];

			if ( Math.abs( a_y - b_y ) < 0.01 ) {

				return [
					new Vector2( a_x, 1 - a_z ),
					new Vector2( b_x, 1 - b_z ),
					new Vector2( c_x, 1 - c_z ),
					new Vector2( d_x, 1 - d_z )
				];

			} else {

				return [
					new Vector2( a_y, 1 - a_z ),
					new Vector2( b_y, 1 - b_z ),
					new Vector2( c_y, 1 - c_z ),
					new Vector2( d_y, 1 - d_z )
				];

			}

		}
	};

	function toJSON( shapes, options, data ) {

		//

		data.shapes = [];

		if ( Array.isArray( shapes ) ) {

			for ( var i = 0, l = shapes.length; i < l; i ++ ) {

				var shape = shapes[ i ];

				data.shapes.push( shape.uuid );

			}

		} else {

			data.shapes.push( shapes.uuid );

		}

		//

		if ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();

		return data;

	}

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * Text = 3D Text
	 *
	 * parameters = {
	 *  font: <THREE.Font>, // font
	 *
	 *  size: <float>, // size of the text
	 *  height: <float>, // thickness to extrude text
	 *  curveSegments: <int>, // number of points on the curves
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into text bevel goes
	 *  bevelSize: <float> // how far from text outline is bevel
	 * }
	 */

	// TextGeometry

	function TextGeometry( text, parameters ) {

		Geometry.call( this );

		this.type = 'TextGeometry';

		this.parameters = {
			text: text,
			parameters: parameters
		};

		this.fromBufferGeometry( new TextBufferGeometry( text, parameters ) );
		this.mergeVertices();

	}

	TextGeometry.prototype = Object.create( Geometry.prototype );
	TextGeometry.prototype.constructor = TextGeometry;

	// TextBufferGeometry

	function TextBufferGeometry( text, parameters ) {

		parameters = parameters || {};

		var font = parameters.font;

		if ( ! ( font && font.isFont ) ) {

			console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
			return new Geometry();

		}

		var shapes = font.generateShapes( text, parameters.size );

		// translate parameters to ExtrudeGeometry API

		parameters.depth = parameters.height !== undefined ? parameters.height : 50;

		// defaults

		if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
		if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
		if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

		ExtrudeBufferGeometry.call( this, shapes, parameters );

		this.type = 'TextBufferGeometry';

	}

	TextBufferGeometry.prototype = Object.create( ExtrudeBufferGeometry.prototype );
	TextBufferGeometry.prototype.constructor = TextBufferGeometry;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author benaadams / https://twitter.com/ben_a_adams
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// SphereGeometry

	function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

		Geometry.call( this );

		this.type = 'SphereGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );
		this.mergeVertices();

	}

	SphereGeometry.prototype = Object.create( Geometry.prototype );
	SphereGeometry.prototype.constructor = SphereGeometry;

	// SphereBufferGeometry

	function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

		BufferGeometry.call( this );

		this.type = 'SphereBufferGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		radius = radius || 1;

		widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

		phiStart = phiStart !== undefined ? phiStart : 0;
		phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

		var thetaEnd = thetaStart + thetaLength;

		var ix, iy;

		var index = 0;
		var grid = [];

		var vertex = new Vector3();
		var normal = new Vector3();

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// generate vertices, normals and uvs

		for ( iy = 0; iy <= heightSegments; iy ++ ) {

			var verticesRow = [];

			var v = iy / heightSegments;

			// special case for the poles

			var uOffset = ( iy == 0 ) ? 0.5 / widthSegments : ( ( iy == heightSegments ) ? - 0.5 / widthSegments : 0 );

			for ( ix = 0; ix <= widthSegments; ix ++ ) {

				var u = ix / widthSegments;

				// vertex

				vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
				vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normal.copy( vertex ).normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u + uOffset, 1 - v );

				verticesRow.push( index ++ );

			}

			grid.push( verticesRow );

		}

		// indices

		for ( iy = 0; iy < heightSegments; iy ++ ) {

			for ( ix = 0; ix < widthSegments; ix ++ ) {

				var a = grid[ iy ][ ix + 1 ];
				var b = grid[ iy ][ ix ];
				var c = grid[ iy + 1 ][ ix ];
				var d = grid[ iy + 1 ][ ix + 1 ];

				if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
				if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;

	/**
	 * @author Kaleb Murphy
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// RingGeometry

	function RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

		Geometry.call( this );

		this.type = 'RingGeometry';

		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );
		this.mergeVertices();

	}

	RingGeometry.prototype = Object.create( Geometry.prototype );
	RingGeometry.prototype.constructor = RingGeometry;

	// RingBufferGeometry

	function RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

		BufferGeometry.call( this );

		this.type = 'RingBufferGeometry';

		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		innerRadius = innerRadius || 0.5;
		outerRadius = outerRadius || 1;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
		phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// some helper variables

		var segment;
		var radius = innerRadius;
		var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
		var vertex = new Vector3();
		var uv = new Vector2();
		var j, i;

		// generate vertices, normals and uvs

		for ( j = 0; j <= phiSegments; j ++ ) {

			for ( i = 0; i <= thetaSegments; i ++ ) {

				// values are generate from the inside of the ring to the outside

				segment = thetaStart + i / thetaSegments * thetaLength;

				// vertex

				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, 0, 1 );

				// uv

				uv.x = ( vertex.x / outerRadius + 1 ) / 2;
				uv.y = ( vertex.y / outerRadius + 1 ) / 2;

				uvs.push( uv.x, uv.y );

			}

			// increase the radius for next row of vertices

			radius += radiusStep;

		}

		// indices

		for ( j = 0; j < phiSegments; j ++ ) {

			var thetaSegmentLevel = j * ( thetaSegments + 1 );

			for ( i = 0; i < thetaSegments; i ++ ) {

				segment = i + thetaSegmentLevel;

				var a = segment;
				var b = segment + thetaSegments + 1;
				var c = segment + thetaSegments + 2;
				var d = segment + 1;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	RingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	RingBufferGeometry.prototype.constructor = RingBufferGeometry;

	/**
	 * @author zz85 / https://github.com/zz85
	 * @author bhouston / http://clara.io
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// LatheGeometry

	function LatheGeometry( points, segments, phiStart, phiLength ) {

		Geometry.call( this );

		this.type = 'LatheGeometry';

		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};

		this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );
		this.mergeVertices();

	}

	LatheGeometry.prototype = Object.create( Geometry.prototype );
	LatheGeometry.prototype.constructor = LatheGeometry;

	// LatheBufferGeometry

	function LatheBufferGeometry( points, segments, phiStart, phiLength ) {

		BufferGeometry.call( this );

		this.type = 'LatheBufferGeometry';

		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};

		segments = Math.floor( segments ) || 12;
		phiStart = phiStart || 0;
		phiLength = phiLength || Math.PI * 2;

		// clamp phiLength so it's in range of [ 0, 2PI ]

		phiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );


		// buffers

		var indices = [];
		var vertices = [];
		var uvs = [];

		// helper variables

		var base;
		var inverseSegments = 1.0 / segments;
		var vertex = new Vector3();
		var uv = new Vector2();
		var i, j;

		// generate vertices and uvs

		for ( i = 0; i <= segments; i ++ ) {

			var phi = phiStart + i * inverseSegments * phiLength;

			var sin = Math.sin( phi );
			var cos = Math.cos( phi );

			for ( j = 0; j <= ( points.length - 1 ); j ++ ) {

				// vertex

				vertex.x = points[ j ].x * sin;
				vertex.y = points[ j ].y;
				vertex.z = points[ j ].x * cos;

				vertices.push( vertex.x, vertex.y, vertex.z );

				// uv

				uv.x = i / segments;
				uv.y = j / ( points.length - 1 );

				uvs.push( uv.x, uv.y );


			}

		}

		// indices

		for ( i = 0; i < segments; i ++ ) {

			for ( j = 0; j < ( points.length - 1 ); j ++ ) {

				base = j + i * points.length;

				var a = base;
				var b = base + points.length;
				var c = base + points.length + 1;
				var d = base + 1;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// generate normals

		this.computeVertexNormals();

		// if the geometry is closed, we need to average the normals along the seam.
		// because the corresponding vertices are identical (but still have different UVs).

		if ( phiLength === Math.PI * 2 ) {

			var normals = this.attributes.normal.array;
			var n1 = new Vector3();
			var n2 = new Vector3();
			var n = new Vector3();

			// this is the buffer offset for the last line of vertices

			base = segments * points.length * 3;

			for ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {

				// select the normal of the vertex in the first line

				n1.x = normals[ j + 0 ];
				n1.y = normals[ j + 1 ];
				n1.z = normals[ j + 2 ];

				// select the normal of the vertex in the last line

				n2.x = normals[ base + j + 0 ];
				n2.y = normals[ base + j + 1 ];
				n2.z = normals[ base + j + 2 ];

				// average normals

				n.addVectors( n1, n2 ).normalize();

				// assign the new values to both normals

				normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
				normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
				normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

			}

		}

	}

	LatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;

	/**
	 * @author jonobr1 / http://jonobr1.com
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// ShapeGeometry

	function ShapeGeometry( shapes, curveSegments ) {

		Geometry.call( this );

		this.type = 'ShapeGeometry';

		if ( typeof curveSegments === 'object' ) {

			console.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );

			curveSegments = curveSegments.curveSegments;

		}

		this.parameters = {
			shapes: shapes,
			curveSegments: curveSegments
		};

		this.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );
		this.mergeVertices();

	}

	ShapeGeometry.prototype = Object.create( Geometry.prototype );
	ShapeGeometry.prototype.constructor = ShapeGeometry;

	ShapeGeometry.prototype.toJSON = function () {

		var data = Geometry.prototype.toJSON.call( this );

		var shapes = this.parameters.shapes;

		return toJSON$1( shapes, data );

	};

	// ShapeBufferGeometry

	function ShapeBufferGeometry( shapes, curveSegments ) {

		BufferGeometry.call( this );

		this.type = 'ShapeBufferGeometry';

		this.parameters = {
			shapes: shapes,
			curveSegments: curveSegments
		};

		curveSegments = curveSegments || 12;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var groupStart = 0;
		var groupCount = 0;

		// allow single and array values for "shapes" parameter

		if ( Array.isArray( shapes ) === false ) {

			addShape( shapes );

		} else {

			for ( var i = 0; i < shapes.length; i ++ ) {

				addShape( shapes[ i ] );

				this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

				groupStart += groupCount;
				groupCount = 0;

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );


		// helper functions

		function addShape( shape ) {

			var i, l, shapeHole;

			var indexOffset = vertices.length / 3;
			var points = shape.extractPoints( curveSegments );

			var shapeVertices = points.shape;
			var shapeHoles = points.holes;

			// check direction of vertices

			if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

				shapeVertices = shapeVertices.reverse();

			}

			for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

				shapeHole = shapeHoles[ i ];

				if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

					shapeHoles[ i ] = shapeHole.reverse();

				}

			}

			var faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

			// join vertices of inner and outer paths to a single array

			for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

				shapeHole = shapeHoles[ i ];
				shapeVertices = shapeVertices.concat( shapeHole );

			}

			// vertices, normals, uvs

			for ( i = 0, l = shapeVertices.length; i < l; i ++ ) {

				var vertex = shapeVertices[ i ];

				vertices.push( vertex.x, vertex.y, 0 );
				normals.push( 0, 0, 1 );
				uvs.push( vertex.x, vertex.y ); // world uvs

			}

			// incides

			for ( i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				var a = face[ 0 ] + indexOffset;
				var b = face[ 1 ] + indexOffset;
				var c = face[ 2 ] + indexOffset;

				indices.push( a, b, c );
				groupCount += 3;

			}

		}

	}

	ShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;

	ShapeBufferGeometry.prototype.toJSON = function () {

		var data = BufferGeometry.prototype.toJSON.call( this );

		var shapes = this.parameters.shapes;

		return toJSON$1( shapes, data );

	};

	//

	function toJSON$1( shapes, data ) {

		data.shapes = [];

		if ( Array.isArray( shapes ) ) {

			for ( var i = 0, l = shapes.length; i < l; i ++ ) {

				var shape = shapes[ i ];

				data.shapes.push( shape.uuid );

			}

		} else {

			data.shapes.push( shapes.uuid );

		}

		return data;

	}

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function EdgesGeometry( geometry, thresholdAngle ) {

		BufferGeometry.call( this );

		this.type = 'EdgesGeometry';

		this.parameters = {
			thresholdAngle: thresholdAngle
		};

		thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

		// buffer

		var vertices = [];

		// helper variables

		var thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );
		var edge = [ 0, 0 ], edges = {}, edge1, edge2;
		var key, keys = [ 'a', 'b', 'c' ];

		// prepare source geometry

		var geometry2;

		if ( geometry.isBufferGeometry ) {

			geometry2 = new Geometry();
			geometry2.fromBufferGeometry( geometry );

		} else {

			geometry2 = geometry.clone();

		}

		geometry2.mergeVertices();
		geometry2.computeFaceNormals();

		var sourceVertices = geometry2.vertices;
		var faces = geometry2.faces;

		// now create a data structure where each entry represents an edge with its adjoining faces

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0; j < 3; j ++ ) {

				edge1 = face[ keys[ j ] ];
				edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
				edge[ 0 ] = Math.min( edge1, edge2 );
				edge[ 1 ] = Math.max( edge1, edge2 );

				key = edge[ 0 ] + ',' + edge[ 1 ];

				if ( edges[ key ] === undefined ) {

					edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };

				} else {

					edges[ key ].face2 = i;

				}

			}

		}

		// generate vertices

		for ( key in edges ) {

			var e = edges[ key ];

			// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.

			if ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {

				var vertex = sourceVertices[ e.index1 ];
				vertices.push( vertex.x, vertex.y, vertex.z );

				vertex = sourceVertices[ e.index2 ];
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		}

		// build geometry

		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

	}

	EdgesGeometry.prototype = Object.create( BufferGeometry.prototype );
	EdgesGeometry.prototype.constructor = EdgesGeometry;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// CylinderGeometry

	function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		Geometry.call( this );

		this.type = 'CylinderGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
		this.mergeVertices();

	}

	CylinderGeometry.prototype = Object.create( Geometry.prototype );
	CylinderGeometry.prototype.constructor = CylinderGeometry;

	// CylinderBufferGeometry

	function CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		BufferGeometry.call( this );

		this.type = 'CylinderBufferGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		var scope = this;

		radiusTop = radiusTop !== undefined ? radiusTop : 1;
		radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
		height = height || 1;

		radialSegments = Math.floor( radialSegments ) || 8;
		heightSegments = Math.floor( heightSegments ) || 1;

		openEnded = openEnded !== undefined ? openEnded : false;
		thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var index = 0;
		var indexArray = [];
		var halfHeight = height / 2;
		var groupStart = 0;

		// generate geometry

		generateTorso();

		if ( openEnded === false ) {

			if ( radiusTop > 0 ) generateCap( true );
			if ( radiusBottom > 0 ) generateCap( false );

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function generateTorso() {

			var x, y;
			var normal = new Vector3();
			var vertex = new Vector3();

			var groupCount = 0;

			// this will be used to calculate the normal
			var slope = ( radiusBottom - radiusTop ) / height;

			// generate vertices, normals and uvs

			for ( y = 0; y <= heightSegments; y ++ ) {

				var indexRow = [];

				var v = y / heightSegments;

				// calculate the radius of the current row

				var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

				for ( x = 0; x <= radialSegments; x ++ ) {

					var u = x / radialSegments;

					var theta = u * thetaLength + thetaStart;

					var sinTheta = Math.sin( theta );
					var cosTheta = Math.cos( theta );

					// vertex

					vertex.x = radius * sinTheta;
					vertex.y = - v * height + halfHeight;
					vertex.z = radius * cosTheta;
					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normal.set( sinTheta, slope, cosTheta ).normalize();
					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( u, 1 - v );

					// save index of vertex in respective row

					indexRow.push( index ++ );

				}

				// now save vertices of the row in our index array

				indexArray.push( indexRow );

			}

			// generate indices

			for ( x = 0; x < radialSegments; x ++ ) {

				for ( y = 0; y < heightSegments; y ++ ) {

					// we use the index array to access the correct indices

					var a = indexArray[ y ][ x ];
					var b = indexArray[ y + 1 ][ x ];
					var c = indexArray[ y + 1 ][ x + 1 ];
					var d = indexArray[ y ][ x + 1 ];

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// update group counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, 0 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

		function generateCap( top ) {

			var x, centerIndexStart, centerIndexEnd;

			var uv = new Vector2();
			var vertex = new Vector3();

			var groupCount = 0;

			var radius = ( top === true ) ? radiusTop : radiusBottom;
			var sign = ( top === true ) ? 1 : - 1;

			// save the index of the first center vertex
			centerIndexStart = index;

			// first we generate the center vertex data of the cap.
			// because the geometry needs one set of uvs per face,
			// we must generate a center vertex per face/segment

			for ( x = 1; x <= radialSegments; x ++ ) {

				// vertex

				vertices.push( 0, halfHeight * sign, 0 );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uvs.push( 0.5, 0.5 );

				// increase index

				index ++;

			}

			// save the index of the last center vertex

			centerIndexEnd = index;

			// now we generate the surrounding vertices, normals and uvs

			for ( x = 0; x <= radialSegments; x ++ ) {

				var u = x / radialSegments;
				var theta = u * thetaLength + thetaStart;

				var cosTheta = Math.cos( theta );
				var sinTheta = Math.sin( theta );

				// vertex

				vertex.x = radius * sinTheta;
				vertex.y = halfHeight * sign;
				vertex.z = radius * cosTheta;
				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uv.x = ( cosTheta * 0.5 ) + 0.5;
				uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
				uvs.push( uv.x, uv.y );

				// increase index

				index ++;

			}

			// generate indices

			for ( x = 0; x < radialSegments; x ++ ) {

				var c = centerIndexStart + x;
				var i = centerIndexEnd + x;

				if ( top === true ) {

					// face top

					indices.push( i, i + 1, c );

				} else {

					// face bottom

					indices.push( i + 1, i, c );

				}

				groupCount += 3;

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

	}

	CylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;

	/**
	 * @author abelnation / http://github.com/abelnation
	 */

	// ConeGeometry

	function ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		CylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

		this.type = 'ConeGeometry';

		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

	}

	ConeGeometry.prototype = Object.create( CylinderGeometry.prototype );
	ConeGeometry.prototype.constructor = ConeGeometry;

	// ConeBufferGeometry

	function ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		CylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

		this.type = 'ConeBufferGeometry';

		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

	}

	ConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );
	ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 * @author Mugen87 / https://github.com/Mugen87
	 * @author hughes
	 */

	// CircleGeometry

	function CircleGeometry( radius, segments, thetaStart, thetaLength ) {

		Geometry.call( this );

		this.type = 'CircleGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );
		this.mergeVertices();

	}

	CircleGeometry.prototype = Object.create( Geometry.prototype );
	CircleGeometry.prototype.constructor = CircleGeometry;

	// CircleBufferGeometry

	function CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {

		BufferGeometry.call( this );

		this.type = 'CircleBufferGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		radius = radius || 1;
		segments = segments !== undefined ? Math.max( 3, segments ) : 8;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var i, s;
		var vertex = new Vector3();
		var uv = new Vector2();

		// center point

		vertices.push( 0, 0, 0 );
		normals.push( 0, 0, 1 );
		uvs.push( 0.5, 0.5 );

		for ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {

			var segment = thetaStart + s / segments * thetaLength;

			// vertex

			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			normals.push( 0, 0, 1 );

			// uvs

			uv.x = ( vertices[ i ] / radius + 1 ) / 2;
			uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

			uvs.push( uv.x, uv.y );

		}

		// indices

		for ( i = 1; i <= segments; i ++ ) {

			indices.push( i, i + 1, 0 );

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	CircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;



	var Geometries = /*#__PURE__*/Object.freeze({
		WireframeGeometry: WireframeGeometry,
		ParametricGeometry: ParametricGeometry,
		ParametricBufferGeometry: ParametricBufferGeometry,
		TetrahedronGeometry: TetrahedronGeometry,
		TetrahedronBufferGeometry: TetrahedronBufferGeometry,
		OctahedronGeometry: OctahedronGeometry,
		OctahedronBufferGeometry: OctahedronBufferGeometry,
		IcosahedronGeometry: IcosahedronGeometry,
		IcosahedronBufferGeometry: IcosahedronBufferGeometry,
		DodecahedronGeometry: DodecahedronGeometry,
		DodecahedronBufferGeometry: DodecahedronBufferGeometry,
		PolyhedronGeometry: PolyhedronGeometry,
		PolyhedronBufferGeometry: PolyhedronBufferGeometry,
		TubeGeometry: TubeGeometry,
		TubeBufferGeometry: TubeBufferGeometry,
		TorusKnotGeometry: TorusKnotGeometry,
		TorusKnotBufferGeometry: TorusKnotBufferGeometry,
		TorusGeometry: TorusGeometry,
		TorusBufferGeometry: TorusBufferGeometry,
		TextGeometry: TextGeometry,
		TextBufferGeometry: TextBufferGeometry,
		SphereGeometry: SphereGeometry,
		SphereBufferGeometry: SphereBufferGeometry,
		RingGeometry: RingGeometry,
		RingBufferGeometry: RingBufferGeometry,
		PlaneGeometry: PlaneGeometry,
		PlaneBufferGeometry: PlaneBufferGeometry,
		LatheGeometry: LatheGeometry,
		LatheBufferGeometry: LatheBufferGeometry,
		ShapeGeometry: ShapeGeometry,
		ShapeBufferGeometry: ShapeBufferGeometry,
		ExtrudeGeometry: ExtrudeGeometry,
		ExtrudeBufferGeometry: ExtrudeBufferGeometry,
		EdgesGeometry: EdgesGeometry,
		ConeGeometry: ConeGeometry,
		ConeBufferGeometry: ConeBufferGeometry,
		CylinderGeometry: CylinderGeometry,
		CylinderBufferGeometry: CylinderBufferGeometry,
		CircleGeometry: CircleGeometry,
		CircleBufferGeometry: CircleBufferGeometry,
		BoxGeometry: BoxGeometry,
		BoxBufferGeometry: BoxBufferGeometry
	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * parameters = {
	 *  color: <THREE.Color>
	 * }
	 */

	function ShadowMaterial( parameters ) {

		Material.call( this );

		this.type = 'ShadowMaterial';

		this.color = new Color( 0x000000 );
		this.transparent = true;

		this.setValues( parameters );

	}

	ShadowMaterial.prototype = Object.create( Material.prototype );
	ShadowMaterial.prototype.constructor = ShadowMaterial;

	ShadowMaterial.prototype.isShadowMaterial = true;

	ShadowMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		return this;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function RawShaderMaterial( parameters ) {

		ShaderMaterial.call( this, parameters );

		this.type = 'RawShaderMaterial';

	}

	RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
	RawShaderMaterial.prototype.constructor = RawShaderMaterial;

	RawShaderMaterial.prototype.isRawShaderMaterial = true;

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  roughness: <float>,
	 *  metalness: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  roughnessMap: new THREE.Texture( <Image> ),
	 *
	 *  metalnessMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  envMapIntensity: <float>
	 *
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshStandardMaterial( parameters ) {

		Material.call( this );

		this.defines = { 'STANDARD': '' };

		this.type = 'MeshStandardMaterial';

		this.color = new Color( 0xffffff ); // diffuse
		this.roughness = 0.5;
		this.metalness = 0.5;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.roughnessMap = null;

		this.metalnessMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.envMapIntensity = 1.0;

		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	MeshStandardMaterial.prototype = Object.create( Material.prototype );
	MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;

	MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

	MeshStandardMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.defines = { 'STANDARD': '' };

		this.color.copy( source.color );
		this.roughness = source.roughness;
		this.metalness = source.metalness;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.roughnessMap = source.roughnessMap;

		this.metalnessMap = source.metalnessMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapIntensity = source.envMapIntensity;

		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  reflectivity: <float>
	 *  clearCoat: <float>
	 *  clearCoatRoughness: <float>
	 * }
	 */

	function MeshPhysicalMaterial( parameters ) {

		MeshStandardMaterial.call( this );

		this.defines = { 'PHYSICAL': '' };

		this.type = 'MeshPhysicalMaterial';

		this.reflectivity = 0.5; // maps to F0 = 0.04

		this.clearCoat = 0.0;
		this.clearCoatRoughness = 0.0;

		this.setValues( parameters );

	}

	MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
	MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;

	MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

	MeshPhysicalMaterial.prototype.copy = function ( source ) {

		MeshStandardMaterial.prototype.copy.call( this, source );

		this.defines = { 'PHYSICAL': '' };

		this.reflectivity = source.reflectivity;

		this.clearCoat = source.clearCoat;
		this.clearCoatRoughness = source.clearCoatRoughness;

		return this;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  specular: <hex>,
	 *  shininess: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshPhongMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshPhongMaterial';

		this.color = new Color( 0xffffff ); // diffuse
		this.specular = new Color( 0x111111 );
		this.shininess = 30;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	MeshPhongMaterial.prototype = Object.create( Material.prototype );
	MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;

	MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

	MeshPhongMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );
		this.specular.copy( source.specular );
		this.shininess = source.shininess;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	/**
	 * @author takahirox / http://github.com/takahirox
	 *
	 * parameters = {
	 *  gradientMap: new THREE.Texture( <Image> )
	 * }
	 */

	function MeshToonMaterial( parameters ) {

		MeshPhongMaterial.call( this );

		this.defines = { 'TOON': '' };

		this.type = 'MeshToonMaterial';

		this.gradientMap = null;

		this.setValues( parameters );

	}

	MeshToonMaterial.prototype = Object.create( MeshPhongMaterial.prototype );
	MeshToonMaterial.prototype.constructor = MeshToonMaterial;

	MeshToonMaterial.prototype.isMeshToonMaterial = true;

	MeshToonMaterial.prototype.copy = function ( source ) {

		MeshPhongMaterial.prototype.copy.call( this, source );

		this.gradientMap = source.gradientMap;

		return this;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshNormalMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshNormalMaterial';

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false;
		this.lights = false;

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	MeshNormalMaterial.prototype = Object.create( Material.prototype );
	MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;

	MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

	MeshNormalMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshLambertMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshLambertMaterial';

		this.color = new Color( 0xffffff ); // diffuse

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	MeshLambertMaterial.prototype = Object.create( Material.prototype );
	MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;

	MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

	MeshLambertMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  matcap: new THREE.Texture( <Image> ),
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshMatcapMaterial( parameters ) {

		Material.call( this );

		this.defines = { 'MATCAP': '' };

		this.type = 'MeshMatcapMaterial';

		this.color = new Color( 0xffffff ); // diffuse

		this.matcap = null;

		this.map = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.alphaMap = null;

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.lights = false;

		this.setValues( parameters );

	}

	MeshMatcapMaterial.prototype = Object.create( Material.prototype );
	MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;

	MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;

	MeshMatcapMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.defines = { 'MATCAP': '' };

		this.color.copy( source.color );

		this.matcap = source.matcap;

		this.map = source.map;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.alphaMap = source.alphaMap;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *
	 *  scale: <float>,
	 *  dashSize: <float>,
	 *  gapSize: <float>
	 * }
	 */

	function LineDashedMaterial( parameters ) {

		LineBasicMaterial.call( this );

		this.type = 'LineDashedMaterial';

		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;

		this.setValues( parameters );

	}

	LineDashedMaterial.prototype = Object.create( LineBasicMaterial.prototype );
	LineDashedMaterial.prototype.constructor = LineDashedMaterial;

	LineDashedMaterial.prototype.isLineDashedMaterial = true;

	LineDashedMaterial.prototype.copy = function ( source ) {

		LineBasicMaterial.prototype.copy.call( this, source );

		this.scale = source.scale;
		this.dashSize = source.dashSize;
		this.gapSize = source.gapSize;

		return this;

	};



	var Materials = /*#__PURE__*/Object.freeze({
		ShadowMaterial: ShadowMaterial,
		SpriteMaterial: SpriteMaterial,
		RawShaderMaterial: RawShaderMaterial,
		ShaderMaterial: ShaderMaterial,
		PointsMaterial: PointsMaterial,
		MeshPhysicalMaterial: MeshPhysicalMaterial,
		MeshStandardMaterial: MeshStandardMaterial,
		MeshPhongMaterial: MeshPhongMaterial,
		MeshToonMaterial: MeshToonMaterial,
		MeshNormalMaterial: MeshNormalMaterial,
		MeshLambertMaterial: MeshLambertMaterial,
		MeshDepthMaterial: MeshDepthMaterial,
		MeshDistanceMaterial: MeshDistanceMaterial,
		MeshBasicMaterial: MeshBasicMaterial,
		MeshMatcapMaterial: MeshMatcapMaterial,
		LineDashedMaterial: LineDashedMaterial,
		LineBasicMaterial: LineBasicMaterial,
		Material: Material
	});

	/**
	 * @author tschw
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */

	var AnimationUtils = {

		// same as Array.prototype.slice, but also works on typed arrays
		arraySlice: function ( array, from, to ) {

			if ( AnimationUtils.isTypedArray( array ) ) {

				// in ios9 array.subarray(from, undefined) will return empty array
				// but array.subarray(from) or array.subarray(from, len) is correct
				return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

			}

			return array.slice( from, to );

		},

		// converts an array to a specific type
		convertArray: function ( array, type, forceClone ) {

			if ( ! array || // let 'undefined' and 'null' pass
				! forceClone && array.constructor === type ) return array;

			if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

				return new type( array ); // create typed array

			}

			return Array.prototype.slice.call( array ); // create Array

		},

		isTypedArray: function ( object ) {

			return ArrayBuffer.isView( object ) &&
				! ( object instanceof DataView );

		},

		// returns an array by which times and values can be sorted
		getKeyframeOrder: function ( times ) {

			function compareTime( i, j ) {

				return times[ i ] - times[ j ];

			}

			var n = times.length;
			var result = new Array( n );
			for ( var i = 0; i !== n; ++ i ) result[ i ] = i;

			result.sort( compareTime );

			return result;

		},

		// uses the array previously returned by 'getKeyframeOrder' to sort data
		sortedArray: function ( values, stride, order ) {

			var nValues = values.length;
			var result = new values.constructor( nValues );

			for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

				var srcOffset = order[ i ] * stride;

				for ( var j = 0; j !== stride; ++ j ) {

					result[ dstOffset ++ ] = values[ srcOffset + j ];

				}

			}

			return result;

		},

		// function for parsing AOS keyframe formats
		flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {

			var i = 1, key = jsonKeys[ 0 ];

			while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

				key = jsonKeys[ i ++ ];

			}

			if ( key === undefined ) return; // no data

			var value = key[ valuePropertyName ];
			if ( value === undefined ) return; // no data

			if ( Array.isArray( value ) ) {

				do {

					value = key[ valuePropertyName ];

					if ( value !== undefined ) {

						times.push( key.time );
						values.push.apply( values, value ); // push all elements

					}

					key = jsonKeys[ i ++ ];

				} while ( key !== undefined );

			} else if ( value.toArray !== undefined ) {

				// ...assume THREE.Math-ish

				do {

					value = key[ valuePropertyName ];

					if ( value !== undefined ) {

						times.push( key.time );
						value.toArray( values, values.length );

					}

					key = jsonKeys[ i ++ ];

				} while ( key !== undefined );

			} else {

				// otherwise push as-is

				do {

					value = key[ valuePropertyName ];

					if ( value !== undefined ) {

						times.push( key.time );
						values.push( value );

					}

					key = jsonKeys[ i ++ ];

				} while ( key !== undefined );

			}

		}

	};

	/**
	 * Abstract base class of interpolants over parametric samples.
	 *
	 * The parameter domain is one dimensional, typically the time or a path
	 * along a curve defined by the data.
	 *
	 * The sample values can have any dimensionality and derived classes may
	 * apply special interpretations to the data.
	 *
	 * This class provides the interval seek in a Template Method, deferring
	 * the actual interpolation to derived classes.
	 *
	 * Time complexity is O(1) for linear access crossing at most two points
	 * and O(log N) for random access, where N is the number of positions.
	 *
	 * References:
	 *
	 * 		http://www.oodesign.com/template-method-pattern.html
	 *
	 * @author tschw
	 */

	function Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		this.parameterPositions = parameterPositions;
		this._cachedIndex = 0;

		this.resultBuffer = resultBuffer !== undefined ?
			resultBuffer : new sampleValues.constructor( sampleSize );
		this.sampleValues = sampleValues;
		this.valueSize = sampleSize;

	}

	Object.assign( Interpolant.prototype, {

		evaluate: function ( t ) {

			var pp = this.parameterPositions,
				i1 = this._cachedIndex,

				t1 = pp[ i1 ],
				t0 = pp[ i1 - 1 ];

			validate_interval: {

				seek: {

					var right;

					linear_scan: {

						//- See http://jsperf.com/comparison-to-undefined/3
						//- slower code:
						//-
						//- 				if ( t >= t1 || t1 === undefined ) {
						forward_scan: if ( ! ( t < t1 ) ) {

							for ( var giveUpAt = i1 + 2; ; ) {

								if ( t1 === undefined ) {

									if ( t < t0 ) break forward_scan;

									// after end

									i1 = pp.length;
									this._cachedIndex = i1;
									return this.afterEnd_( i1 - 1, t, t0 );

								}

								if ( i1 === giveUpAt ) break; // this loop

								t0 = t1;
								t1 = pp[ ++ i1 ];

								if ( t < t1 ) {

									// we have arrived at the sought interval
									break seek;

								}

							}

							// prepare binary search on the right side of the index
							right = pp.length;
							break linear_scan;

						}

						//- slower code:
						//-					if ( t < t0 || t0 === undefined ) {
						if ( ! ( t >= t0 ) ) {

							// looping?

							var t1global = pp[ 1 ];

							if ( t < t1global ) {

								i1 = 2; // + 1, using the scan for the details
								t0 = t1global;

							}

							// linear reverse scan

							for ( var giveUpAt = i1 - 2; ; ) {

								if ( t0 === undefined ) {

									// before start

									this._cachedIndex = 0;
									return this.beforeStart_( 0, t, t1 );

								}

								if ( i1 === giveUpAt ) break; // this loop

								t1 = t0;
								t0 = pp[ -- i1 - 1 ];

								if ( t >= t0 ) {

									// we have arrived at the sought interval
									break seek;

								}

							}

							// prepare binary search on the left side of the index
							right = i1;
							i1 = 0;
							break linear_scan;

						}

						// the interval is valid

						break validate_interval;

					} // linear scan

					// binary search

					while ( i1 < right ) {

						var mid = ( i1 + right ) >>> 1;

						if ( t < pp[ mid ] ) {

							right = mid;

						} else {

							i1 = mid + 1;

						}

					}

					t1 = pp[ i1 ];
					t0 = pp[ i1 - 1 ];

					// check boundary cases, again

					if ( t0 === undefined ) {

						this._cachedIndex = 0;
						return this.beforeStart_( 0, t, t1 );

					}

					if ( t1 === undefined ) {

						i1 = pp.length;
						this._cachedIndex = i1;
						return this.afterEnd_( i1 - 1, t0, t );

					}

				} // seek

				this._cachedIndex = i1;

				this.intervalChanged_( i1, t0, t1 );

			} // validate_interval

			return this.interpolate_( i1, t0, t, t1 );

		},

		settings: null, // optional, subclass-specific settings structure
		// Note: The indirection allows central control of many interpolants.

		// --- Protected interface

		DefaultSettings_: {},

		getSettings_: function () {

			return this.settings || this.DefaultSettings_;

		},

		copySampleValue_: function ( index ) {

			// copies a sample value to the result buffer

			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
				offset = index * stride;

			for ( var i = 0; i !== stride; ++ i ) {

				result[ i ] = values[ offset + i ];

			}

			return result;

		},

		// Template methods for derived classes:

		interpolate_: function ( /* i1, t0, t, t1 */ ) {

			throw new Error( 'call to abstract method' );
			// implementations shall return this.resultBuffer

		},

		intervalChanged_: function ( /* i1, t0, t1 */ ) {

			// empty

		}

	} );

	//!\ DECLARE ALIAS AFTER assign prototype !
	Object.assign( Interpolant.prototype, {

		//( 0, t, t0 ), returns this.resultBuffer
		beforeStart_: Interpolant.prototype.copySampleValue_,

		//( N-1, tN-1, t ), returns this.resultBuffer
		afterEnd_: Interpolant.prototype.copySampleValue_,

	} );

	/**
	 * Fast and simple cubic spline interpolant.
	 *
	 * It was derived from a Hermitian construction setting the first derivative
	 * at each sample position to the linear slope between neighboring positions
	 * over their parameter interval.
	 *
	 * @author tschw
	 */

	function CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

		this._weightPrev = - 0;
		this._offsetPrev = - 0;
		this._weightNext = - 0;
		this._offsetNext = - 0;

	}

	CubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: CubicInterpolant,

		DefaultSettings_: {

			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding

		},

		intervalChanged_: function ( i1, t0, t1 ) {

			var pp = this.parameterPositions,
				iPrev = i1 - 2,
				iNext = i1 + 1,

				tPrev = pp[ iPrev ],
				tNext = pp[ iNext ];

			if ( tPrev === undefined ) {

				switch ( this.getSettings_().endingStart ) {

					case ZeroSlopeEnding:

						// f'(t0) = 0
						iPrev = i1;
						tPrev = 2 * t0 - t1;

						break;

					case WrapAroundEnding:

						// use the other end of the curve
						iPrev = pp.length - 2;
						tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

						break;

					default: // ZeroCurvatureEnding

						// f''(t0) = 0 a.k.a. Natural Spline
						iPrev = i1;
						tPrev = t1;

				}

			}

			if ( tNext === undefined ) {

				switch ( this.getSettings_().endingEnd ) {

					case ZeroSlopeEnding:

						// f'(tN) = 0
						iNext = i1;
						tNext = 2 * t1 - t0;

						break;

					case WrapAroundEnding:

						// use the other end of the curve
						iNext = 1;
						tNext = t1 + pp[ 1 ] - pp[ 0 ];

						break;

					default: // ZeroCurvatureEnding

						// f''(tN) = 0, a.k.a. Natural Spline
						iNext = i1 - 1;
						tNext = t0;

				}

			}

			var halfDt = ( t1 - t0 ) * 0.5,
				stride = this.valueSize;

			this._weightPrev = halfDt / ( t0 - tPrev );
			this._weightNext = halfDt / ( tNext - t1 );
			this._offsetPrev = iPrev * stride;
			this._offsetNext = iNext * stride;

		},

		interpolate_: function ( i1, t0, t, t1 ) {

			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				o1 = i1 * stride,		o0 = o1 - stride,
				oP = this._offsetPrev, 	oN = this._offsetNext,
				wP = this._weightPrev,	wN = this._weightNext,

				p = ( t - t0 ) / ( t1 - t0 ),
				pp = p * p,
				ppp = pp * p;

			// evaluate polynomials

			var sP = - wP * ppp + 2 * wP * pp - wP * p;
			var s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
			var s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
			var sN = wN * ppp - wN * pp;

			// combine data linearly

			for ( var i = 0; i !== stride; ++ i ) {

				result[ i ] =
						sP * values[ oP + i ] +
						s0 * values[ o0 + i ] +
						s1 * values[ o1 + i ] +
						sN * values[ oN + i ];

			}

			return result;

		}

	} );

	/**
	 * @author tschw
	 */

	function LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	LinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: LinearInterpolant,

		interpolate_: function ( i1, t0, t, t1 ) {

			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				offset1 = i1 * stride,
				offset0 = offset1 - stride,

				weight1 = ( t - t0 ) / ( t1 - t0 ),
				weight0 = 1 - weight1;

			for ( var i = 0; i !== stride; ++ i ) {

				result[ i ] =
						values[ offset0 + i ] * weight0 +
						values[ offset1 + i ] * weight1;

			}

			return result;

		}

	} );

	/**
	 *
	 * Interpolant that evaluates to the sample value at the position preceeding
	 * the parameter.
	 *
	 * @author tschw
	 */

	function DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	DiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: DiscreteInterpolant,

		interpolate_: function ( i1 /*, t0, t, t1 */ ) {

			return this.copySampleValue_( i1 - 1 );

		}

	} );

	/**
	 *
	 * A timed sequence of keyframes for a specific property.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function KeyframeTrack( name, times, values, interpolation ) {

		if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
		if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );

		this.name = name;

		this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
		this.values = AnimationUtils.convertArray( values, this.ValueBufferType );

		this.setInterpolation( interpolation || this.DefaultInterpolation );

	}

	// Static methods

	Object.assign( KeyframeTrack, {

		// Serialization (in static context, because of constructor invocation
		// and automatic invocation of .toJSON):

		toJSON: function ( track ) {

			var trackType = track.constructor;

			var json;

			// derived classes can define a static toJSON method
			if ( trackType.toJSON !== undefined ) {

				json = trackType.toJSON( track );

			} else {

				// by default, we assume the data can be serialized as-is
				json = {

					'name': track.name,
					'times': AnimationUtils.convertArray( track.times, Array ),
					'values': AnimationUtils.convertArray( track.values, Array )

				};

				var interpolation = track.getInterpolation();

				if ( interpolation !== track.DefaultInterpolation ) {

					json.interpolation = interpolation;

				}

			}

			json.type = track.ValueTypeName; // mandatory

			return json;

		}

	} );

	Object.assign( KeyframeTrack.prototype, {

		constructor: KeyframeTrack,

		TimeBufferType: Float32Array,

		ValueBufferType: Float32Array,

		DefaultInterpolation: InterpolateLinear,

		InterpolantFactoryMethodDiscrete: function ( result ) {

			return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

		},

		InterpolantFactoryMethodLinear: function ( result ) {

			return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );

		},

		InterpolantFactoryMethodSmooth: function ( result ) {

			return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );

		},

		setInterpolation: function ( interpolation ) {

			var factoryMethod;

			switch ( interpolation ) {

				case InterpolateDiscrete:

					factoryMethod = this.InterpolantFactoryMethodDiscrete;

					break;

				case InterpolateLinear:

					factoryMethod = this.InterpolantFactoryMethodLinear;

					break;

				case InterpolateSmooth:

					factoryMethod = this.InterpolantFactoryMethodSmooth;

					break;

			}

			if ( factoryMethod === undefined ) {

				var message = "unsupported interpolation for " +
					this.ValueTypeName + " keyframe track named " + this.name;

				if ( this.createInterpolant === undefined ) {

					// fall back to default, unless the default itself is messed up
					if ( interpolation !== this.DefaultInterpolation ) {

						this.setInterpolation( this.DefaultInterpolation );

					} else {

						throw new Error( message ); // fatal, in this case

					}

				}

				console.warn( 'THREE.KeyframeTrack:', message );
				return this;

			}

			this.createInterpolant = factoryMethod;

			return this;

		},

		getInterpolation: function () {

			switch ( this.createInterpolant ) {

				case this.InterpolantFactoryMethodDiscrete:

					return InterpolateDiscrete;

				case this.InterpolantFactoryMethodLinear:

					return InterpolateLinear;

				case this.InterpolantFactoryMethodSmooth:

					return InterpolateSmooth;

			}

		},

		getValueSize: function () {

			return this.values.length / this.times.length;

		},

		// move all keyframes either forwards or backwards in time
		shift: function ( timeOffset ) {

			if ( timeOffset !== 0.0 ) {

				var times = this.times;

				for ( var i = 0, n = times.length; i !== n; ++ i ) {

					times[ i ] += timeOffset;

				}

			}

			return this;

		},

		// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
		scale: function ( timeScale ) {

			if ( timeScale !== 1.0 ) {

				var times = this.times;

				for ( var i = 0, n = times.length; i !== n; ++ i ) {

					times[ i ] *= timeScale;

				}

			}

			return this;

		},

		// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
		// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
		trim: function ( startTime, endTime ) {

			var times = this.times,
				nKeys = times.length,
				from = 0,
				to = nKeys - 1;

			while ( from !== nKeys && times[ from ] < startTime ) {

				++ from;

			}

			while ( to !== - 1 && times[ to ] > endTime ) {

				-- to;

			}

			++ to; // inclusive -> exclusive bound

			if ( from !== 0 || to !== nKeys ) {

				// empty tracks are forbidden, so keep at least one keyframe
				if ( from >= to ) to = Math.max( to, 1 ), from = to - 1;

				var stride = this.getValueSize();
				this.times = AnimationUtils.arraySlice( times, from, to );
				this.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );

			}

			return this;

		},

		// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
		validate: function () {

			var valid = true;

			var valueSize = this.getValueSize();
			if ( valueSize - Math.floor( valueSize ) !== 0 ) {

				console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
				valid = false;

			}

			var times = this.times,
				values = this.values,

				nKeys = times.length;

			if ( nKeys === 0 ) {

				console.error( 'THREE.KeyframeTrack: Track is empty.', this );
				valid = false;

			}

			var prevTime = null;

			for ( var i = 0; i !== nKeys; i ++ ) {

				var currTime = times[ i ];

				if ( typeof currTime === 'number' && isNaN( currTime ) ) {

					console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
					valid = false;
					break;

				}

				if ( prevTime !== null && prevTime > currTime ) {

					console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
					valid = false;
					break;

				}

				prevTime = currTime;

			}

			if ( values !== undefined ) {

				if ( AnimationUtils.isTypedArray( values ) ) {

					for ( var i = 0, n = values.length; i !== n; ++ i ) {

						var value = values[ i ];

						if ( isNaN( value ) ) {

							console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
							valid = false;
							break;

						}

					}

				}

			}

			return valid;

		},

		// removes equivalent sequential keys as common in morph target sequences
		// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
		optimize: function () {

			var times = this.times,
				values = this.values,
				stride = this.getValueSize(),

				smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

				writeIndex = 1,
				lastIndex = times.length - 1;

			for ( var i = 1; i < lastIndex; ++ i ) {

				var keep = false;

				var time = times[ i ];
				var timeNext = times[ i + 1 ];

				// remove adjacent keyframes scheduled at the same time

				if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {

					if ( ! smoothInterpolation ) {

						// remove unnecessary keyframes same as their neighbors

						var offset = i * stride,
							offsetP = offset - stride,
							offsetN = offset + stride;

						for ( var j = 0; j !== stride; ++ j ) {

							var value = values[ offset + j ];

							if ( value !== values[ offsetP + j ] ||
								value !== values[ offsetN + j ] ) {

								keep = true;
								break;

							}

						}

					} else {

						keep = true;

					}

				}

				// in-place compaction

				if ( keep ) {

					if ( i !== writeIndex ) {

						times[ writeIndex ] = times[ i ];

						var readOffset = i * stride,
							writeOffset = writeIndex * stride;

						for ( var j = 0; j !== stride; ++ j ) {

							values[ writeOffset + j ] = values[ readOffset + j ];

						}

					}

					++ writeIndex;

				}

			}

			// flush last keyframe (compaction looks ahead)

			if ( lastIndex > 0 ) {

				times[ writeIndex ] = times[ lastIndex ];

				for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {

					values[ writeOffset + j ] = values[ readOffset + j ];

				}

				++ writeIndex;

			}

			if ( writeIndex !== times.length ) {

				this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
				this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );

			}

			return this;

		},

		clone: function () {

			var times = AnimationUtils.arraySlice( this.times, 0 );
			var values = AnimationUtils.arraySlice( this.values, 0 );

			var TypedKeyframeTrack = this.constructor;
			var track = new TypedKeyframeTrack( this.name, times, values );

			// Interpolant argument to constructor is not saved, so copy the factory method directly.
			track.createInterpolant = this.createInterpolant;

			return track;

		}

	} );

	/**
	 *
	 * A Track of Boolean keyframe values.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function BooleanKeyframeTrack( name, times, values ) {

		KeyframeTrack.call( this, name, times, values );

	}

	BooleanKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: BooleanKeyframeTrack,

		ValueTypeName: 'bool',
		ValueBufferType: Array,

		DefaultInterpolation: InterpolateDiscrete,

		InterpolantFactoryMethodLinear: undefined,
		InterpolantFactoryMethodSmooth: undefined

		// Note: Actually this track could have a optimized / compressed
		// representation of a single value and a custom interpolant that
		// computes "firstValue ^ isOdd( index )".

	} );

	/**
	 *
	 * A Track of keyframe values that represent color.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function ColorKeyframeTrack( name, times, values, interpolation ) {

		KeyframeTrack.call( this, name, times, values, interpolation );

	}

	ColorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: ColorKeyframeTrack,

		ValueTypeName: 'color'

		// ValueBufferType is inherited

		// DefaultInterpolation is inherited

		// Note: Very basic implementation and nothing special yet.
		// However, this is the place for color space parameterization.

	} );

	/**
	 *
	 * A Track of numeric keyframe values.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function NumberKeyframeTrack( name, times, values, interpolation ) {

		KeyframeTrack.call( this, name, times, values, interpolation );

	}

	NumberKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: NumberKeyframeTrack,

		ValueTypeName: 'number'

		// ValueBufferType is inherited

		// DefaultInterpolation is inherited

	} );

	/**
	 * Spherical linear unit quaternion interpolant.
	 *
	 * @author tschw
	 */

	function QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	QuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: QuaternionLinearInterpolant,

		interpolate_: function ( i1, t0, t, t1 ) {

			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				offset = i1 * stride,

				alpha = ( t - t0 ) / ( t1 - t0 );

			for ( var end = offset + stride; offset !== end; offset += 4 ) {

				Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

			}

			return result;

		}

	} );

	/**
	 *
	 * A Track of quaternion keyframe values.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function QuaternionKeyframeTrack( name, times, values, interpolation ) {

		KeyframeTrack.call( this, name, times, values, interpolation );

	}

	QuaternionKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: QuaternionKeyframeTrack,

		ValueTypeName: 'quaternion',

		// ValueBufferType is inherited

		DefaultInterpolation: InterpolateLinear,

		InterpolantFactoryMethodLinear: function ( result ) {

			return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

		},

		InterpolantFactoryMethodSmooth: undefined // not yet implemented

	} );

	/**
	 *
	 * A Track that interpolates Strings
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function StringKeyframeTrack( name, times, values, interpolation ) {

		KeyframeTrack.call( this, name, times, values, interpolation );

	}

	StringKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: StringKeyframeTrack,

		ValueTypeName: 'string',
		ValueBufferType: Array,

		DefaultInterpolation: InterpolateDiscrete,

		InterpolantFactoryMethodLinear: undefined,

		InterpolantFactoryMethodSmooth: undefined

	} );

	/**
	 *
	 * A Track of vectored keyframe values.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function VectorKeyframeTrack( name, times, values, interpolation ) {

		KeyframeTrack.call( this, name, times, values, interpolation );

	}

	VectorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: VectorKeyframeTrack,

		ValueTypeName: 'vector'

		// ValueBufferType is inherited

		// DefaultInterpolation is inherited

	} );

	/**
	 *
	 * Reusable set of Tracks that represent an animation.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */

	function AnimationClip( name, duration, tracks ) {

		this.name = name;
		this.tracks = tracks;
		this.duration = ( duration !== undefined ) ? duration : - 1;

		this.uuid = _Math.generateUUID();

		// this means it should figure out its duration by scanning the tracks
		if ( this.duration < 0 ) {

			this.resetDuration();

		}

	}

	function getTrackTypeForValueTypeName( typeName ) {

		switch ( typeName.toLowerCase() ) {

			case 'scalar':
			case 'double':
			case 'float':
			case 'number':
			case 'integer':

				return NumberKeyframeTrack;

			case 'vector':
			case 'vector2':
			case 'vector3':
			case 'vector4':

				return VectorKeyframeTrack;

			case 'color':

				return ColorKeyframeTrack;

			case 'quaternion':

				return QuaternionKeyframeTrack;

			case 'bool':
			case 'boolean':

				return BooleanKeyframeTrack;

			case 'string':

				return StringKeyframeTrack;

		}

		throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );

	}

	function parseKeyframeTrack( json ) {

		if ( json.type === undefined ) {

			throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );

		}

		var trackType = getTrackTypeForValueTypeName( json.type );

		if ( json.times === undefined ) {

			var times = [], values = [];

			AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

			json.times = times;
			json.values = values;

		}

		// derived classes can define a static parse method
		if ( trackType.parse !== undefined ) {

			return trackType.parse( json );

		} else {

			// by default, we assume a constructor compatible with the base
			return new trackType( json.name, json.times, json.values, json.interpolation );

		}

	}

	Object.assign( AnimationClip, {

		parse: function ( json ) {

			var tracks = [],
				jsonTracks = json.tracks,
				frameTime = 1.0 / ( json.fps || 1.0 );

			for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {

				tracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );

			}

			return new AnimationClip( json.name, json.duration, tracks );

		},

		toJSON: function ( clip ) {

			var tracks = [],
				clipTracks = clip.tracks;

			var json = {

				'name': clip.name,
				'duration': clip.duration,
				'tracks': tracks,
				'uuid': clip.uuid

			};

			for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {

				tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

			}

			return json;

		},

		CreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {

			var numMorphTargets = morphTargetSequence.length;
			var tracks = [];

			for ( var i = 0; i < numMorphTargets; i ++ ) {

				var times = [];
				var values = [];

				times.push(
					( i + numMorphTargets - 1 ) % numMorphTargets,
					i,
					( i + 1 ) % numMorphTargets );

				values.push( 0, 1, 0 );

				var order = AnimationUtils.getKeyframeOrder( times );
				times = AnimationUtils.sortedArray( times, 1, order );
				values = AnimationUtils.sortedArray( values, 1, order );

				// if there is a key at the first frame, duplicate it as the
				// last frame as well for perfect loop.
				if ( ! noLoop && times[ 0 ] === 0 ) {

					times.push( numMorphTargets );
					values.push( values[ 0 ] );

				}

				tracks.push(
					new NumberKeyframeTrack(
						'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
						times, values
					).scale( 1.0 / fps ) );

			}

			return new AnimationClip( name, - 1, tracks );

		},

		findByName: function ( objectOrClipArray, name ) {

			var clipArray = objectOrClipArray;

			if ( ! Array.isArray( objectOrClipArray ) ) {

				var o = objectOrClipArray;
				clipArray = o.geometry && o.geometry.animations || o.animations;

			}

			for ( var i = 0; i < clipArray.length; i ++ ) {

				if ( clipArray[ i ].name === name ) {

					return clipArray[ i ];

				}

			}

			return null;

		},

		CreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {

			var animationToMorphTargets = {};

			// tested with https://regex101.com/ on trick sequences
			// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
			var pattern = /^([\w-]*?)([\d]+)$/;

			// sort morph target names into animation groups based
			// patterns like Walk_001, Walk_002, Run_001, Run_002
			for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

				var morphTarget = morphTargets[ i ];
				var parts = morphTarget.name.match( pattern );

				if ( parts && parts.length > 1 ) {

					var name = parts[ 1 ];

					var animationMorphTargets = animationToMorphTargets[ name ];
					if ( ! animationMorphTargets ) {

						animationToMorphTargets[ name ] = animationMorphTargets = [];

					}

					animationMorphTargets.push( morphTarget );

				}

			}

			var clips = [];

			for ( var name in animationToMorphTargets ) {

				clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

			}

			return clips;

		},

		// parse the animation.hierarchy format
		parseAnimation: function ( animation, bones ) {

			if ( ! animation ) {

				console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
				return null;

			}

			var addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

				// only return track if there are actually keys.
				if ( animationKeys.length !== 0 ) {

					var times = [];
					var values = [];

					AnimationUtils.flattenJSON( animationKeys, times, values, propertyName );

					// empty keys are filtered out, so check again
					if ( times.length !== 0 ) {

						destTracks.push( new trackType( trackName, times, values ) );

					}

				}

			};

			var tracks = [];

			var clipName = animation.name || 'default';
			// automatic length determination in AnimationClip.
			var duration = animation.length || - 1;
			var fps = animation.fps || 30;

			var hierarchyTracks = animation.hierarchy || [];

			for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

				var animationKeys = hierarchyTracks[ h ].keys;

				// skip empty tracks
				if ( ! animationKeys || animationKeys.length === 0 ) continue;

				// process morph targets
				if ( animationKeys[ 0 ].morphTargets ) {

					// figure out all morph targets used in this track
					var morphTargetNames = {};

					for ( var k = 0; k < animationKeys.length; k ++ ) {

						if ( animationKeys[ k ].morphTargets ) {

							for ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

								morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

							}

						}

					}

					// create a track for each morph target with all zero
					// morphTargetInfluences except for the keys in which
					// the morphTarget is named.
					for ( var morphTargetName in morphTargetNames ) {

						var times = [];
						var values = [];

						for ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

							var animationKey = animationKeys[ k ];

							times.push( animationKey.time );
							values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

						}

						tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

					}

					duration = morphTargetNames.length * ( fps || 1.0 );

				} else {

					// ...assume skeletal animation

					var boneName = '.bones[' + bones[ h ].name + ']';

					addNonemptyTrack(
						VectorKeyframeTrack, boneName + '.position',
						animationKeys, 'pos', tracks );

					addNonemptyTrack(
						QuaternionKeyframeTrack, boneName + '.quaternion',
						animationKeys, 'rot', tracks );

					addNonemptyTrack(
						VectorKeyframeTrack, boneName + '.scale',
						animationKeys, 'scl', tracks );

				}

			}

			if ( tracks.length === 0 ) {

				return null;

			}

			var clip = new AnimationClip( clipName, duration, tracks );

			return clip;

		}

	} );

	Object.assign( AnimationClip.prototype, {

		resetDuration: function () {

			var tracks = this.tracks, duration = 0;

			for ( var i = 0, n = tracks.length; i !== n; ++ i ) {

				var track = this.tracks[ i ];

				duration = Math.max( duration, track.times[ track.times.length - 1 ] );

			}

			this.duration = duration;

			return this;

		},

		trim: function () {

			for ( var i = 0; i < this.tracks.length; i ++ ) {

				this.tracks[ i ].trim( 0, this.duration );

			}

			return this;

		},

		validate: function () {

			var valid = true;

			for ( var i = 0; i < this.tracks.length; i ++ ) {

				valid = valid && this.tracks[ i ].validate();

			}

			return valid;

		},

		optimize: function () {

			for ( var i = 0; i < this.tracks.length; i ++ ) {

				this.tracks[ i ].optimize();

			}

			return this;

		},


		clone: function () {

			var tracks = [];

			for ( var i = 0; i < this.tracks.length; i ++ ) {

				tracks.push( this.tracks[ i ].clone() );

			}

			return new AnimationClip( this.name, this.duration, tracks );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var Cache = {

		enabled: false,

		files: {},

		add: function ( key, file ) {

			if ( this.enabled === false ) return;

			// console.log( 'THREE.Cache', 'Adding key:', key );

			this.files[ key ] = file;

		},

		get: function ( key ) {

			if ( this.enabled === false ) return;

			// console.log( 'THREE.Cache', 'Checking key:', key );

			return this.files[ key ];

		},

		remove: function ( key ) {

			delete this.files[ key ];

		},

		clear: function () {

			this.files = {};

		}

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function LoadingManager( onLoad, onProgress, onError ) {

		var scope = this;

		var isLoading = false;
		var itemsLoaded = 0;
		var itemsTotal = 0;
		var urlModifier = undefined;

		// Refer to #5689 for the reason why we don't set .onStart
		// in the constructor

		this.onStart = undefined;
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;

		this.itemStart = function ( url ) {

			itemsTotal ++;

			if ( isLoading === false ) {

				if ( scope.onStart !== undefined ) {

					scope.onStart( url, itemsLoaded, itemsTotal );

				}

			}

			isLoading = true;

		};

		this.itemEnd = function ( url ) {

			itemsLoaded ++;

			if ( scope.onProgress !== undefined ) {

				scope.onProgress( url, itemsLoaded, itemsTotal );

			}

			if ( itemsLoaded === itemsTotal ) {

				isLoading = false;

				if ( scope.onLoad !== undefined ) {

					scope.onLoad();

				}

			}

		};

		this.itemError = function ( url ) {

			if ( scope.onError !== undefined ) {

				scope.onError( url );

			}

		};

		this.resolveURL = function ( url ) {

			if ( urlModifier ) {

				return urlModifier( url );

			}

			return url;

		};

		this.setURLModifier = function ( transform ) {

			urlModifier = transform;
			return this;

		};

	}

	var DefaultLoadingManager = new LoadingManager();

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var loading = {};

	function FileLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( FileLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			if ( url === undefined ) url = '';

			if ( this.path !== undefined ) url = this.path + url;

			url = this.manager.resolveURL( url );

			var scope = this;

			var cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			// Check if request is duplicate

			if ( loading[ url ] !== undefined ) {

				loading[ url ].push( {

					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError

				} );

				return;

			}

			// Check for data: URI
			var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
			var dataUriRegexResult = url.match( dataUriRegex );

			// Safari can not handle Data URIs through XMLHttpRequest so process manually
			if ( dataUriRegexResult ) {

				var mimeType = dataUriRegexResult[ 1 ];
				var isBase64 = !! dataUriRegexResult[ 2 ];
				var data = dataUriRegexResult[ 3 ];

				data = decodeURIComponent( data );

				if ( isBase64 ) data = atob( data );

				try {

					var response;
					var responseType = ( this.responseType || '' ).toLowerCase();

					switch ( responseType ) {

						case 'arraybuffer':
						case 'blob':

							var view = new Uint8Array( data.length );

							for ( var i = 0; i < data.length; i ++ ) {

								view[ i ] = data.charCodeAt( i );

							}

							if ( responseType === 'blob' ) {

								response = new Blob( [ view.buffer ], { type: mimeType } );

							} else {

								response = view.buffer;

							}

							break;

						case 'document':

							var parser = new DOMParser();
							response = parser.parseFromString( data, mimeType );

							break;

						case 'json':

							response = JSON.parse( data );

							break;

						default: // 'text' or other

							response = data;

							break;

					}

					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					setTimeout( function () {

						if ( onLoad ) onLoad( response );

						scope.manager.itemEnd( url );

					}, 0 );

				} catch ( error ) {

					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					setTimeout( function () {

						if ( onError ) onError( error );

						scope.manager.itemError( url );
						scope.manager.itemEnd( url );

					}, 0 );

				}

			} else {

				// Initialise array for duplicate requests

				loading[ url ] = [];

				loading[ url ].push( {

					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError

				} );

				var request = new XMLHttpRequest();

				request.open( 'GET', url, true );

				request.addEventListener( 'load', function ( event ) {

					var response = this.response;

					Cache.add( url, response );

					var callbacks = loading[ url ];

					delete loading[ url ];

					if ( this.status === 200 || this.status === 0 ) {

						// Some browsers return HTTP Status 0 when using non-http protocol
						// e.g. 'file://' or 'data://'. Handle as success.

						if ( this.status === 0 ) console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

						for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

							var callback = callbacks[ i ];
							if ( callback.onLoad ) callback.onLoad( response );

						}

						scope.manager.itemEnd( url );

					} else {

						for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

							var callback = callbacks[ i ];
							if ( callback.onError ) callback.onError( event );

						}

						scope.manager.itemError( url );
						scope.manager.itemEnd( url );

					}

				}, false );

				request.addEventListener( 'progress', function ( event ) {

					var callbacks = loading[ url ];

					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

						var callback = callbacks[ i ];
						if ( callback.onProgress ) callback.onProgress( event );

					}

				}, false );

				request.addEventListener( 'error', function ( event ) {

					var callbacks = loading[ url ];

					delete loading[ url ];

					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

						var callback = callbacks[ i ];
						if ( callback.onError ) callback.onError( event );

					}

					scope.manager.itemError( url );
					scope.manager.itemEnd( url );

				}, false );

				request.addEventListener( 'abort', function ( event ) {

					var callbacks = loading[ url ];

					delete loading[ url ];

					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

						var callback = callbacks[ i ];
						if ( callback.onError ) callback.onError( event );

					}

					scope.manager.itemError( url );
					scope.manager.itemEnd( url );

				}, false );

				if ( this.responseType !== undefined ) request.responseType = this.responseType;
				if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

				if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );

				for ( var header in this.requestHeader ) {

					request.setRequestHeader( header, this.requestHeader[ header ] );

				}

				request.send( null );

			}

			scope.manager.itemStart( url );

			return request;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		},

		setResponseType: function ( value ) {

			this.responseType = value;
			return this;

		},

		setWithCredentials: function ( value ) {

			this.withCredentials = value;
			return this;

		},

		setMimeType: function ( value ) {

			this.mimeType = value;
			return this;

		},

		setRequestHeader: function ( value ) {

			this.requestHeader = value;
			return this;

		}

	} );

	/**
	 * @author bhouston / http://clara.io/
	 */

	function AnimationLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( AnimationLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new FileLoader( scope.manager );
			loader.setPath( scope.path );
			loader.load( url, function ( text ) {

				onLoad( scope.parse( JSON.parse( text ) ) );

			}, onProgress, onError );

		},

		parse: function ( json ) {

			var animations = [];

			for ( var i = 0; i < json.length; i ++ ) {

				var clip = AnimationClip.parse( json[ i ] );

				animations.push( clip );

			}

			return animations;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 */

	function CompressedTextureLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		// override in sub classes
		this._parser = null;

	}

	Object.assign( CompressedTextureLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var images = [];

			var texture = new CompressedTexture();
			texture.image = images;

			var loader = new FileLoader( this.manager );
			loader.setPath( this.path );
			loader.setResponseType( 'arraybuffer' );

			function loadTexture( i ) {

				loader.load( url[ i ], function ( buffer ) {

					var texDatas = scope._parser( buffer, true );

					images[ i ] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps
					};

					loaded += 1;

					if ( loaded === 6 ) {

						if ( texDatas.mipmapCount === 1 )
							texture.minFilter = LinearFilter;

						texture.format = texDatas.format;
						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}

				}, onProgress, onError );

			}

			if ( Array.isArray( url ) ) {

				var loaded = 0;

				for ( var i = 0, il = url.length; i < il; ++ i ) {

					loadTexture( i );

				}

			} else {

				// compressed cubemap texture stored in a single DDS file

				loader.load( url, function ( buffer ) {

					var texDatas = scope._parser( buffer, true );

					if ( texDatas.isCubemap ) {

						var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

						for ( var f = 0; f < faces; f ++ ) {

							images[ f ] = { mipmaps: [] };

							for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

								images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
								images[ f ].format = texDatas.format;
								images[ f ].width = texDatas.width;
								images[ f ].height = texDatas.height;

							}

						}

					} else {

						texture.image.width = texDatas.width;
						texture.image.height = texDatas.height;
						texture.mipmaps = texDatas.mipmaps;

					}

					if ( texDatas.mipmapCount === 1 ) {

						texture.minFilter = LinearFilter;

					}

					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}, onProgress, onError );

			}

			return texture;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author Nikos M. / https://github.com/foo123/
	 *
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 */

	function DataTextureLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		// override in sub classes
		this._parser = null;

	}

	Object.assign( DataTextureLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var texture = new DataTexture();

			var loader = new FileLoader( this.manager );
			loader.setResponseType( 'arraybuffer' );
			loader.setPath( this.path );
			loader.load( url, function ( buffer ) {

				var texData = scope._parser( buffer );

				if ( ! texData ) return;

				if ( texData.image !== undefined ) {

					texture.image = texData.image;

				} else if ( texData.data !== undefined ) {

					texture.image.width = texData.width;
					texture.image.height = texData.height;
					texture.image.data = texData.data;

				}

				texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
				texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;

				texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
				texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearMipMapLinearFilter;

				texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

				if ( texData.format !== undefined ) {

					texture.format = texData.format;

				}
				if ( texData.type !== undefined ) {

					texture.type = texData.type;

				}

				if ( texData.mipmaps !== undefined ) {

					texture.mipmaps = texData.mipmaps;

				}

				if ( texData.mipmapCount === 1 ) {

					texture.minFilter = LinearFilter;

				}

				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture, texData );

			}, onProgress, onError );


			return texture;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */


	function ImageLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( ImageLoader.prototype, {

		crossOrigin: 'anonymous',

		load: function ( url, onLoad, onProgress, onError ) {

			if ( url === undefined ) url = '';

			if ( this.path !== undefined ) url = this.path + url;

			url = this.manager.resolveURL( url );

			var scope = this;

			var cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );

			function onImageLoad() {

				image.removeEventListener( 'load', onImageLoad, false );
				image.removeEventListener( 'error', onImageError, false );

				Cache.add( url, this );

				if ( onLoad ) onLoad( this );

				scope.manager.itemEnd( url );

			}

			function onImageError( event ) {

				image.removeEventListener( 'load', onImageLoad, false );
				image.removeEventListener( 'error', onImageError, false );

				if ( onError ) onError( event );

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			}

			image.addEventListener( 'load', onImageLoad, false );
			image.addEventListener( 'error', onImageError, false );

			if ( url.substr( 0, 5 ) !== 'data:' ) {

				if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

			}

			scope.manager.itemStart( url );

			image.src = url;

			return image;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;
			return this;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */


	function CubeTextureLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( CubeTextureLoader.prototype, {

		crossOrigin: 'anonymous',

		load: function ( urls, onLoad, onProgress, onError ) {

			var texture = new CubeTexture();

			var loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );

			var loaded = 0;

			function loadTexture( i ) {

				loader.load( urls[ i ], function ( image ) {

					texture.images[ i ] = image;

					loaded ++;

					if ( loaded === 6 ) {

						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}

				}, undefined, onError );

			}

			for ( var i = 0; i < urls.length; ++ i ) {

				loadTexture( i );

			}

			return texture;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;
			return this;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */


	function TextureLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( TextureLoader.prototype, {

		crossOrigin: 'anonymous',

		load: function ( url, onLoad, onProgress, onError ) {

			var texture = new Texture();

			var loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );

			loader.load( url, function ( image ) {

				texture.image = image;

				// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
				var isJPEG = url.search( /\.jpe?g($|\?)/i ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

				texture.format = isJPEG ? RGBFormat : RGBAFormat;
				texture.needsUpdate = true;

				if ( onLoad !== undefined ) {

					onLoad( texture );

				}

			}, onProgress, onError );

			return texture;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;
			return this;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Extensible curve object
	 *
	 * Some common of curve methods:
	 * .getPoint( t, optionalTarget ), .getTangent( t )
	 * .getPointAt( u, optionalTarget ), .getTangentAt( u )
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following curves inherit from THREE.Curve:
	 *
	 * -- 2D curves --
	 * THREE.ArcCurve
	 * THREE.CubicBezierCurve
	 * THREE.EllipseCurve
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.SplineCurve
	 *
	 * -- 3D curves --
	 * THREE.CatmullRomCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath.
	 *
	 **/

	/**************************************************************
	 *	Abstract Curve base class
	 **************************************************************/

	function Curve() {

		this.type = 'Curve';

		this.arcLengthDivisions = 200;

	}

	Object.assign( Curve.prototype, {

		// Virtual base class method to overwrite and implement in subclasses
		//	- t [0 .. 1]

		getPoint: function ( /* t, optionalTarget */ ) {

			console.warn( 'THREE.Curve: .getPoint() not implemented.' );
			return null;

		},

		// Get point at relative position in curve according to arc length
		// - u [0 .. 1]

		getPointAt: function ( u, optionalTarget ) {

			var t = this.getUtoTmapping( u );
			return this.getPoint( t, optionalTarget );

		},

		// Get sequence of points using getPoint( t )

		getPoints: function ( divisions ) {

			if ( divisions === undefined ) divisions = 5;

			var points = [];

			for ( var d = 0; d <= divisions; d ++ ) {

				points.push( this.getPoint( d / divisions ) );

			}

			return points;

		},

		// Get sequence of points using getPointAt( u )

		getSpacedPoints: function ( divisions ) {

			if ( divisions === undefined ) divisions = 5;

			var points = [];

			for ( var d = 0; d <= divisions; d ++ ) {

				points.push( this.getPointAt( d / divisions ) );

			}

			return points;

		},

		// Get total curve arc length

		getLength: function () {

			var lengths = this.getLengths();
			return lengths[ lengths.length - 1 ];

		},

		// Get list of cumulative segment lengths

		getLengths: function ( divisions ) {

			if ( divisions === undefined ) divisions = this.arcLengthDivisions;

			if ( this.cacheArcLengths &&
				( this.cacheArcLengths.length === divisions + 1 ) &&
				! this.needsUpdate ) {

				return this.cacheArcLengths;

			}

			this.needsUpdate = false;

			var cache = [];
			var current, last = this.getPoint( 0 );
			var p, sum = 0;

			cache.push( 0 );

			for ( p = 1; p <= divisions; p ++ ) {

				current = this.getPoint( p / divisions );
				sum += current.distanceTo( last );
				cache.push( sum );
				last = current;

			}

			this.cacheArcLengths = cache;

			return cache; // { sums: cache, sum: sum }; Sum is in the last element.

		},

		updateArcLengths: function () {

			this.needsUpdate = true;
			this.getLengths();

		},

		// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

		getUtoTmapping: function ( u, distance ) {

			var arcLengths = this.getLengths();

			var i = 0, il = arcLengths.length;

			var targetArcLength; // The targeted u distance value to get

			if ( distance ) {

				targetArcLength = distance;

			} else {

				targetArcLength = u * arcLengths[ il - 1 ];

			}

			// binary search for the index with largest value smaller than target u distance

			var low = 0, high = il - 1, comparison;

			while ( low <= high ) {

				i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

				comparison = arcLengths[ i ] - targetArcLength;

				if ( comparison < 0 ) {

					low = i + 1;

				} else if ( comparison > 0 ) {

					high = i - 1;

				} else {

					high = i;
					break;

					// DONE

				}

			}

			i = high;

			if ( arcLengths[ i ] === targetArcLength ) {

				return i / ( il - 1 );

			}

			// we could get finer grain at lengths, or use simple interpolation between two points

			var lengthBefore = arcLengths[ i ];
			var lengthAfter = arcLengths[ i + 1 ];

			var segmentLength = lengthAfter - lengthBefore;

			// determine where we are between the 'before' and 'after' points

			var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

			// add that fractional amount to t

			var t = ( i + segmentFraction ) / ( il - 1 );

			return t;

		},

		// Returns a unit vector tangent at t
		// In case any sub curve does not implement its tangent derivation,
		// 2 points a small delta apart will be used to find its gradient
		// which seems to give a reasonable approximation

		getTangent: function ( t ) {

			var delta = 0.0001;
			var t1 = t - delta;
			var t2 = t + delta;

			// Capping in case of danger

			if ( t1 < 0 ) t1 = 0;
			if ( t2 > 1 ) t2 = 1;

			var pt1 = this.getPoint( t1 );
			var pt2 = this.getPoint( t2 );

			var vec = pt2.clone().sub( pt1 );
			return vec.normalize();

		},

		getTangentAt: function ( u ) {

			var t = this.getUtoTmapping( u );
			return this.getTangent( t );

		},

		computeFrenetFrames: function ( segments, closed ) {

			// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

			var normal = new Vector3();

			var tangents = [];
			var normals = [];
			var binormals = [];

			var vec = new Vector3();
			var mat = new Matrix4();

			var i, u, theta;

			// compute the tangent vectors for each segment on the curve

			for ( i = 0; i <= segments; i ++ ) {

				u = i / segments;

				tangents[ i ] = this.getTangentAt( u );
				tangents[ i ].normalize();

			}

			// select an initial normal vector perpendicular to the first tangent vector,
			// and in the direction of the minimum tangent xyz component

			normals[ 0 ] = new Vector3();
			binormals[ 0 ] = new Vector3();
			var min = Number.MAX_VALUE;
			var tx = Math.abs( tangents[ 0 ].x );
			var ty = Math.abs( tangents[ 0 ].y );
			var tz = Math.abs( tangents[ 0 ].z );

			if ( tx <= min ) {

				min = tx;
				normal.set( 1, 0, 0 );

			}

			if ( ty <= min ) {

				min = ty;
				normal.set( 0, 1, 0 );

			}

			if ( tz <= min ) {

				normal.set( 0, 0, 1 );

			}

			vec.crossVectors( tangents[ 0 ], normal ).normalize();

			normals[ 0 ].crossVectors( tangents[ 0 ], vec );
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


			// compute the slowly-varying normal and binormal vectors for each segment on the curve

			for ( i = 1; i <= segments; i ++ ) {

				normals[ i ] = normals[ i - 1 ].clone();

				binormals[ i ] = binormals[ i - 1 ].clone();

				vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

				if ( vec.length() > Number.EPSILON ) {

					vec.normalize();

					theta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

					normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

				}

				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			}

			// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

			if ( closed === true ) {

				theta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
				theta /= segments;

				if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

					theta = - theta;

				}

				for ( i = 1; i <= segments; i ++ ) {

					// twist a little...
					normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
					binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

				}

			}

			return {
				tangents: tangents,
				normals: normals,
				binormals: binormals
			};

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.arcLengthDivisions = source.arcLengthDivisions;

			return this;

		},

		toJSON: function () {

			var data = {
				metadata: {
					version: 4.5,
					type: 'Curve',
					generator: 'Curve.toJSON'
				}
			};

			data.arcLengthDivisions = this.arcLengthDivisions;
			data.type = this.type;

			return data;

		},

		fromJSON: function ( json ) {

			this.arcLengthDivisions = json.arcLengthDivisions;

			return this;

		}

	} );

	function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		Curve.call( this );

		this.type = 'EllipseCurve';

		this.aX = aX || 0;
		this.aY = aY || 0;

		this.xRadius = xRadius || 1;
		this.yRadius = yRadius || 1;

		this.aStartAngle = aStartAngle || 0;
		this.aEndAngle = aEndAngle || 2 * Math.PI;

		this.aClockwise = aClockwise || false;

		this.aRotation = aRotation || 0;

	}

	EllipseCurve.prototype = Object.create( Curve.prototype );
	EllipseCurve.prototype.constructor = EllipseCurve;

	EllipseCurve.prototype.isEllipseCurve = true;

	EllipseCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		var twoPi = Math.PI * 2;
		var deltaAngle = this.aEndAngle - this.aStartAngle;
		var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

		// ensures that deltaAngle is 0 .. 2 PI
		while ( deltaAngle < 0 ) deltaAngle += twoPi;
		while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

		if ( deltaAngle < Number.EPSILON ) {

			if ( samePoints ) {

				deltaAngle = 0;

			} else {

				deltaAngle = twoPi;

			}

		}

		if ( this.aClockwise === true && ! samePoints ) {

			if ( deltaAngle === twoPi ) {

				deltaAngle = - twoPi;

			} else {

				deltaAngle = deltaAngle - twoPi;

			}

		}

		var angle = this.aStartAngle + t * deltaAngle;
		var x = this.aX + this.xRadius * Math.cos( angle );
		var y = this.aY + this.yRadius * Math.sin( angle );

		if ( this.aRotation !== 0 ) {

			var cos = Math.cos( this.aRotation );
			var sin = Math.sin( this.aRotation );

			var tx = x - this.aX;
			var ty = y - this.aY;

			// Rotate the point about the center of the ellipse.
			x = tx * cos - ty * sin + this.aX;
			y = tx * sin + ty * cos + this.aY;

		}

		return point.set( x, y );

	};

	EllipseCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.aX = source.aX;
		this.aY = source.aY;

		this.xRadius = source.xRadius;
		this.yRadius = source.yRadius;

		this.aStartAngle = source.aStartAngle;
		this.aEndAngle = source.aEndAngle;

		this.aClockwise = source.aClockwise;

		this.aRotation = source.aRotation;

		return this;

	};


	EllipseCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.aX = this.aX;
		data.aY = this.aY;

		data.xRadius = this.xRadius;
		data.yRadius = this.yRadius;

		data.aStartAngle = this.aStartAngle;
		data.aEndAngle = this.aEndAngle;

		data.aClockwise = this.aClockwise;

		data.aRotation = this.aRotation;

		return data;

	};

	EllipseCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.aX = json.aX;
		this.aY = json.aY;

		this.xRadius = json.xRadius;
		this.yRadius = json.yRadius;

		this.aStartAngle = json.aStartAngle;
		this.aEndAngle = json.aEndAngle;

		this.aClockwise = json.aClockwise;

		this.aRotation = json.aRotation;

		return this;

	};

	function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		this.type = 'ArcCurve';

	}

	ArcCurve.prototype = Object.create( EllipseCurve.prototype );
	ArcCurve.prototype.constructor = ArcCurve;

	ArcCurve.prototype.isArcCurve = true;

	/**
	 * @author zz85 https://github.com/zz85
	 *
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 */


	/*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/

	function CubicPoly() {

		var c0 = 0, c1 = 0, c2 = 0, c3 = 0;

		/*
		 * Compute coefficients for a cubic polynomial
		 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *   p(0) = x0, p(1) = x1
		 *  and
		 *   p'(0) = t0, p'(1) = t1.
		 */
		function init( x0, x1, t0, t1 ) {

			c0 = x0;
			c1 = t0;
			c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
			c3 = 2 * x0 - 2 * x1 + t0 + t1;

		}

		return {

			initCatmullRom: function ( x0, x1, x2, x3, tension ) {

				init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

			},

			initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

				// compute tangents when parameterized in [t1,t2]
				var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
				var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

				// rescale tangents for parametrization in [0,1]
				t1 *= dt1;
				t2 *= dt1;

				init( x1, x2, t1, t2 );

			},

			calc: function ( t ) {

				var t2 = t * t;
				var t3 = t2 * t;
				return c0 + c1 * t + c2 * t2 + c3 * t3;

			}

		};

	}

	//

	var tmp = new Vector3();
	var px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();

	function CatmullRomCurve3( points, closed, curveType, tension ) {

		Curve.call( this );

		this.type = 'CatmullRomCurve3';

		this.points = points || [];
		this.closed = closed || false;
		this.curveType = curveType || 'centripetal';
		this.tension = tension || 0.5;

	}

	CatmullRomCurve3.prototype = Object.create( Curve.prototype );
	CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;

	CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

	CatmullRomCurve3.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector3();

		var points = this.points;
		var l = points.length;

		var p = ( l - ( this.closed ? 0 : 1 ) ) * t;
		var intPoint = Math.floor( p );
		var weight = p - intPoint;

		if ( this.closed ) {

			intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;

		} else if ( weight === 0 && intPoint === l - 1 ) {

			intPoint = l - 2;
			weight = 1;

		}

		var p0, p1, p2, p3; // 4 points

		if ( this.closed || intPoint > 0 ) {

			p0 = points[ ( intPoint - 1 ) % l ];

		} else {

			// extrapolate first point
			tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
			p0 = tmp;

		}

		p1 = points[ intPoint % l ];
		p2 = points[ ( intPoint + 1 ) % l ];

		if ( this.closed || intPoint + 2 < l ) {

			p3 = points[ ( intPoint + 2 ) % l ];

		} else {

			// extrapolate last point
			tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
			p3 = tmp;

		}

		if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {

			// init Centripetal / Chordal Catmull-Rom
			var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
			var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
			var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
			var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

			// safety check for repeated points
			if ( dt1 < 1e-4 ) dt1 = 1.0;
			if ( dt0 < 1e-4 ) dt0 = dt1;
			if ( dt2 < 1e-4 ) dt2 = dt1;

			px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
			py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
			pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

		} else if ( this.curveType === 'catmullrom' ) {

			px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
			py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
			pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );

		}

		point.set(
			px.calc( weight ),
			py.calc( weight ),
			pz.calc( weight )
		);

		return point;

	};

	CatmullRomCurve3.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.points = [];

		for ( var i = 0, l = source.points.length; i < l; i ++ ) {

			var point = source.points[ i ];

			this.points.push( point.clone() );

		}

		this.closed = source.closed;
		this.curveType = source.curveType;
		this.tension = source.tension;

		return this;

	};

	CatmullRomCurve3.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.points = [];

		for ( var i = 0, l = this.points.length; i < l; i ++ ) {

			var point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		data.closed = this.closed;
		data.curveType = this.curveType;
		data.tension = this.tension;

		return data;

	};

	CatmullRomCurve3.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.points = [];

		for ( var i = 0, l = json.points.length; i < l; i ++ ) {

			var point = json.points[ i ];
			this.points.push( new Vector3().fromArray( point ) );

		}

		this.closed = json.closed;
		this.curveType = json.curveType;
		this.tension = json.tension;

		return this;

	};

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Bezier Curves formulas obtained from
	 * http://en.wikipedia.org/wiki/Bzier_curve
	 */

	function CatmullRom( t, p0, p1, p2, p3 ) {

		var v0 = ( p2 - p0 ) * 0.5;
		var v1 = ( p3 - p1 ) * 0.5;
		var t2 = t * t;
		var t3 = t * t2;
		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

	//

	function QuadraticBezierP0( t, p ) {

		var k = 1 - t;
		return k * k * p;

	}

	function QuadraticBezierP1( t, p ) {

		return 2 * ( 1 - t ) * t * p;

	}

	function QuadraticBezierP2( t, p ) {

		return t * t * p;

	}

	function QuadraticBezier( t, p0, p1, p2 ) {

		return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
			QuadraticBezierP2( t, p2 );

	}

	//

	function CubicBezierP0( t, p ) {

		var k = 1 - t;
		return k * k * k * p;

	}

	function CubicBezierP1( t, p ) {

		var k = 1 - t;
		return 3 * k * k * t * p;

	}

	function CubicBezierP2( t, p ) {

		return 3 * ( 1 - t ) * t * t * p;

	}

	function CubicBezierP3( t, p ) {

		return t * t * t * p;

	}

	function CubicBezier( t, p0, p1, p2, p3 ) {

		return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
			CubicBezierP3( t, p3 );

	}

	function CubicBezierCurve( v0, v1, v2, v3 ) {

		Curve.call( this );

		this.type = 'CubicBezierCurve';

		this.v0 = v0 || new Vector2();
		this.v1 = v1 || new Vector2();
		this.v2 = v2 || new Vector2();
		this.v3 = v3 || new Vector2();

	}

	CubicBezierCurve.prototype = Object.create( Curve.prototype );
	CubicBezierCurve.prototype.constructor = CubicBezierCurve;

	CubicBezierCurve.prototype.isCubicBezierCurve = true;

	CubicBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
		);

		return point;

	};

	CubicBezierCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	};

	CubicBezierCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	};

	CubicBezierCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	};

	function CubicBezierCurve3( v0, v1, v2, v3 ) {

		Curve.call( this );

		this.type = 'CubicBezierCurve3';

		this.v0 = v0 || new Vector3();
		this.v1 = v1 || new Vector3();
		this.v2 = v2 || new Vector3();
		this.v3 = v3 || new Vector3();

	}

	CubicBezierCurve3.prototype = Object.create( Curve.prototype );
	CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;

	CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

	CubicBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector3();

		var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
			CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
		);

		return point;

	};

	CubicBezierCurve3.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	};

	CubicBezierCurve3.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	};

	CubicBezierCurve3.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	};

	function LineCurve( v1, v2 ) {

		Curve.call( this );

		this.type = 'LineCurve';

		this.v1 = v1 || new Vector2();
		this.v2 = v2 || new Vector2();

	}

	LineCurve.prototype = Object.create( Curve.prototype );
	LineCurve.prototype.constructor = LineCurve;

	LineCurve.prototype.isLineCurve = true;

	LineCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	};

	// Line curve is linear, so we can overwrite default getPointAt

	LineCurve.prototype.getPointAt = function ( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	};

	LineCurve.prototype.getTangent = function ( /* t */ ) {

		var tangent = this.v2.clone().sub( this.v1 );

		return tangent.normalize();

	};

	LineCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	};

	LineCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	};

	LineCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	};

	function LineCurve3( v1, v2 ) {

		Curve.call( this );

		this.type = 'LineCurve3';

		this.v1 = v1 || new Vector3();
		this.v2 = v2 || new Vector3();

	}

	LineCurve3.prototype = Object.create( Curve.prototype );
	LineCurve3.prototype.constructor = LineCurve3;

	LineCurve3.prototype.isLineCurve3 = true;

	LineCurve3.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector3();

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	};

	// Line curve is linear, so we can overwrite default getPointAt

	LineCurve3.prototype.getPointAt = function ( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	};

	LineCurve3.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	};

	LineCurve3.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	};

	LineCurve3.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	};

	function QuadraticBezierCurve( v0, v1, v2 ) {

		Curve.call( this );

		this.type = 'QuadraticBezierCurve';

		this.v0 = v0 || new Vector2();
		this.v1 = v1 || new Vector2();
		this.v2 = v2 || new Vector2();

	}

	QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
	QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;

	QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

	QuadraticBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		var v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y )
		);

		return point;

	};

	QuadraticBezierCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	};

	QuadraticBezierCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	};

	QuadraticBezierCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	};

	function QuadraticBezierCurve3( v0, v1, v2 ) {

		Curve.call( this );

		this.type = 'QuadraticBezierCurve3';

		this.v0 = v0 || new Vector3();
		this.v1 = v1 || new Vector3();
		this.v2 = v2 || new Vector3();

	}

	QuadraticBezierCurve3.prototype = Object.create( Curve.prototype );
	QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;

	QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

	QuadraticBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector3();

		var v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y ),
			QuadraticBezier( t, v0.z, v1.z, v2.z )
		);

		return point;

	};

	QuadraticBezierCurve3.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	};

	QuadraticBezierCurve3.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	};

	QuadraticBezierCurve3.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	};

	function SplineCurve( points /* array of Vector2 */ ) {

		Curve.call( this );

		this.type = 'SplineCurve';

		this.points = points || [];

	}

	SplineCurve.prototype = Object.create( Curve.prototype );
	SplineCurve.prototype.constructor = SplineCurve;

	SplineCurve.prototype.isSplineCurve = true;

	SplineCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		var points = this.points;
		var p = ( points.length - 1 ) * t;

		var intPoint = Math.floor( p );
		var weight = p - intPoint;

		var p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
		var p1 = points[ intPoint ];
		var p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		var p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		point.set(
			CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
			CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
		);

		return point;

	};

	SplineCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.points = [];

		for ( var i = 0, l = source.points.length; i < l; i ++ ) {

			var point = source.points[ i ];

			this.points.push( point.clone() );

		}

		return this;

	};

	SplineCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.points = [];

		for ( var i = 0, l = this.points.length; i < l; i ++ ) {

			var point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		return data;

	};

	SplineCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.points = [];

		for ( var i = 0, l = json.points.length; i < l; i ++ ) {

			var point = json.points[ i ];
			this.points.push( new Vector2().fromArray( point ) );

		}

		return this;

	};



	var Curves = /*#__PURE__*/Object.freeze({
		ArcCurve: ArcCurve,
		CatmullRomCurve3: CatmullRomCurve3,
		CubicBezierCurve: CubicBezierCurve,
		CubicBezierCurve3: CubicBezierCurve3,
		EllipseCurve: EllipseCurve,
		LineCurve: LineCurve,
		LineCurve3: LineCurve3,
		QuadraticBezierCurve: QuadraticBezierCurve,
		QuadraticBezierCurve3: QuadraticBezierCurve3,
		SplineCurve: SplineCurve
	});

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 **/

	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 **************************************************************/

	function CurvePath() {

		Curve.call( this );

		this.type = 'CurvePath';

		this.curves = [];
		this.autoClose = false; // Automatically closes the path

	}

	CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {

		constructor: CurvePath,

		add: function ( curve ) {

			this.curves.push( curve );

		},

		closePath: function () {

			// Add a line curve if start and end of lines are not connected
			var startPoint = this.curves[ 0 ].getPoint( 0 );
			var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

			if ( ! startPoint.equals( endPoint ) ) {

				this.curves.push( new LineCurve( endPoint, startPoint ) );

			}

		},

		// To get accurate point with reference to
		// entire path distance at time t,
		// following has to be done:

		// 1. Length of each sub path have to be known
		// 2. Locate and identify type of curve
		// 3. Get t for the curve
		// 4. Return curve.getPointAt(t')

		getPoint: function ( t ) {

			var d = t * this.getLength();
			var curveLengths = this.getCurveLengths();
			var i = 0;

			// To think about boundaries points.

			while ( i < curveLengths.length ) {

				if ( curveLengths[ i ] >= d ) {

					var diff = curveLengths[ i ] - d;
					var curve = this.curves[ i ];

					var segmentLength = curve.getLength();
					var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

					return curve.getPointAt( u );

				}

				i ++;

			}

			return null;

			// loop where sum != 0, sum > d , sum+1 <d

		},

		// We cannot use the default THREE.Curve getPoint() with getLength() because in
		// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
		// getPoint() depends on getLength

		getLength: function () {

			var lens = this.getCurveLengths();
			return lens[ lens.length - 1 ];

		},

		// cacheLengths must be recalculated.
		updateArcLengths: function () {

			this.needsUpdate = true;
			this.cacheLengths = null;
			this.getCurveLengths();

		},

		// Compute lengths and cache them
		// We cannot overwrite getLengths() because UtoT mapping uses it.

		getCurveLengths: function () {

			// We use cache values if curves and cache array are same length

			if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

				return this.cacheLengths;

			}

			// Get length of sub-curve
			// Push sums into cached array

			var lengths = [], sums = 0;

			for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

				sums += this.curves[ i ].getLength();
				lengths.push( sums );

			}

			this.cacheLengths = lengths;

			return lengths;

		},

		getSpacedPoints: function ( divisions ) {

			if ( divisions === undefined ) divisions = 40;

			var points = [];

			for ( var i = 0; i <= divisions; i ++ ) {

				points.push( this.getPoint( i / divisions ) );

			}

			if ( this.autoClose ) {

				points.push( points[ 0 ] );

			}

			return points;

		},

		getPoints: function ( divisions ) {

			divisions = divisions || 12;

			var points = [], last;

			for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {

				var curve = curves[ i ];
				var resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2
					: ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1
						: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length
							: divisions;

				var pts = curve.getPoints( resolution );

				for ( var j = 0; j < pts.length; j ++ ) {

					var point = pts[ j ];

					if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

					points.push( point );
					last = point;

				}

			}

			if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

				points.push( points[ 0 ] );

			}

			return points;

		},

		copy: function ( source ) {

			Curve.prototype.copy.call( this, source );

			this.curves = [];

			for ( var i = 0, l = source.curves.length; i < l; i ++ ) {

				var curve = source.curves[ i ];

				this.curves.push( curve.clone() );

			}

			this.autoClose = source.autoClose;

			return this;

		},

		toJSON: function () {

			var data = Curve.prototype.toJSON.call( this );

			data.autoClose = this.autoClose;
			data.curves = [];

			for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

				var curve = this.curves[ i ];
				data.curves.push( curve.toJSON() );

			}

			return data;

		},

		fromJSON: function ( json ) {

			Curve.prototype.fromJSON.call( this, json );

			this.autoClose = json.autoClose;
			this.curves = [];

			for ( var i = 0, l = json.curves.length; i < l; i ++ ) {

				var curve = json.curves[ i ];
				this.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );

			}

			return this;

		}

	} );

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Creates free form 2d path using series of points, lines or curves.
	 **/

	function Path( points ) {

		CurvePath.call( this );

		this.type = 'Path';

		this.currentPoint = new Vector2();

		if ( points ) {

			this.setFromPoints( points );

		}

	}

	Path.prototype = Object.assign( Object.create( CurvePath.prototype ), {

		constructor: Path,

		setFromPoints: function ( points ) {

			this.moveTo( points[ 0 ].x, points[ 0 ].y );

			for ( var i = 1, l = points.length; i < l; i ++ ) {

				this.lineTo( points[ i ].x, points[ i ].y );

			}

		},

		moveTo: function ( x, y ) {

			this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

		},

		lineTo: function ( x, y ) {

			var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
			this.curves.push( curve );

			this.currentPoint.set( x, y );

		},

		quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

			var curve = new QuadraticBezierCurve(
				this.currentPoint.clone(),
				new Vector2( aCPx, aCPy ),
				new Vector2( aX, aY )
			);

			this.curves.push( curve );

			this.currentPoint.set( aX, aY );

		},

		bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

			var curve = new CubicBezierCurve(
				this.currentPoint.clone(),
				new Vector2( aCP1x, aCP1y ),
				new Vector2( aCP2x, aCP2y ),
				new Vector2( aX, aY )
			);

			this.curves.push( curve );

			this.currentPoint.set( aX, aY );

		},

		splineThru: function ( pts /*Array of Vector*/ ) {

			var npts = [ this.currentPoint.clone() ].concat( pts );

			var curve = new SplineCurve( npts );
			this.curves.push( curve );

			this.currentPoint.copy( pts[ pts.length - 1 ] );

		},

		arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

			var x0 = this.currentPoint.x;
			var y0 = this.currentPoint.y;

			this.absarc( aX + x0, aY + y0, aRadius,
				aStartAngle, aEndAngle, aClockwise );

		},

		absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

			this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		},

		ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

			var x0 = this.currentPoint.x;
			var y0 = this.currentPoint.y;

			this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		},

		absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

			var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

			if ( this.curves.length > 0 ) {

				// if a previous curve is present, attempt to join
				var firstPoint = curve.getPoint( 0 );

				if ( ! firstPoint.equals( this.currentPoint ) ) {

					this.lineTo( firstPoint.x, firstPoint.y );

				}

			}

			this.curves.push( curve );

			var lastPoint = curve.getPoint( 1 );
			this.currentPoint.copy( lastPoint );

		},

		copy: function ( source ) {

			CurvePath.prototype.copy.call( this, source );

			this.currentPoint.copy( source.currentPoint );

			return this;

		},

		toJSON: function () {

			var data = CurvePath.prototype.toJSON.call( this );

			data.currentPoint = this.currentPoint.toArray();

			return data;

		},

		fromJSON: function ( json ) {

			CurvePath.prototype.fromJSON.call( this, json );

			this.currentPoint.fromArray( json.currentPoint );

			return this;

		}

	} );

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Defines a 2d shape plane using paths.
	 **/

	// STEP 1 Create a path.
	// STEP 2 Turn path into shape.
	// STEP 3 ExtrudeGeometry takes in Shape/Shapes
	// STEP 3a - Extract points from each shape, turn to vertices
	// STEP 3b - Triangulate each shape, add faces.

	function Shape( points ) {

		Path.call( this, points );

		this.uuid = _Math.generateUUID();

		this.type = 'Shape';

		this.holes = [];

	}

	Shape.prototype = Object.assign( Object.create( Path.prototype ), {

		constructor: Shape,

		getPointsHoles: function ( divisions ) {

			var holesPts = [];

			for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

				holesPts[ i ] = this.holes[ i ].getPoints( divisions );

			}

			return holesPts;

		},

		// get points of shape and holes (keypoints based on segments parameter)

		extractPoints: function ( divisions ) {

			return {

				shape: this.getPoints( divisions ),
				holes: this.getPointsHoles( divisions )

			};

		},

		copy: function ( source ) {

			Path.prototype.copy.call( this, source );

			this.holes = [];

			for ( var i = 0, l = source.holes.length; i < l; i ++ ) {

				var hole = source.holes[ i ];

				this.holes.push( hole.clone() );

			}

			return this;

		},

		toJSON: function () {

			var data = Path.prototype.toJSON.call( this );

			data.uuid = this.uuid;
			data.holes = [];

			for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

				var hole = this.holes[ i ];
				data.holes.push( hole.toJSON() );

			}

			return data;

		},

		fromJSON: function ( json ) {

			Path.prototype.fromJSON.call( this, json );

			this.uuid = json.uuid;
			this.holes = [];

			for ( var i = 0, l = json.holes.length; i < l; i ++ ) {

				var hole = json.holes[ i ];
				this.holes.push( new Path().fromJSON( hole ) );

			}

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Light( color, intensity ) {

		Object3D.call( this );

		this.type = 'Light';

		this.color = new Color( color );
		this.intensity = intensity !== undefined ? intensity : 1;

		this.receiveShadow = undefined;

	}

	Light.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Light,

		isLight: true,

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source );

			this.color.copy( source.color );
			this.intensity = source.intensity;

			return this;

		},

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			data.object.color = this.color.getHex();
			data.object.intensity = this.intensity;

			if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

			if ( this.distance !== undefined ) data.object.distance = this.distance;
			if ( this.angle !== undefined ) data.object.angle = this.angle;
			if ( this.decay !== undefined ) data.object.decay = this.decay;
			if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

			if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

			return data;

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function HemisphereLight( skyColor, groundColor, intensity ) {

		Light.call( this, skyColor, intensity );

		this.type = 'HemisphereLight';

		this.castShadow = undefined;

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.groundColor = new Color( groundColor );

	}

	HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: HemisphereLight,

		isHemisphereLight: true,

		copy: function ( source ) {

			Light.prototype.copy.call( this, source );

			this.groundColor.copy( source.groundColor );

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function LightShadow( camera ) {

		this.camera = camera;

		this.bias = 0;
		this.radius = 1;

		this.mapSize = new Vector2( 512, 512 );

		this.map = null;
		this.matrix = new Matrix4();

	}

	Object.assign( LightShadow.prototype, {

		copy: function ( source ) {

			this.camera = source.camera.clone();

			this.bias = source.bias;
			this.radius = source.radius;

			this.mapSize.copy( source.mapSize );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		toJSON: function () {

			var object = {};

			if ( this.bias !== 0 ) object.bias = this.bias;
			if ( this.radius !== 1 ) object.radius = this.radius;
			if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

			object.camera = this.camera.toJSON( false ).object;
			delete object.camera.matrix;

			return object;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function SpotLightShadow() {

		LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );

	}

	SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

		constructor: SpotLightShadow,

		isSpotLightShadow: true,

		update: function ( light ) {

			var camera = this.camera;

			var fov = _Math.RAD2DEG * 2 * light.angle;
			var aspect = this.mapSize.width / this.mapSize.height;
			var far = light.distance || camera.far;

			if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

				camera.fov = fov;
				camera.aspect = aspect;
				camera.far = far;
				camera.updateProjectionMatrix();

			}

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function SpotLight( color, intensity, distance, angle, penumbra, decay ) {

		Light.call( this, color, intensity );

		this.type = 'SpotLight';

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.target = new Object3D();

		Object.defineProperty( this, 'power', {
			get: function () {

				// intensity = power per solid angle.
				// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
				return this.intensity * Math.PI;

			},
			set: function ( power ) {

				// intensity = power per solid angle.
				// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
				this.intensity = power / Math.PI;

			}
		} );

		this.distance = ( distance !== undefined ) ? distance : 0;
		this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
		this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

		this.shadow = new SpotLightShadow();

	}

	SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: SpotLight,

		isSpotLight: true,

		copy: function ( source ) {

			Light.prototype.copy.call( this, source );

			this.distance = source.distance;
			this.angle = source.angle;
			this.penumbra = source.penumbra;
			this.decay = source.decay;

			this.target = source.target.clone();

			this.shadow = source.shadow.clone();

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */


	function PointLight( color, intensity, distance, decay ) {

		Light.call( this, color, intensity );

		this.type = 'PointLight';

		Object.defineProperty( this, 'power', {
			get: function () {

				// intensity = power per solid angle.
				// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
				return this.intensity * 4 * Math.PI;

			},
			set: function ( power ) {

				// intensity = power per solid angle.
				// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
				this.intensity = power / ( 4 * Math.PI );

			}
		} );

		this.distance = ( distance !== undefined ) ? distance : 0;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

		this.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

	}

	PointLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: PointLight,

		isPointLight: true,

		copy: function ( source ) {

			Light.prototype.copy.call( this, source );

			this.distance = source.distance;
			this.decay = source.decay;

			this.shadow = source.shadow.clone();

			return this;

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author arose / http://github.com/arose
	 */

	function OrthographicCamera( left, right, top, bottom, near, far ) {

		Camera.call( this );

		this.type = 'OrthographicCamera';

		this.zoom = 1;
		this.view = null;

		this.left = ( left !== undefined ) ? left : - 1;
		this.right = ( right !== undefined ) ? right : 1;
		this.top = ( top !== undefined ) ? top : 1;
		this.bottom = ( bottom !== undefined ) ? bottom : - 1;

		this.near = ( near !== undefined ) ? near : 0.1;
		this.far = ( far !== undefined ) ? far : 2000;

		this.updateProjectionMatrix();

	}

	OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

		constructor: OrthographicCamera,

		isOrthographicCamera: true,

		copy: function ( source, recursive ) {

			Camera.prototype.copy.call( this, source, recursive );

			this.left = source.left;
			this.right = source.right;
			this.top = source.top;
			this.bottom = source.bottom;
			this.near = source.near;
			this.far = source.far;

			this.zoom = source.zoom;
			this.view = source.view === null ? null : Object.assign( {}, source.view );

			return this;

		},

		setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

			if ( this.view === null ) {

				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};

			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;

			this.updateProjectionMatrix();

		},

		clearViewOffset: function () {

			if ( this.view !== null ) {

				this.view.enabled = false;

			}

			this.updateProjectionMatrix();

		},

		updateProjectionMatrix: function () {

			var dx = ( this.right - this.left ) / ( 2 * this.zoom );
			var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
			var cx = ( this.right + this.left ) / 2;
			var cy = ( this.top + this.bottom ) / 2;

			var left = cx - dx;
			var right = cx + dx;
			var top = cy + dy;
			var bottom = cy - dy;

			if ( this.view !== null && this.view.enabled ) {

				var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );
				var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );
				var scaleW = ( this.right - this.left ) / this.view.width;
				var scaleH = ( this.top - this.bottom ) / this.view.height;

				left += scaleW * ( this.view.offsetX / zoomW );
				right = left + scaleW * ( this.view.width / zoomW );
				top -= scaleH * ( this.view.offsetY / zoomH );
				bottom = top - scaleH * ( this.view.height / zoomH );

			}

			this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

			this.projectionMatrixInverse.getInverse( this.projectionMatrix );

		},

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			data.object.zoom = this.zoom;
			data.object.left = this.left;
			data.object.right = this.right;
			data.object.top = this.top;
			data.object.bottom = this.bottom;
			data.object.near = this.near;
			data.object.far = this.far;

			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

			return data;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function DirectionalLightShadow( ) {

		LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

	}

	DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

		constructor: DirectionalLightShadow

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function DirectionalLight( color, intensity ) {

		Light.call( this, color, intensity );

		this.type = 'DirectionalLight';

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.target = new Object3D();

		this.shadow = new DirectionalLightShadow();

	}

	DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: DirectionalLight,

		isDirectionalLight: true,

		copy: function ( source ) {

			Light.prototype.copy.call( this, source );

			this.target = source.target.clone();

			this.shadow = source.shadow.clone();

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function AmbientLight( color, intensity ) {

		Light.call( this, color, intensity );

		this.type = 'AmbientLight';

		this.castShadow = undefined;

	}

	AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: AmbientLight,

		isAmbientLight: true

	} );

	/**
	 * @author abelnation / http://github.com/abelnation
	 */

	function RectAreaLight( color, intensity, width, height ) {

		Light.call( this, color, intensity );

		this.type = 'RectAreaLight';

		this.width = ( width !== undefined ) ? width : 10;
		this.height = ( height !== undefined ) ? height : 10;

	}

	RectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: RectAreaLight,

		isRectAreaLight: true,

		copy: function ( source ) {

			Light.prototype.copy.call( this, source );

			this.width = source.width;
			this.height = source.height;

			return this;

		},

		toJSON: function ( meta ) {

			var data = Light.prototype.toJSON.call( this, meta );

			data.object.width = this.width;
			data.object.height = this.height;

			return data;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function MaterialLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
		this.textures = {};

	}

	Object.assign( MaterialLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new FileLoader( scope.manager );
			loader.setPath( scope.path );
			loader.load( url, function ( text ) {

				onLoad( scope.parse( JSON.parse( text ) ) );

			}, onProgress, onError );

		},

		parse: function ( json ) {

			var textures = this.textures;

			function getTexture( name ) {

				if ( textures[ name ] === undefined ) {

					console.warn( 'THREE.MaterialLoader: Undefined texture', name );

				}

				return textures[ name ];

			}

			var material = new Materials[ json.type ]();

			if ( json.uuid !== undefined ) material.uuid = json.uuid;
			if ( json.name !== undefined ) material.name = json.name;
			if ( json.color !== undefined ) material.color.setHex( json.color );
			if ( json.roughness !== undefined ) material.roughness = json.roughness;
			if ( json.metalness !== undefined ) material.metalness = json.metalness;
			if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
			if ( json.specular !== undefined ) material.specular.setHex( json.specular );
			if ( json.shininess !== undefined ) material.shininess = json.shininess;
			if ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat;
			if ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness;
			if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
			if ( json.fog !== undefined ) material.fog = json.fog;
			if ( json.flatShading !== undefined ) material.flatShading = json.flatShading;
			if ( json.blending !== undefined ) material.blending = json.blending;
			if ( json.combine !== undefined ) material.combine = json.combine;
			if ( json.side !== undefined ) material.side = json.side;
			if ( json.opacity !== undefined ) material.opacity = json.opacity;
			if ( json.transparent !== undefined ) material.transparent = json.transparent;
			if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
			if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
			if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
			if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
			if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
			if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
			if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
			if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;

			if ( json.rotation !== undefined ) material.rotation = json.rotation;

			if ( json.linewidth !== 1 ) material.linewidth = json.linewidth;
			if ( json.dashSize !== undefined ) material.dashSize = json.dashSize;
			if ( json.gapSize !== undefined ) material.gapSize = json.gapSize;
			if ( json.scale !== undefined ) material.scale = json.scale;

			if ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;
			if ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;
			if ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;

			if ( json.skinning !== undefined ) material.skinning = json.skinning;
			if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;
			if ( json.dithering !== undefined ) material.dithering = json.dithering;

			if ( json.visible !== undefined ) material.visible = json.visible;
			if ( json.userData !== undefined ) material.userData = json.userData;

			// Shader Material

			if ( json.uniforms !== undefined ) {

				for ( var name in json.uniforms ) {

					var uniform = json.uniforms[ name ];

					material.uniforms[ name ] = {};

					switch ( uniform.type ) {

						case 't':
							material.uniforms[ name ].value = getTexture( uniform.value );
							break;

						case 'c':
							material.uniforms[ name ].value = new Color().setHex( uniform.value );
							break;

						case 'v2':
							material.uniforms[ name ].value = new Vector2().fromArray( uniform.value );
							break;

						case 'v3':
							material.uniforms[ name ].value = new Vector3().fromArray( uniform.value );
							break;

						case 'v4':
							material.uniforms[ name ].value = new Vector4().fromArray( uniform.value );
							break;

						case 'm3':
							material.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );

						case 'm4':
							material.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );
							break;

						default:
							material.uniforms[ name ].value = uniform.value;

					}

				}

			}

			if ( json.defines !== undefined ) material.defines = json.defines;
			if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
			if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;

			if ( json.extensions !== undefined ) {

				for ( var key in json.extensions ) {

					material.extensions[ key ] = json.extensions[ key ];

				}

			}

			// Deprecated

			if ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading

			// for PointsMaterial

			if ( json.size !== undefined ) material.size = json.size;
			if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

			// maps

			if ( json.map !== undefined ) material.map = getTexture( json.map );

			if ( json.alphaMap !== undefined ) {

				material.alphaMap = getTexture( json.alphaMap );
				material.transparent = true;

			}

			if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
			if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

			if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
			if ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;
			if ( json.normalScale !== undefined ) {

				var normalScale = json.normalScale;

				if ( Array.isArray( normalScale ) === false ) {

					// Blender exporter used to export a scalar. See #7459

					normalScale = [ normalScale, normalScale ];

				}

				material.normalScale = new Vector2().fromArray( normalScale );

			}

			if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
			if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
			if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

			if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
			if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

			if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
			if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

			if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );

			if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );
			if ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;

			if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;

			if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
			if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

			if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
			if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

			if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );

			return material;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		},

		setTextures: function ( value ) {

			this.textures = value;
			return this;

		}

	} );

	/**
	 * @author Don McCurdy / https://www.donmccurdy.com
	 */

	var LoaderUtils = {

		decodeText: function ( array ) {

			if ( typeof TextDecoder !== 'undefined' ) {

				return new TextDecoder().decode( array );

			}

			// Avoid the String.fromCharCode.apply(null, array) shortcut, which
			// throws a "maximum call stack size exceeded" error for large arrays.

			var s = '';

			for ( var i = 0, il = array.length; i < il; i ++ ) {

				// Implicitly assumes little-endian.
				s += String.fromCharCode( array[ i ] );

			}

			// Merges multi-byte utf-8 characters.
			return decodeURIComponent( escape( s ) );

		},

		extractUrlBase: function ( url ) {

			var index = url.lastIndexOf( '/' );

			if ( index === - 1 ) return './';

			return url.substr( 0, index + 1 );

		}

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function BufferGeometryLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( BufferGeometryLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new FileLoader( scope.manager );
			loader.setPath( scope.path );
			loader.load( url, function ( text ) {

				onLoad( scope.parse( JSON.parse( text ) ) );

			}, onProgress, onError );

		},

		parse: function ( json ) {

			var geometry = new BufferGeometry();

			var index = json.data.index;

			if ( index !== undefined ) {

				var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
				geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

			}

			var attributes = json.data.attributes;

			for ( var key in attributes ) {

				var attribute = attributes[ key ];
				var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );

				var bufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );
				if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
				geometry.addAttribute( key, bufferAttribute );

			}

			var morphAttributes = json.data.morphAttributes;

			if ( morphAttributes ) {

				for ( var key in morphAttributes ) {

					var attributeArray = morphAttributes[ key ];

					var array = [];

					for ( var i = 0, il = attributeArray.length; i < il; i ++ ) {

						var attribute = attributeArray[ i ];
						var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );

						var bufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );
						if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
						array.push( bufferAttribute );

					}

					geometry.morphAttributes[ key ] = array;

				}

			}

			var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

			if ( groups !== undefined ) {

				for ( var i = 0, n = groups.length; i !== n; ++ i ) {

					var group = groups[ i ];

					geometry.addGroup( group.start, group.count, group.materialIndex );

				}

			}

			var boundingSphere = json.data.boundingSphere;

			if ( boundingSphere !== undefined ) {

				var center = new Vector3();

				if ( boundingSphere.center !== undefined ) {

					center.fromArray( boundingSphere.center );

				}

				geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

			}

			if ( json.name ) geometry.name = json.name;
			if ( json.userData ) geometry.userData = json.userData;

			return geometry;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	var TYPED_ARRAYS = {
		Int8Array: Int8Array,
		Uint8Array: Uint8Array,
		// Workaround for IE11 pre KB2929437. See #11440
		Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
		Int16Array: Int16Array,
		Uint16Array: Uint16Array,
		Int32Array: Int32Array,
		Uint32Array: Uint32Array,
		Float32Array: Float32Array,
		Float64Array: Float64Array
	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function ObjectLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
		this.resourcePath = '';

	}

	Object.assign( ObjectLoader.prototype, {

		crossOrigin: 'anonymous',

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var path = ( this.path === undefined ) ? LoaderUtils.extractUrlBase( url ) : this.path;
			this.resourcePath = this.resourcePath || path;

			var loader = new FileLoader( scope.manager );
			loader.setPath( this.path );
			loader.load( url, function ( text ) {

				var json = null;

				try {

					json = JSON.parse( text );

				} catch ( error ) {

					if ( onError !== undefined ) onError( error );

					console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );

					return;

				}

				var metadata = json.metadata;

				if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

					console.error( 'THREE.ObjectLoader: Can\'t load ' + url );
					return;

				}

				scope.parse( json, onLoad );

			}, onProgress, onError );

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		},

		setResourcePath: function ( value ) {

			this.resourcePath = value;
			return this;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;
			return this;

		},

		parse: function ( json, onLoad ) {

			var shapes = this.parseShape( json.shapes );
			var geometries = this.parseGeometries( json.geometries, shapes );

			var images = this.parseImages( json.images, function () {

				if ( onLoad !== undefined ) onLoad( object );

			} );

			var textures = this.parseTextures( json.textures, images );
			var materials = this.parseMaterials( json.materials, textures );

			var object = this.parseObject( json.object, geometries, materials );

			if ( json.animations ) {

				object.animations = this.parseAnimations( json.animations );

			}

			if ( json.images === undefined || json.images.length === 0 ) {

				if ( onLoad !== undefined ) onLoad( object );

			}

			return object;

		},

		parseShape: function ( json ) {

			var shapes = {};

			if ( json !== undefined ) {

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var shape = new Shape().fromJSON( json[ i ] );

					shapes[ shape.uuid ] = shape;

				}

			}

			return shapes;

		},

		parseGeometries: function ( json, shapes ) {

			var geometries = {};

			if ( json !== undefined ) {

				var bufferGeometryLoader = new BufferGeometryLoader();

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var geometry;
					var data = json[ i ];

					switch ( data.type ) {

						case 'PlaneGeometry':
						case 'PlaneBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.width,
								data.height,
								data.widthSegments,
								data.heightSegments
							);

							break;

						case 'BoxGeometry':
						case 'BoxBufferGeometry':
						case 'CubeGeometry': // backwards compatible

							geometry = new Geometries[ data.type ](
								data.width,
								data.height,
								data.depth,
								data.widthSegments,
								data.heightSegments,
								data.depthSegments
							);

							break;

						case 'CircleGeometry':
						case 'CircleBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.segments,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'CylinderGeometry':
						case 'CylinderBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radiusTop,
								data.radiusBottom,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'ConeGeometry':
						case 'ConeBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'SphereGeometry':
						case 'SphereBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.widthSegments,
								data.heightSegments,
								data.phiStart,
								data.phiLength,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'DodecahedronGeometry':
						case 'DodecahedronBufferGeometry':
						case 'IcosahedronGeometry':
						case 'IcosahedronBufferGeometry':
						case 'OctahedronGeometry':
						case 'OctahedronBufferGeometry':
						case 'TetrahedronGeometry':
						case 'TetrahedronBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.detail
							);

							break;

						case 'RingGeometry':
						case 'RingBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.innerRadius,
								data.outerRadius,
								data.thetaSegments,
								data.phiSegments,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'TorusGeometry':
						case 'TorusBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.arc
							);

							break;

						case 'TorusKnotGeometry':
						case 'TorusKnotBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.tube,
								data.tubularSegments,
								data.radialSegments,
								data.p,
								data.q
							);

							break;

						case 'TubeGeometry':
						case 'TubeBufferGeometry':

							// This only works for built-in curves (e.g. CatmullRomCurve3).
							// User defined curves or instances of CurvePath will not be deserialized.
							geometry = new Geometries[ data.type ](
								new Curves[ data.path.type ]().fromJSON( data.path ),
								data.tubularSegments,
								data.radius,
								data.radialSegments,
								data.closed
							);

							break;

						case 'LatheGeometry':
						case 'LatheBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.points,
								data.segments,
								data.phiStart,
								data.phiLength
							);

							break;

						case 'PolyhedronGeometry':
						case 'PolyhedronBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.vertices,
								data.indices,
								data.radius,
								data.details
							);

							break;

						case 'ShapeGeometry':
						case 'ShapeBufferGeometry':

							var geometryShapes = [];

							for ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) {

								var shape = shapes[ data.shapes[ j ] ];

								geometryShapes.push( shape );

							}

							geometry = new Geometries[ data.type ](
								geometryShapes,
								data.curveSegments
							);

							break;


						case 'ExtrudeGeometry':
						case 'ExtrudeBufferGeometry':

							var geometryShapes = [];

							for ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) {

								var shape = shapes[ data.shapes[ j ] ];

								geometryShapes.push( shape );

							}

							var extrudePath = data.options.extrudePath;

							if ( extrudePath !== undefined ) {

								data.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );

							}

							geometry = new Geometries[ data.type ](
								geometryShapes,
								data.options
							);

							break;

						case 'BufferGeometry':

							geometry = bufferGeometryLoader.parse( data );

							break;

						case 'Geometry':

							if ( 'THREE' in window && 'LegacyJSONLoader' in THREE ) {

								var geometryLoader = new THREE.LegacyJSONLoader();
								geometry = geometryLoader.parse( data, this.resourcePath ).geometry;


							} else {

								console.error( 'THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".' );

							}

							break;

						default:

							console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

							continue;

					}

					geometry.uuid = data.uuid;

					if ( data.name !== undefined ) geometry.name = data.name;
					if ( geometry.isBufferGeometry === true && data.userData !== undefined ) geometry.userData = data.userData;

					geometries[ data.uuid ] = geometry;

				}

			}

			return geometries;

		},

		parseMaterials: function ( json, textures ) {

			var cache = {}; // MultiMaterial
			var materials = {};

			if ( json !== undefined ) {

				var loader = new MaterialLoader();
				loader.setTextures( textures );

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var data = json[ i ];

					if ( data.type === 'MultiMaterial' ) {

						// Deprecated

						var array = [];

						for ( var j = 0; j < data.materials.length; j ++ ) {

							var material = data.materials[ j ];

							if ( cache[ material.uuid ] === undefined ) {

								cache[ material.uuid ] = loader.parse( material );

							}

							array.push( cache[ material.uuid ] );

						}

						materials[ data.uuid ] = array;

					} else {

						if ( cache[ data.uuid ] === undefined ) {

							cache[ data.uuid ] = loader.parse( data );

						}

						materials[ data.uuid ] = cache[ data.uuid ];

					}

				}

			}

			return materials;

		},

		parseAnimations: function ( json ) {

			var animations = [];

			for ( var i = 0; i < json.length; i ++ ) {

				var data = json[ i ];

				var clip = AnimationClip.parse( data );

				if ( data.uuid !== undefined ) clip.uuid = data.uuid;

				animations.push( clip );

			}

			return animations;

		},

		parseImages: function ( json, onLoad ) {

			var scope = this;
			var images = {};

			function loadImage( url ) {

				scope.manager.itemStart( url );

				return loader.load( url, function () {

					scope.manager.itemEnd( url );

				}, undefined, function () {

					scope.manager.itemError( url );
					scope.manager.itemEnd( url );

				} );

			}

			if ( json !== undefined && json.length > 0 ) {

				var manager = new LoadingManager( onLoad );

				var loader = new ImageLoader( manager );
				loader.setCrossOrigin( this.crossOrigin );

				for ( var i = 0, il = json.length; i < il; i ++ ) {

					var image = json[ i ];
					var url = image.url;

					if ( Array.isArray( url ) ) {

						// load array of images e.g CubeTexture

						images[ image.uuid ] = [];

						for ( var j = 0, jl = url.length; j < jl; j ++ ) {

							var currentUrl = url[ j ];

							var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( currentUrl ) ? currentUrl : scope.resourcePath + currentUrl;

							images[ image.uuid ].push( loadImage( path ) );

						}

					} else {

						// load single image

						var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.resourcePath + image.url;

						images[ image.uuid ] = loadImage( path );

					}

				}

			}

			return images;

		},

		parseTextures: function ( json, images ) {

			function parseConstant( value, type ) {

				if ( typeof value === 'number' ) return value;

				console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

				return type[ value ];

			}

			var textures = {};

			if ( json !== undefined ) {

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var data = json[ i ];

					if ( data.image === undefined ) {

						console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

					}

					if ( images[ data.image ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

					}

					var texture;

					if ( Array.isArray( images[ data.image ] ) ) {

						texture = new CubeTexture( images[ data.image ] );

					} else {

						texture = new Texture( images[ data.image ] );

					}

					texture.needsUpdate = true;

					texture.uuid = data.uuid;

					if ( data.name !== undefined ) texture.name = data.name;

					if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );

					if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
					if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
					if ( data.center !== undefined ) texture.center.fromArray( data.center );
					if ( data.rotation !== undefined ) texture.rotation = data.rotation;

					if ( data.wrap !== undefined ) {

						texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
						texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );

					}

					if ( data.format !== undefined ) texture.format = data.format;
					if ( data.type !== undefined ) texture.type = data.type;
					if ( data.encoding !== undefined ) texture.encoding = data.encoding;

					if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );
					if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );
					if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

					if ( data.flipY !== undefined ) texture.flipY = data.flipY;

					if ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;
					if ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;

					textures[ data.uuid ] = texture;

				}

			}

			return textures;

		},

		parseObject: function ( data, geometries, materials ) {

			var object;

			function getGeometry( name ) {

				if ( geometries[ name ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

				}

				return geometries[ name ];

			}

			function getMaterial( name ) {

				if ( name === undefined ) return undefined;

				if ( Array.isArray( name ) ) {

					var array = [];

					for ( var i = 0, l = name.length; i < l; i ++ ) {

						var uuid = name[ i ];

						if ( materials[ uuid ] === undefined ) {

							console.warn( 'THREE.ObjectLoader: Undefined material', uuid );

						}

						array.push( materials[ uuid ] );

					}

					return array;

				}

				if ( materials[ name ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined material', name );

				}

				return materials[ name ];

			}

			switch ( data.type ) {

				case 'Scene':

					object = new Scene();

					if ( data.background !== undefined ) {

						if ( Number.isInteger( data.background ) ) {

							object.background = new Color( data.background );

						}

					}

					if ( data.fog !== undefined ) {

						if ( data.fog.type === 'Fog' ) {

							object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

						} else if ( data.fog.type === 'FogExp2' ) {

							object.fog = new FogExp2( data.fog.color, data.fog.density );

						}

					}

					break;

				case 'PerspectiveCamera':

					object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

					if ( data.focus !== undefined ) object.focus = data.focus;
					if ( data.zoom !== undefined ) object.zoom = data.zoom;
					if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
					if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
					if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

					break;

				case 'OrthographicCamera':

					object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

					if ( data.zoom !== undefined ) object.zoom = data.zoom;
					if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

					break;

				case 'AmbientLight':

					object = new AmbientLight( data.color, data.intensity );

					break;

				case 'DirectionalLight':

					object = new DirectionalLight( data.color, data.intensity );

					break;

				case 'PointLight':

					object = new PointLight( data.color, data.intensity, data.distance, data.decay );

					break;

				case 'RectAreaLight':

					object = new RectAreaLight( data.color, data.intensity, data.width, data.height );

					break;

				case 'SpotLight':

					object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

					break;

				case 'HemisphereLight':

					object = new HemisphereLight( data.color, data.groundColor, data.intensity );

					break;

				case 'SkinnedMesh':

					console.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' );

				case 'Mesh':

					var geometry = getGeometry( data.geometry );
					var material = getMaterial( data.material );

					if ( geometry.bones && geometry.bones.length > 0 ) {

						object = new SkinnedMesh( geometry, material );

					} else {

						object = new Mesh( geometry, material );

					}

					if ( data.drawMode !== undefined ) object.setDrawMode( data.drawMode );

					break;

				case 'LOD':

					object = new LOD();

					break;

				case 'Line':

					object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

					break;

				case 'LineLoop':

					object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'LineSegments':

					object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'PointCloud':
				case 'Points':

					object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'Sprite':

					object = new Sprite( getMaterial( data.material ) );

					break;

				case 'Group':

					object = new Group();

					break;

				default:

					object = new Object3D();

			}

			object.uuid = data.uuid;

			if ( data.name !== undefined ) object.name = data.name;

			if ( data.matrix !== undefined ) {

				object.matrix.fromArray( data.matrix );

				if ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;
				if ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );

			} else {

				if ( data.position !== undefined ) object.position.fromArray( data.position );
				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
				if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

			}

			if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
			if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

			if ( data.shadow ) {

				if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
				if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
				if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
				if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

			}

			if ( data.visible !== undefined ) object.visible = data.visible;
			if ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;
			if ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;
			if ( data.userData !== undefined ) object.userData = data.userData;
			if ( data.layers !== undefined ) object.layers.mask = data.layers;

			if ( data.children !== undefined ) {

				var children = data.children;

				for ( var i = 0; i < children.length; i ++ ) {

					object.add( this.parseObject( children[ i ], geometries, materials ) );

				}

			}

			if ( data.type === 'LOD' ) {

				var levels = data.levels;

				for ( var l = 0; l < levels.length; l ++ ) {

					var level = levels[ l ];
					var child = object.getObjectByProperty( 'uuid', level.object );

					if ( child !== undefined ) {

						object.addLevel( child, level.distance );

					}

				}

			}

			return object;

		}

	} );

	var TEXTURE_MAPPING = {
		UVMapping: UVMapping,
		CubeReflectionMapping: CubeReflectionMapping,
		CubeRefractionMapping: CubeRefractionMapping,
		EquirectangularReflectionMapping: EquirectangularReflectionMapping,
		EquirectangularRefractionMapping: EquirectangularRefractionMapping,
		SphericalReflectionMapping: SphericalReflectionMapping,
		CubeUVReflectionMapping: CubeUVReflectionMapping,
		CubeUVRefractionMapping: CubeUVRefractionMapping
	};

	var TEXTURE_WRAPPING = {
		RepeatWrapping: RepeatWrapping,
		ClampToEdgeWrapping: ClampToEdgeWrapping,
		MirroredRepeatWrapping: MirroredRepeatWrapping
	};

	var TEXTURE_FILTER = {
		NearestFilter: NearestFilter,
		NearestMipMapNearestFilter: NearestMipMapNearestFilter,
		NearestMipMapLinearFilter: NearestMipMapLinearFilter,
		LinearFilter: LinearFilter,
		LinearMipMapNearestFilter: LinearMipMapNearestFilter,
		LinearMipMapLinearFilter: LinearMipMapLinearFilter
	};

	/**
	 * @author thespite / http://clicktorelease.com/
	 */


	function ImageBitmapLoader( manager ) {

		if ( typeof createImageBitmap === 'undefined' ) {

			console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );

		}

		if ( typeof fetch === 'undefined' ) {

			console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );

		}

		this.manager = manager !== undefined ? manager : DefaultLoadingManager;
		this.options = undefined;

	}

	ImageBitmapLoader.prototype = {

		constructor: ImageBitmapLoader,

		setOptions: function setOptions( options ) {

			this.options = options;

			return this;

		},

		load: function ( url, onLoad, onProgress, onError ) {

			if ( url === undefined ) url = '';

			if ( this.path !== undefined ) url = this.path + url;

			url = this.manager.resolveURL( url );

			var scope = this;

			var cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			fetch( url ).then( function ( res ) {

				return res.blob();

			} ).then( function ( blob ) {

				if ( scope.options === undefined ) {

					// Workaround for FireFox. It causes an error if you pass options.
					return createImageBitmap( blob );

				} else {

					return createImageBitmap( blob, scope.options );

				}

			} ).then( function ( imageBitmap ) {

				Cache.add( url, imageBitmap );

				if ( onLoad ) onLoad( imageBitmap );

				scope.manager.itemEnd( url );

			} ).catch( function ( e ) {

				if ( onError ) onError( e );

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			} );

			scope.manager.itemStart( url );

		},

		setCrossOrigin: function ( /* value */ ) {

			return this;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	};

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
	 **/

	function ShapePath() {

		this.type = 'ShapePath';

		this.color = new Color();

		this.subPaths = [];
		this.currentPath = null;

	}

	Object.assign( ShapePath.prototype, {

		moveTo: function ( x, y ) {

			this.currentPath = new Path();
			this.subPaths.push( this.currentPath );
			this.currentPath.moveTo( x, y );

		},

		lineTo: function ( x, y ) {

			this.currentPath.lineTo( x, y );

		},

		quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

			this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );

		},

		bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

			this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );

		},

		splineThru: function ( pts ) {

			this.currentPath.splineThru( pts );

		},

		toShapes: function ( isCCW, noHoles ) {

			function toShapesNoHoles( inSubpaths ) {

				var shapes = [];

				for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

					var tmpPath = inSubpaths[ i ];

					var tmpShape = new Shape();
					tmpShape.curves = tmpPath.curves;

					shapes.push( tmpShape );

				}

				return shapes;

			}

			function isPointInsidePolygon( inPt, inPolygon ) {

				var polyLen = inPolygon.length;

				// inPt on polygon contour => immediate success    or
				// toggling of inside/outside at every single! intersection point of an edge
				//  with the horizontal line through inPt, left of inPt
				//  not counting lowerY endpoints of edges and whole edges on that line
				var inside = false;
				for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

					var edgeLowPt = inPolygon[ p ];
					var edgeHighPt = inPolygon[ q ];

					var edgeDx = edgeHighPt.x - edgeLowPt.x;
					var edgeDy = edgeHighPt.y - edgeLowPt.y;

					if ( Math.abs( edgeDy ) > Number.EPSILON ) {

						// not parallel
						if ( edgeDy < 0 ) {

							edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;
							edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

						}
						if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

						if ( inPt.y === edgeLowPt.y ) {

							if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
							// continue;				// no intersection or edgeLowPt => doesn't count !!!

						} else {

							var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
							if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
							if ( perpEdge < 0 ) 				continue;
							inside = ! inside;		// true intersection left of inPt

						}

					} else {

						// parallel or collinear
						if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
						// edge lies on the same horizontal line as inPt
						if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
							 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
						// continue;

					}

				}

				return	inside;

			}

			var isClockWise = ShapeUtils.isClockWise;

			var subPaths = this.subPaths;
			if ( subPaths.length === 0 ) return [];

			if ( noHoles === true )	return	toShapesNoHoles( subPaths );


			var solid, tmpPath, tmpShape, shapes = [];

			if ( subPaths.length === 1 ) {

				tmpPath = subPaths[ 0 ];
				tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;
				shapes.push( tmpShape );
				return shapes;

			}

			var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
			holesFirst = isCCW ? ! holesFirst : holesFirst;

			// console.log("Holes first", holesFirst);

			var betterShapeHoles = [];
			var newShapes = [];
			var newShapeHoles = [];
			var mainIdx = 0;
			var tmpPoints;

			newShapes[ mainIdx ] = undefined;
			newShapeHoles[ mainIdx ] = [];

			for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

				tmpPath = subPaths[ i ];
				tmpPoints = tmpPath.getPoints();
				solid = isClockWise( tmpPoints );
				solid = isCCW ? ! solid : solid;

				if ( solid ) {

					if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

					newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
					newShapes[ mainIdx ].s.curves = tmpPath.curves;

					if ( holesFirst )	mainIdx ++;
					newShapeHoles[ mainIdx ] = [];

					//console.log('cw', i);

				} else {

					newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

					//console.log('ccw', i);

				}

			}

			// only Holes? -> probably all Shapes with wrong orientation
			if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


			if ( newShapes.length > 1 ) {

				var ambiguous = false;
				var toChange = [];

				for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

					betterShapeHoles[ sIdx ] = [];

				}

				for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

					var sho = newShapeHoles[ sIdx ];

					for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

						var ho = sho[ hIdx ];
						var hole_unassigned = true;

						for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

							if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

								if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
								if ( hole_unassigned ) {

									hole_unassigned = false;
									betterShapeHoles[ s2Idx ].push( ho );

								} else {

									ambiguous = true;

								}

							}

						}
						if ( hole_unassigned ) {

							betterShapeHoles[ sIdx ].push( ho );

						}

					}

				}
				// console.log("ambiguous: ", ambiguous);
				if ( toChange.length > 0 ) {

					// console.log("to change: ", toChange);
					if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

				}

			}

			var tmpHoles;

			for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

				tmpShape = newShapes[ i ].s;
				shapes.push( tmpShape );
				tmpHoles = newShapeHoles[ i ];

				for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

					tmpShape.holes.push( tmpHoles[ j ].h );

				}

			}

			//console.log("shape", shapes);

			return shapes;

		}

	} );

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author mrdoob / http://mrdoob.com/
	 */


	function Font( data ) {

		this.type = 'Font';

		this.data = data;

	}

	Object.assign( Font.prototype, {

		isFont: true,

		generateShapes: function ( text, size ) {

			if ( size === undefined ) size = 100;

			var shapes = [];
			var paths = createPaths( text, size, this.data );

			for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

				Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

			}

			return shapes;

		}

	} );

	function createPaths( text, size, data ) {

		var chars = Array.from ? Array.from( text ) : String( text ).split( '' ); // see #13988
		var scale = size / data.resolution;
		var line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;

		var paths = [];

		var offsetX = 0, offsetY = 0;

		for ( var i = 0; i < chars.length; i ++ ) {

			var char = chars[ i ];

			if ( char === '\n' ) {

				offsetX = 0;
				offsetY -= line_height;

			} else {

				var ret = createPath( char, scale, offsetX, offsetY, data );
				offsetX += ret.offsetX;
				paths.push( ret.path );

			}

		}

		return paths;

	}

	function createPath( char, scale, offsetX, offsetY, data ) {

		var glyph = data.glyphs[ char ] || data.glyphs[ '?' ];

		if ( ! glyph ) return;

		var path = new ShapePath();

		var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

		if ( glyph.o ) {

			var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

			for ( var i = 0, l = outline.length; i < l; ) {

				var action = outline[ i ++ ];

				switch ( action ) {

					case 'm': // moveTo

						x = outline[ i ++ ] * scale + offsetX;
						y = outline[ i ++ ] * scale + offsetY;

						path.moveTo( x, y );

						break;

					case 'l': // lineTo

						x = outline[ i ++ ] * scale + offsetX;
						y = outline[ i ++ ] * scale + offsetY;

						path.lineTo( x, y );

						break;

					case 'q': // quadraticCurveTo

						cpx = outline[ i ++ ] * scale + offsetX;
						cpy = outline[ i ++ ] * scale + offsetY;
						cpx1 = outline[ i ++ ] * scale + offsetX;
						cpy1 = outline[ i ++ ] * scale + offsetY;

						path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

						break;

					case 'b': // bezierCurveTo

						cpx = outline[ i ++ ] * scale + offsetX;
						cpy = outline[ i ++ ] * scale + offsetY;
						cpx1 = outline[ i ++ ] * scale + offsetX;
						cpy1 = outline[ i ++ ] * scale + offsetY;
						cpx2 = outline[ i ++ ] * scale + offsetX;
						cpy2 = outline[ i ++ ] * scale + offsetY;

						path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

						break;

				}

			}

		}

		return { offsetX: glyph.ha * scale, path: path };

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function FontLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( FontLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new FileLoader( this.manager );
			loader.setPath( this.path );
			loader.load( url, function ( text ) {

				var json;

				try {

					json = JSON.parse( text );

				} catch ( e ) {

					console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
					json = JSON.parse( text.substring( 65, text.length - 2 ) );

				}

				var font = scope.parse( json );

				if ( onLoad ) onLoad( font );

			}, onProgress, onError );

		},

		parse: function ( json ) {

			return new Font( json );

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Loader() {}

	Loader.Handlers = {

		handlers: [],

		add: function ( regex, loader ) {

			this.handlers.push( regex, loader );

		},

		get: function ( file ) {

			var handlers = this.handlers;

			for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

				var regex = handlers[ i ];
				var loader = handlers[ i + 1 ];

				if ( regex.test( file ) ) {

					return loader;

				}

			}

			return null;

		}

	};

	Object.assign( Loader.prototype, {

		crossOrigin: 'anonymous',

		onLoadStart: function () {},

		onLoadProgress: function () {},

		onLoadComplete: function () {},

		initMaterials: function ( materials, texturePath, crossOrigin ) {

			var array = [];

			for ( var i = 0; i < materials.length; ++ i ) {

				array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

			}

			return array;

		},

		createMaterial: ( function () {

			var BlendingMode = {
				NoBlending: NoBlending,
				NormalBlending: NormalBlending,
				AdditiveBlending: AdditiveBlending,
				SubtractiveBlending: SubtractiveBlending,
				MultiplyBlending: MultiplyBlending,
				CustomBlending: CustomBlending
			};

			var color = new Color();
			var textureLoader = new TextureLoader();
			var materialLoader = new MaterialLoader();

			return function createMaterial( m, texturePath, crossOrigin ) {

				// convert from old material format

				var textures = {};

				function loadTexture( path, repeat, offset, wrap, anisotropy ) {

					var fullPath = texturePath + path;
					var loader = Loader.Handlers.get( fullPath );

					var texture;

					if ( loader !== null ) {

						texture = loader.load( fullPath );

					} else {

						textureLoader.setCrossOrigin( crossOrigin );
						texture = textureLoader.load( fullPath );

					}

					if ( repeat !== undefined ) {

						texture.repeat.fromArray( repeat );

						if ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;
						if ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;

					}

					if ( offset !== undefined ) {

						texture.offset.fromArray( offset );

					}

					if ( wrap !== undefined ) {

						if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;
						if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;

						if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;
						if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;

					}

					if ( anisotropy !== undefined ) {

						texture.anisotropy = anisotropy;

					}

					var uuid = _Math.generateUUID();

					textures[ uuid ] = texture;

					return uuid;

				}

				//

				var json = {
					uuid: _Math.generateUUID(),
					type: 'MeshLambertMaterial'
				};

				for ( var name in m ) {

					var value = m[ name ];

					switch ( name ) {

						case 'DbgColor':
						case 'DbgIndex':
						case 'opticalDensity':
						case 'illumination':
							break;
						case 'DbgName':
							json.name = value;
							break;
						case 'blending':
							json.blending = BlendingMode[ value ];
							break;
						case 'colorAmbient':
						case 'mapAmbient':
							console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
							break;
						case 'colorDiffuse':
							json.color = color.fromArray( value ).getHex();
							break;
						case 'colorSpecular':
							json.specular = color.fromArray( value ).getHex();
							break;
						case 'colorEmissive':
							json.emissive = color.fromArray( value ).getHex();
							break;
						case 'specularCoef':
							json.shininess = value;
							break;
						case 'shading':
							if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
							if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
							if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';
							break;
						case 'mapDiffuse':
							json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
							break;
						case 'mapDiffuseRepeat':
						case 'mapDiffuseOffset':
						case 'mapDiffuseWrap':
						case 'mapDiffuseAnisotropy':
							break;
						case 'mapEmissive':
							json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );
							break;
						case 'mapEmissiveRepeat':
						case 'mapEmissiveOffset':
						case 'mapEmissiveWrap':
						case 'mapEmissiveAnisotropy':
							break;
						case 'mapLight':
							json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
							break;
						case 'mapLightRepeat':
						case 'mapLightOffset':
						case 'mapLightWrap':
						case 'mapLightAnisotropy':
							break;
						case 'mapAO':
							json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
							break;
						case 'mapAORepeat':
						case 'mapAOOffset':
						case 'mapAOWrap':
						case 'mapAOAnisotropy':
							break;
						case 'mapBump':
							json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
							break;
						case 'mapBumpScale':
							json.bumpScale = value;
							break;
						case 'mapBumpRepeat':
						case 'mapBumpOffset':
						case 'mapBumpWrap':
						case 'mapBumpAnisotropy':
							break;
						case 'mapNormal':
							json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
							break;
						case 'mapNormalFactor':
							json.normalScale = value;
							break;
						case 'mapNormalRepeat':
						case 'mapNormalOffset':
						case 'mapNormalWrap':
						case 'mapNormalAnisotropy':
							break;
						case 'mapSpecular':
							json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
							break;
						case 'mapSpecularRepeat':
						case 'mapSpecularOffset':
						case 'mapSpecularWrap':
						case 'mapSpecularAnisotropy':
							break;
						case 'mapMetalness':
							json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );
							break;
						case 'mapMetalnessRepeat':
						case 'mapMetalnessOffset':
						case 'mapMetalnessWrap':
						case 'mapMetalnessAnisotropy':
							break;
						case 'mapRoughness':
							json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );
							break;
						case 'mapRoughnessRepeat':
						case 'mapRoughnessOffset':
						case 'mapRoughnessWrap':
						case 'mapRoughnessAnisotropy':
							break;
						case 'mapAlpha':
							json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
							break;
						case 'mapAlphaRepeat':
						case 'mapAlphaOffset':
						case 'mapAlphaWrap':
						case 'mapAlphaAnisotropy':
							break;
						case 'flipSided':
							json.side = BackSide;
							break;
						case 'doubleSided':
							json.side = DoubleSide;
							break;
						case 'transparency':
							console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
							json.opacity = value;
							break;
						case 'depthTest':
						case 'depthWrite':
						case 'colorWrite':
						case 'opacity':
						case 'reflectivity':
						case 'transparent':
						case 'visible':
						case 'wireframe':
							json[ name ] = value;
							break;
						case 'vertexColors':
							if ( value === true ) json.vertexColors = VertexColors;
							if ( value === 'face' ) json.vertexColors = FaceColors;
							break;
						default:
							console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
							break;

					}

				}

				if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
				if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;

				if ( json.opacity < 1 ) json.transparent = true;

				materialLoader.setTextures( textures );

				return materialLoader.parse( json );

			};

		} )()

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var context;

	var AudioContext = {

		getContext: function () {

			if ( context === undefined ) {

				context = new ( window.AudioContext || window.webkitAudioContext )();

			}

			return context;

		},

		setContext: function ( value ) {

			context = value;

		}

	};

	/**
	 * @author Reece Aaron Lecrivain / http://reecenotes.com/
	 */

	function AudioLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( AudioLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var loader = new FileLoader( this.manager );
			loader.setResponseType( 'arraybuffer' );
			loader.setPath( this.path );
			loader.load( url, function ( buffer ) {

				// Create a copy of the buffer. The `decodeAudioData` method
				// detaches the buffer when complete, preventing reuse.
				var bufferCopy = buffer.slice( 0 );

				var context = AudioContext.getContext();
				context.decodeAudioData( bufferCopy, function ( audioBuffer ) {

					onLoad( audioBuffer );

				} );

			}, onProgress, onError );

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function StereoCamera() {

		this.type = 'StereoCamera';

		this.aspect = 1;

		this.eyeSep = 0.064;

		this.cameraL = new PerspectiveCamera();
		this.cameraL.layers.enable( 1 );
		this.cameraL.matrixAutoUpdate = false;

		this.cameraR = new PerspectiveCamera();
		this.cameraR.layers.enable( 2 );
		this.cameraR.matrixAutoUpdate = false;

	}

	Object.assign( StereoCamera.prototype, {

		update: ( function () {

			var instance, focus, fov, aspect, near, far, zoom, eyeSep;

			var eyeRight = new Matrix4();
			var eyeLeft = new Matrix4();

			return function update( camera ) {

				var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
													aspect !== camera.aspect * this.aspect || near !== camera.near ||
													far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;

				if ( needsUpdate ) {

					instance = this;
					focus = camera.focus;
					fov = camera.fov;
					aspect = camera.aspect * this.aspect;
					near = camera.near;
					far = camera.far;
					zoom = camera.zoom;

					// Off-axis stereoscopic effect based on
					// http://paulbourke.net/stereographics/stereorender/

					var projectionMatrix = camera.projectionMatrix.clone();
					eyeSep = this.eyeSep / 2;
					var eyeSepOnProjection = eyeSep * near / focus;
					var ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;
					var xmin, xmax;

					// translate xOffset

					eyeLeft.elements[ 12 ] = - eyeSep;
					eyeRight.elements[ 12 ] = eyeSep;

					// for left eye

					xmin = - ymax * aspect + eyeSepOnProjection;
					xmax = ymax * aspect + eyeSepOnProjection;

					projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
					projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

					this.cameraL.projectionMatrix.copy( projectionMatrix );

					// for right eye

					xmin = - ymax * aspect - eyeSepOnProjection;
					xmax = ymax * aspect - eyeSepOnProjection;

					projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
					projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

					this.cameraR.projectionMatrix.copy( projectionMatrix );

				}

				this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
				this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );

			};

		} )()

	} );

	/**
	 * Camera for rendering cube maps
	 *	- renders scene into axis-aligned cube
	 *
	 * @author alteredq / http://alteredqualia.com/
	 */

	function CubeCamera( near, far, cubeResolution, options ) {

		Object3D.call( this );

		this.type = 'CubeCamera';

		var fov = 90, aspect = 1;

		var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
		cameraPX.up.set( 0, - 1, 0 );
		cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
		this.add( cameraPX );

		var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
		cameraNX.up.set( 0, - 1, 0 );
		cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
		this.add( cameraNX );

		var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
		cameraPY.up.set( 0, 0, 1 );
		cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
		this.add( cameraPY );

		var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
		cameraNY.up.set( 0, 0, - 1 );
		cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
		this.add( cameraNY );

		var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.up.set( 0, - 1, 0 );
		cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
		this.add( cameraPZ );

		var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.up.set( 0, - 1, 0 );
		cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
		this.add( cameraNZ );

		options = options || { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };

		this.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );
		this.renderTarget.texture.name = "CubeCamera";

		this.update = function ( renderer, scene ) {

			if ( this.parent === null ) this.updateMatrixWorld();

			var currentRenderTarget = renderer.getRenderTarget();

			var renderTarget = this.renderTarget;
			var generateMipmaps = renderTarget.texture.generateMipmaps;

			renderTarget.texture.generateMipmaps = false;

			renderer.setRenderTarget( renderTarget, 0 );
			renderer.render( scene, cameraPX );

			renderer.setRenderTarget( renderTarget, 1 );
			renderer.render( scene, cameraNX );

			renderer.setRenderTarget( renderTarget, 2 );
			renderer.render( scene, cameraPY );

			renderer.setRenderTarget( renderTarget, 3 );
			renderer.render( scene, cameraNY );

			renderer.setRenderTarget( renderTarget, 4 );
			renderer.render( scene, cameraPZ );

			renderTarget.texture.generateMipmaps = generateMipmaps;

			renderer.setRenderTarget( renderTarget, 5 );
			renderer.render( scene, cameraNZ );

			renderer.setRenderTarget( currentRenderTarget );

		};

		this.clear = function ( renderer, color, depth, stencil ) {

			var currentRenderTarget = renderer.getRenderTarget();

			var renderTarget = this.renderTarget;

			for ( var i = 0; i < 6; i ++ ) {

				renderer.setRenderTarget( renderTarget, i );

				renderer.clear( color, depth, stencil );

			}

			renderer.setRenderTarget( currentRenderTarget );

		};

	}

	CubeCamera.prototype = Object.create( Object3D.prototype );
	CubeCamera.prototype.constructor = CubeCamera;

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Clock( autoStart ) {

		this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;

		this.running = false;

	}

	Object.assign( Clock.prototype, {

		start: function () {

			this.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732

			this.oldTime = this.startTime;
			this.elapsedTime = 0;
			this.running = true;

		},

		stop: function () {

			this.getElapsedTime();
			this.running = false;
			this.autoStart = false;

		},

		getElapsedTime: function () {

			this.getDelta();
			return this.elapsedTime;

		},

		getDelta: function () {

			var diff = 0;

			if ( this.autoStart && ! this.running ) {

				this.start();
				return 0;

			}

			if ( this.running ) {

				var newTime = ( typeof performance === 'undefined' ? Date : performance ).now();

				diff = ( newTime - this.oldTime ) / 1000;
				this.oldTime = newTime;

				this.elapsedTime += diff;

			}

			return diff;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function AudioListener() {

		Object3D.call( this );

		this.type = 'AudioListener';

		this.context = AudioContext.getContext();

		this.gain = this.context.createGain();
		this.gain.connect( this.context.destination );

		this.filter = null;

		this.timeDelta = 0;

	}

	AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: AudioListener,

		getInput: function () {

			return this.gain;

		},

		removeFilter: function ( ) {

			if ( this.filter !== null ) {

				this.gain.disconnect( this.filter );
				this.filter.disconnect( this.context.destination );
				this.gain.connect( this.context.destination );
				this.filter = null;

			}

			return this;

		},

		getFilter: function () {

			return this.filter;

		},

		setFilter: function ( value ) {

			if ( this.filter !== null ) {

				this.gain.disconnect( this.filter );
				this.filter.disconnect( this.context.destination );

			} else {

				this.gain.disconnect( this.context.destination );

			}

			this.filter = value;
			this.gain.connect( this.filter );
			this.filter.connect( this.context.destination );

			return this;

		},

		getMasterVolume: function () {

			return this.gain.gain.value;

		},

		setMasterVolume: function ( value ) {

			this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

			return this;

		},

		updateMatrixWorld: ( function () {

			var position = new Vector3();
			var quaternion = new Quaternion();
			var scale = new Vector3();

			var orientation = new Vector3();
			var clock = new Clock();

			return function updateMatrixWorld( force ) {

				Object3D.prototype.updateMatrixWorld.call( this, force );

				var listener = this.context.listener;
				var up = this.up;

				this.timeDelta = clock.getDelta();

				this.matrixWorld.decompose( position, quaternion, scale );

				orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

				if ( listener.positionX ) {

					// code path for Chrome (see #14393)

					var endTime = this.context.currentTime + this.timeDelta;

					listener.positionX.linearRampToValueAtTime( position.x, endTime );
					listener.positionY.linearRampToValueAtTime( position.y, endTime );
					listener.positionZ.linearRampToValueAtTime( position.z, endTime );
					listener.forwardX.linearRampToValueAtTime( orientation.x, endTime );
					listener.forwardY.linearRampToValueAtTime( orientation.y, endTime );
					listener.forwardZ.linearRampToValueAtTime( orientation.z, endTime );
					listener.upX.linearRampToValueAtTime( up.x, endTime );
					listener.upY.linearRampToValueAtTime( up.y, endTime );
					listener.upZ.linearRampToValueAtTime( up.z, endTime );

				} else {

					listener.setPosition( position.x, position.y, position.z );
					listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

				}

			};

		} )()

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Reece Aaron Lecrivain / http://reecenotes.com/
	 */

	function Audio( listener ) {

		Object3D.call( this );

		this.type = 'Audio';

		this.listener = listener;
		this.context = listener.context;

		this.gain = this.context.createGain();
		this.gain.connect( listener.getInput() );

		this.autoplay = false;

		this.buffer = null;
		this.detune = 0;
		this.loop = false;
		this.startTime = 0;
		this.offset = 0;
		this.playbackRate = 1;
		this.isPlaying = false;
		this.hasPlaybackControl = true;
		this.sourceType = 'empty';

		this.filters = [];

	}

	Audio.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Audio,

		getOutput: function () {

			return this.gain;

		},

		setNodeSource: function ( audioNode ) {

			this.hasPlaybackControl = false;
			this.sourceType = 'audioNode';
			this.source = audioNode;
			this.connect();

			return this;

		},

		setMediaElementSource: function ( mediaElement ) {

			this.hasPlaybackControl = false;
			this.sourceType = 'mediaNode';
			this.source = this.context.createMediaElementSource( mediaElement );
			this.connect();

			return this;

		},

		setBuffer: function ( audioBuffer ) {

			this.buffer = audioBuffer;
			this.sourceType = 'buffer';

			if ( this.autoplay ) this.play();

			return this;

		},

		play: function () {

			if ( this.isPlaying === true ) {

				console.warn( 'THREE.Audio: Audio is already playing.' );
				return;

			}

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			var source = this.context.createBufferSource();

			source.buffer = this.buffer;
			source.loop = this.loop;
			source.onended = this.onEnded.bind( this );
			this.startTime = this.context.currentTime;
			source.start( this.startTime, this.offset );

			this.isPlaying = true;

			this.source = source;

			this.setDetune( this.detune );
			this.setPlaybackRate( this.playbackRate );

			return this.connect();

		},

		pause: function () {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			if ( this.isPlaying === true ) {

				this.source.stop();
				this.source.onended = null;
				this.offset += ( this.context.currentTime - this.startTime ) * this.playbackRate;
				this.isPlaying = false;

			}

			return this;

		},

		stop: function () {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this.source.stop();
			this.source.onended = null;
			this.offset = 0;
			this.isPlaying = false;

			return this;

		},

		connect: function () {

			if ( this.filters.length > 0 ) {

				this.source.connect( this.filters[ 0 ] );

				for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

					this.filters[ i - 1 ].connect( this.filters[ i ] );

				}

				this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

			} else {

				this.source.connect( this.getOutput() );

			}

			return this;

		},

		disconnect: function () {

			if ( this.filters.length > 0 ) {

				this.source.disconnect( this.filters[ 0 ] );

				for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

					this.filters[ i - 1 ].disconnect( this.filters[ i ] );

				}

				this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

			} else {

				this.source.disconnect( this.getOutput() );

			}

			return this;

		},

		getFilters: function () {

			return this.filters;

		},

		setFilters: function ( value ) {

			if ( ! value ) value = [];

			if ( this.isPlaying === true ) {

				this.disconnect();
				this.filters = value;
				this.connect();

			} else {

				this.filters = value;

			}

			return this;

		},

		setDetune: function ( value ) {

			this.detune = value;

			if ( this.source.detune === undefined ) return; // only set detune when available

			if ( this.isPlaying === true ) {

				this.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );

			}

			return this;

		},

		getDetune: function () {

			return this.detune;

		},

		getFilter: function () {

			return this.getFilters()[ 0 ];

		},

		setFilter: function ( filter ) {

			return this.setFilters( filter ? [ filter ] : [] );

		},

		setPlaybackRate: function ( value ) {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this.playbackRate = value;

			if ( this.isPlaying === true ) {

				this.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );

			}

			return this;

		},

		getPlaybackRate: function () {

			return this.playbackRate;

		},

		onEnded: function () {

			this.isPlaying = false;

		},

		getLoop: function () {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return false;

			}

			return this.loop;

		},

		setLoop: function ( value ) {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this.loop = value;

			if ( this.isPlaying === true ) {

				this.source.loop = this.loop;

			}

			return this;

		},

		getVolume: function () {

			return this.gain.gain.value;

		},

		setVolume: function ( value ) {

			this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function PositionalAudio( listener ) {

		Audio.call( this, listener );

		this.panner = this.context.createPanner();
		this.panner.connect( this.gain );

	}

	PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {

		constructor: PositionalAudio,

		getOutput: function () {

			return this.panner;

		},

		getRefDistance: function () {

			return this.panner.refDistance;

		},

		setRefDistance: function ( value ) {

			this.panner.refDistance = value;

			return this;

		},

		getRolloffFactor: function () {

			return this.panner.rolloffFactor;

		},

		setRolloffFactor: function ( value ) {

			this.panner.rolloffFactor = value;

			return this;

		},

		getDistanceModel: function () {

			return this.panner.distanceModel;

		},

		setDistanceModel: function ( value ) {

			this.panner.distanceModel = value;

			return this;

		},

		getMaxDistance: function () {

			return this.panner.maxDistance;

		},

		setMaxDistance: function ( value ) {

			this.panner.maxDistance = value;

			return this;

		},

		setDirectionalCone: function ( coneInnerAngle, coneOuterAngle, coneOuterGain ) {

			this.panner.coneInnerAngle = coneInnerAngle;
			this.panner.coneOuterAngle = coneOuterAngle;
			this.panner.coneOuterGain = coneOuterGain;

			return this;

		},

		updateMatrixWorld: ( function () {

			var position = new Vector3();
			var quaternion = new Quaternion();
			var scale = new Vector3();

			var orientation = new Vector3();

			return function updateMatrixWorld( force ) {

				Object3D.prototype.updateMatrixWorld.call( this, force );

				if ( this.hasPlaybackControl === true && this.isPlaying === false ) return;

				this.matrixWorld.decompose( position, quaternion, scale );

				orientation.set( 0, 0, 1 ).applyQuaternion( quaternion );

				var panner = this.panner;

				if ( panner.positionX ) {

					// code path for Chrome and Firefox (see #14393)

					var endTime = this.context.currentTime + this.listener.timeDelta;

					panner.positionX.linearRampToValueAtTime( position.x, endTime );
					panner.positionY.linearRampToValueAtTime( position.y, endTime );
					panner.positionZ.linearRampToValueAtTime( position.z, endTime );
					panner.orientationX.linearRampToValueAtTime( orientation.x, endTime );
					panner.orientationY.linearRampToValueAtTime( orientation.y, endTime );
					panner.orientationZ.linearRampToValueAtTime( orientation.z, endTime );

				} else {

					panner.setPosition( position.x, position.y, position.z );
					panner.setOrientation( orientation.x, orientation.y, orientation.z );

				}

			};

		} )()


	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function AudioAnalyser( audio, fftSize ) {

		this.analyser = audio.context.createAnalyser();
		this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

		this.data = new Uint8Array( this.analyser.frequencyBinCount );

		audio.getOutput().connect( this.analyser );

	}

	Object.assign( AudioAnalyser.prototype, {

		getFrequencyData: function () {

			this.analyser.getByteFrequencyData( this.data );

			return this.data;

		},

		getAverageFrequency: function () {

			var value = 0, data = this.getFrequencyData();

			for ( var i = 0; i < data.length; i ++ ) {

				value += data[ i ];

			}

			return value / data.length;

		}

	} );

	/**
	 *
	 * Buffered scene graph property that allows weighted accumulation.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function PropertyMixer( binding, typeName, valueSize ) {

		this.binding = binding;
		this.valueSize = valueSize;

		var bufferType = Float64Array,
			mixFunction;

		switch ( typeName ) {

			case 'quaternion':
				mixFunction = this._slerp;
				break;

			case 'string':
			case 'bool':
				bufferType = Array;
				mixFunction = this._select;
				break;

			default:
				mixFunction = this._lerp;

		}

		this.buffer = new bufferType( valueSize * 4 );
		// layout: [ incoming | accu0 | accu1 | orig ]
		//
		// interpolators can use .buffer as their .result
		// the data then goes to 'incoming'
		//
		// 'accu0' and 'accu1' are used frame-interleaved for
		// the cumulative result and are compared to detect
		// changes
		//
		// 'orig' stores the original state of the property

		this._mixBufferRegion = mixFunction;

		this.cumulativeWeight = 0;

		this.useCount = 0;
		this.referenceCount = 0;

	}

	Object.assign( PropertyMixer.prototype, {

		// accumulate data in the 'incoming' region into 'accu<i>'
		accumulate: function ( accuIndex, weight ) {

			// note: happily accumulating nothing when weight = 0, the caller knows
			// the weight and shouldn't have made the call in the first place

			var buffer = this.buffer,
				stride = this.valueSize,
				offset = accuIndex * stride + stride,

				currentWeight = this.cumulativeWeight;

			if ( currentWeight === 0 ) {

				// accuN := incoming * weight

				for ( var i = 0; i !== stride; ++ i ) {

					buffer[ offset + i ] = buffer[ i ];

				}

				currentWeight = weight;

			} else {

				// accuN := accuN + incoming * weight

				currentWeight += weight;
				var mix = weight / currentWeight;
				this._mixBufferRegion( buffer, offset, 0, mix, stride );

			}

			this.cumulativeWeight = currentWeight;

		},

		// apply the state of 'accu<i>' to the binding when accus differ
		apply: function ( accuIndex ) {

			var stride = this.valueSize,
				buffer = this.buffer,
				offset = accuIndex * stride + stride,

				weight = this.cumulativeWeight,

				binding = this.binding;

			this.cumulativeWeight = 0;

			if ( weight < 1 ) {

				// accuN := accuN + original * ( 1 - cumulativeWeight )

				var originalValueOffset = stride * 3;

				this._mixBufferRegion(
					buffer, offset, originalValueOffset, 1 - weight, stride );

			}

			for ( var i = stride, e = stride + stride; i !== e; ++ i ) {

				if ( buffer[ i ] !== buffer[ i + stride ] ) {

					// value has changed -> update scene graph

					binding.setValue( buffer, offset );
					break;

				}

			}

		},

		// remember the state of the bound property and copy it to both accus
		saveOriginalState: function () {

			var binding = this.binding;

			var buffer = this.buffer,
				stride = this.valueSize,

				originalValueOffset = stride * 3;

			binding.getValue( buffer, originalValueOffset );

			// accu[0..1] := orig -- initially detect changes against the original
			for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {

				buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

			}

			this.cumulativeWeight = 0;

		},

		// apply the state previously taken via 'saveOriginalState' to the binding
		restoreOriginalState: function () {

			var originalValueOffset = this.valueSize * 3;
			this.binding.setValue( this.buffer, originalValueOffset );

		},


		// mix functions

		_select: function ( buffer, dstOffset, srcOffset, t, stride ) {

			if ( t >= 0.5 ) {

				for ( var i = 0; i !== stride; ++ i ) {

					buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

				}

			}

		},

		_slerp: function ( buffer, dstOffset, srcOffset, t ) {

			Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

		},

		_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {

			var s = 1 - t;

			for ( var i = 0; i !== stride; ++ i ) {

				var j = dstOffset + i;

				buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

			}

		}

	} );

	/**
	 *
	 * A reference to a real property in the scene graph.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	// Characters [].:/ are reserved for track binding syntax.
	var RESERVED_CHARS_RE = '\\[\\]\\.:\\/';

	function Composite( targetGroup, path, optionalParsedPath ) {

		var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

		this._targetGroup = targetGroup;
		this._bindings = targetGroup.subscribe_( path, parsedPath );

	}

	Object.assign( Composite.prototype, {

		getValue: function ( array, offset ) {

			this.bind(); // bind all binding

			var firstValidIndex = this._targetGroup.nCachedObjects_,
				binding = this._bindings[ firstValidIndex ];

			// and only call .getValue on the first
			if ( binding !== undefined ) binding.getValue( array, offset );

		},

		setValue: function ( array, offset ) {

			var bindings = this._bindings;

			for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

				bindings[ i ].setValue( array, offset );

			}

		},

		bind: function () {

			var bindings = this._bindings;

			for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

				bindings[ i ].bind();

			}

		},

		unbind: function () {

			var bindings = this._bindings;

			for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

				bindings[ i ].unbind();

			}

		}

	} );


	function PropertyBinding( rootNode, path, parsedPath ) {

		this.path = path;
		this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

		this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;

		this.rootNode = rootNode;

	}

	Object.assign( PropertyBinding, {

		Composite: Composite,

		create: function ( root, path, parsedPath ) {

			if ( ! ( root && root.isAnimationObjectGroup ) ) {

				return new PropertyBinding( root, path, parsedPath );

			} else {

				return new PropertyBinding.Composite( root, path, parsedPath );

			}

		},

		/**
		 * Replaces spaces with underscores and removes unsupported characters from
		 * node names, to ensure compatibility with parseTrackName().
		 *
		 * @param  {string} name Node name to be sanitized.
		 * @return {string}
		 */
		sanitizeNodeName: ( function () {

			var reservedRe = new RegExp( '[' + RESERVED_CHARS_RE + ']', 'g' );

			return function sanitizeNodeName( name ) {

				return name.replace( /\s/g, '_' ).replace( reservedRe, '' );

			};

		}() ),

		parseTrackName: function () {

			// Attempts to allow node names from any language. ES5's `\w` regexp matches
			// only latin characters, and the unicode \p{L} is not yet supported. So
			// instead, we exclude reserved characters and match everything else.
			var wordChar = '[^' + RESERVED_CHARS_RE + ']';
			var wordCharOrDot = '[^' + RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';

			// Parent directories, delimited by '/' or ':'. Currently unused, but must
			// be matched to parse the rest of the track name.
			var directoryRe = /((?:WC+[\/:])*)/.source.replace( 'WC', wordChar );

			// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
			var nodeRe = /(WCOD+)?/.source.replace( 'WCOD', wordCharOrDot );

			// Object on target node, and accessor. May not contain reserved
			// characters. Accessor may contain any character except closing bracket.
			var objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', wordChar );

			// Property and accessor. May not contain reserved characters. Accessor may
			// contain any non-bracket characters.
			var propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', wordChar );

			var trackRe = new RegExp( ''
				+ '^'
				+ directoryRe
				+ nodeRe
				+ objectRe
				+ propertyRe
				+ '$'
			);

			var supportedObjectNames = [ 'material', 'materials', 'bones' ];

			return function parseTrackName( trackName ) {

				var matches = trackRe.exec( trackName );

				if ( ! matches ) {

					throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

				}

				var results = {
					// directoryName: matches[ 1 ], // (tschw) currently unused
					nodeName: matches[ 2 ],
					objectName: matches[ 3 ],
					objectIndex: matches[ 4 ],
					propertyName: matches[ 5 ], // required
					propertyIndex: matches[ 6 ]
				};

				var lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

				if ( lastDot !== undefined && lastDot !== - 1 ) {

					var objectName = results.nodeName.substring( lastDot + 1 );

					// Object names must be checked against a whitelist. Otherwise, there
					// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
					// 'bar' could be the objectName, or part of a nodeName (which can
					// include '.' characters).
					if ( supportedObjectNames.indexOf( objectName ) !== - 1 ) {

						results.nodeName = results.nodeName.substring( 0, lastDot );
						results.objectName = objectName;

					}

				}

				if ( results.propertyName === null || results.propertyName.length === 0 ) {

					throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

				}

				return results;

			};

		}(),

		findNode: function ( root, nodeName ) {

			if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

				return root;

			}

			// search into skeleton bones.
			if ( root.skeleton ) {

				var bone = root.skeleton.getBoneByName( nodeName );

				if ( bone !== undefined ) {

					return bone;

				}

			}

			// search into node subtree.
			if ( root.children ) {

				var searchNodeSubtree = function ( children ) {

					for ( var i = 0; i < children.length; i ++ ) {

						var childNode = children[ i ];

						if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

							return childNode;

						}

						var result = searchNodeSubtree( childNode.children );

						if ( result ) return result;

					}

					return null;

				};

				var subTreeNode = searchNodeSubtree( root.children );

				if ( subTreeNode ) {

					return subTreeNode;

				}

			}

			return null;

		}

	} );

	Object.assign( PropertyBinding.prototype, { // prototype, continued

		// these are used to "bind" a nonexistent property
		_getValue_unavailable: function () {},
		_setValue_unavailable: function () {},

		BindingType: {
			Direct: 0,
			EntireArray: 1,
			ArrayElement: 2,
			HasFromToArray: 3
		},

		Versioning: {
			None: 0,
			NeedsUpdate: 1,
			MatrixWorldNeedsUpdate: 2
		},

		GetterByBindingType: [

			function getValue_direct( buffer, offset ) {

				buffer[ offset ] = this.node[ this.propertyName ];

			},

			function getValue_array( buffer, offset ) {

				var source = this.resolvedProperty;

				for ( var i = 0, n = source.length; i !== n; ++ i ) {

					buffer[ offset ++ ] = source[ i ];

				}

			},

			function getValue_arrayElement( buffer, offset ) {

				buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

			},

			function getValue_toArray( buffer, offset ) {

				this.resolvedProperty.toArray( buffer, offset );

			}

		],

		SetterByBindingTypeAndVersioning: [

			[
				// Direct

				function setValue_direct( buffer, offset ) {

					this.targetObject[ this.propertyName ] = buffer[ offset ];

				},

				function setValue_direct_setNeedsUpdate( buffer, offset ) {

					this.targetObject[ this.propertyName ] = buffer[ offset ];
					this.targetObject.needsUpdate = true;

				},

				function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

					this.targetObject[ this.propertyName ] = buffer[ offset ];
					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			], [

				// EntireArray

				function setValue_array( buffer, offset ) {

					var dest = this.resolvedProperty;

					for ( var i = 0, n = dest.length; i !== n; ++ i ) {

						dest[ i ] = buffer[ offset ++ ];

					}

				},

				function setValue_array_setNeedsUpdate( buffer, offset ) {

					var dest = this.resolvedProperty;

					for ( var i = 0, n = dest.length; i !== n; ++ i ) {

						dest[ i ] = buffer[ offset ++ ];

					}

					this.targetObject.needsUpdate = true;

				},

				function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

					var dest = this.resolvedProperty;

					for ( var i = 0, n = dest.length; i !== n; ++ i ) {

						dest[ i ] = buffer[ offset ++ ];

					}

					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			], [

				// ArrayElement

				function setValue_arrayElement( buffer, offset ) {

					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

				},

				function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
					this.targetObject.needsUpdate = true;

				},

				function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			], [

				// HasToFromArray

				function setValue_fromArray( buffer, offset ) {

					this.resolvedProperty.fromArray( buffer, offset );

				},

				function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

					this.resolvedProperty.fromArray( buffer, offset );
					this.targetObject.needsUpdate = true;

				},

				function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

					this.resolvedProperty.fromArray( buffer, offset );
					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			]

		],

		getValue: function getValue_unbound( targetArray, offset ) {

			this.bind();
			this.getValue( targetArray, offset );

			// Note: This class uses a State pattern on a per-method basis:
			// 'bind' sets 'this.getValue' / 'setValue' and shadows the
			// prototype version of these methods with one that represents
			// the bound state. When the property is not found, the methods
			// become no-ops.

		},

		setValue: function getValue_unbound( sourceArray, offset ) {

			this.bind();
			this.setValue( sourceArray, offset );

		},

		// create getter / setter pair for a property in the scene graph
		bind: function () {

			var targetObject = this.node,
				parsedPath = this.parsedPath,

				objectName = parsedPath.objectName,
				propertyName = parsedPath.propertyName,
				propertyIndex = parsedPath.propertyIndex;

			if ( ! targetObject ) {

				targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;

				this.node = targetObject;

			}

			// set fail state so we can just 'return' on error
			this.getValue = this._getValue_unavailable;
			this.setValue = this._setValue_unavailable;

			// ensure there is a value node
			if ( ! targetObject ) {

				console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
				return;

			}

			if ( objectName ) {

				var objectIndex = parsedPath.objectIndex;

				// special cases were we need to reach deeper into the hierarchy to get the face materials....
				switch ( objectName ) {

					case 'materials':

						if ( ! targetObject.material ) {

							console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
							return;

						}

						if ( ! targetObject.material.materials ) {

							console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
							return;

						}

						targetObject = targetObject.material.materials;

						break;

					case 'bones':

						if ( ! targetObject.skeleton ) {

							console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
							return;

						}

						// potential future optimization: skip this if propertyIndex is already an integer
						// and convert the integer string to a true integer.

						targetObject = targetObject.skeleton.bones;

						// support resolving morphTarget names into indices.
						for ( var i = 0; i < targetObject.length; i ++ ) {

							if ( targetObject[ i ].name === objectIndex ) {

								objectIndex = i;
								break;

							}

						}

						break;

					default:

						if ( targetObject[ objectName ] === undefined ) {

							console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
							return;

						}

						targetObject = targetObject[ objectName ];

				}


				if ( objectIndex !== undefined ) {

					if ( targetObject[ objectIndex ] === undefined ) {

						console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
						return;

					}

					targetObject = targetObject[ objectIndex ];

				}

			}

			// resolve property
			var nodeProperty = targetObject[ propertyName ];

			if ( nodeProperty === undefined ) {

				var nodeName = parsedPath.nodeName;

				console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
					'.' + propertyName + ' but it wasn\'t found.', targetObject );
				return;

			}

			// determine versioning scheme
			var versioning = this.Versioning.None;

			this.targetObject = targetObject;

			if ( targetObject.needsUpdate !== undefined ) { // material

				versioning = this.Versioning.NeedsUpdate;

			} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

				versioning = this.Versioning.MatrixWorldNeedsUpdate;

			}

			// determine how the property gets bound
			var bindingType = this.BindingType.Direct;

			if ( propertyIndex !== undefined ) {

				// access a sub element of the property array (only primitives are supported right now)

				if ( propertyName === "morphTargetInfluences" ) {

					// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

					// support resolving morphTarget names into indices.
					if ( ! targetObject.geometry ) {

						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
						return;

					}

					if ( targetObject.geometry.isBufferGeometry ) {

						if ( ! targetObject.geometry.morphAttributes ) {

							console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
							return;

						}

						for ( var i = 0; i < this.node.geometry.morphAttributes.position.length; i ++ ) {

							if ( targetObject.geometry.morphAttributes.position[ i ].name === propertyIndex ) {

								propertyIndex = i;
								break;

							}

						}


					} else {

						if ( ! targetObject.geometry.morphTargets ) {

							console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this );
							return;

						}

						for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {

							if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {

								propertyIndex = i;
								break;

							}

						}

					}

				}

				bindingType = this.BindingType.ArrayElement;

				this.resolvedProperty = nodeProperty;
				this.propertyIndex = propertyIndex;

			} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

				// must use copy for Object3D.Euler/Quaternion

				bindingType = this.BindingType.HasFromToArray;

				this.resolvedProperty = nodeProperty;

			} else if ( Array.isArray( nodeProperty ) ) {

				bindingType = this.BindingType.EntireArray;

				this.resolvedProperty = nodeProperty;

			} else {

				this.propertyName = propertyName;

			}

			// select getter / setter
			this.getValue = this.GetterByBindingType[ bindingType ];
			this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

		},

		unbind: function () {

			this.node = null;

			// back to the prototype version of getValue / setValue
			// note: avoiding to mutate the shape of 'this' via 'delete'
			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;

		}

	} );

	//!\ DECLARE ALIAS AFTER assign prototype !
	Object.assign( PropertyBinding.prototype, {

		// initial state of these methods that calls 'bind'
		_getValue_unbound: PropertyBinding.prototype.getValue,
		_setValue_unbound: PropertyBinding.prototype.setValue,

	} );

	/**
	 *
	 * A group of objects that receives a shared animation state.
	 *
	 * Usage:
	 *
	 *  - Add objects you would otherwise pass as 'root' to the
	 *    constructor or the .clipAction method of AnimationMixer.
	 *
	 *  - Instead pass this object as 'root'.
	 *
	 *  - You can also add and remove objects later when the mixer
	 *    is running.
	 *
	 * Note:
	 *
	 *    Objects of this class appear as one object to the mixer,
	 *    so cache control of the individual objects must be done
	 *    on the group.
	 *
	 * Limitation:
	 *
	 *  - The animated properties must be compatible among the
	 *    all objects in the group.
	 *
	 *  - A single property can either be controlled through a
	 *    target group or directly, but not both.
	 *
	 * @author tschw
	 */

	function AnimationObjectGroup() {

		this.uuid = _Math.generateUUID();

		// cached objects followed by the active ones
		this._objects = Array.prototype.slice.call( arguments );

		this.nCachedObjects_ = 0; // threshold
		// note: read by PropertyBinding.Composite

		var indices = {};
		this._indicesByUUID = indices; // for bookkeeping

		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

			indices[ arguments[ i ].uuid ] = i;

		}

		this._paths = []; // inside: string
		this._parsedPaths = []; // inside: { we don't care, here }
		this._bindings = []; // inside: Array< PropertyBinding >
		this._bindingsIndicesByPath = {}; // inside: indices in these arrays

		var scope = this;

		this.stats = {

			objects: {
				get total() {

					return scope._objects.length;

				},
				get inUse() {

					return this.total - scope.nCachedObjects_;

				}
			},
			get bindingsPerObject() {

				return scope._bindings.length;

			}

		};

	}

	Object.assign( AnimationObjectGroup.prototype, {

		isAnimationObjectGroup: true,

		add: function () {

			var objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				nBindings = bindings.length,
				knownObject = undefined;

			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];

				if ( index === undefined ) {

					// unknown object -> add it to the ACTIVE region

					index = nObjects ++;
					indicesByUUID[ uuid ] = index;
					objects.push( object );

					// accounting is done, now do the same for all bindings

					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

						bindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );

					}

				} else if ( index < nCachedObjects ) {

					knownObject = objects[ index ];

					// move existing object to the ACTIVE region

					var firstActiveIndex = -- nCachedObjects,
						lastCachedObject = objects[ firstActiveIndex ];

					indicesByUUID[ lastCachedObject.uuid ] = index;
					objects[ index ] = lastCachedObject;

					indicesByUUID[ uuid ] = firstActiveIndex;
					objects[ firstActiveIndex ] = object;

					// accounting is done, now do the same for all bindings

					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

						var bindingsForPath = bindings[ j ],
							lastCached = bindingsForPath[ firstActiveIndex ],
							binding = bindingsForPath[ index ];

						bindingsForPath[ index ] = lastCached;

						if ( binding === undefined ) {

							// since we do not bother to create new bindings
							// for objects that are cached, the binding may
							// or may not exist

							binding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );

						}

						bindingsForPath[ firstActiveIndex ] = binding;

					}

				} else if ( objects[ index ] !== knownObject ) {

					console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +
						'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );

				} // else the object is already where we want it to be

			} // for arguments

			this.nCachedObjects_ = nCachedObjects;

		},

		remove: function () {

			var objects = this._objects,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				bindings = this._bindings,
				nBindings = bindings.length;

			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];

				if ( index !== undefined && index >= nCachedObjects ) {

					// move existing object into the CACHED region

					var lastCachedIndex = nCachedObjects ++,
						firstActiveObject = objects[ lastCachedIndex ];

					indicesByUUID[ firstActiveObject.uuid ] = index;
					objects[ index ] = firstActiveObject;

					indicesByUUID[ uuid ] = lastCachedIndex;
					objects[ lastCachedIndex ] = object;

					// accounting is done, now do the same for all bindings

					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

						var bindingsForPath = bindings[ j ],
							firstActive = bindingsForPath[ lastCachedIndex ],
							binding = bindingsForPath[ index ];

						bindingsForPath[ index ] = firstActive;
						bindingsForPath[ lastCachedIndex ] = binding;

					}

				}

			} // for arguments

			this.nCachedObjects_ = nCachedObjects;

		},

		// remove & forget
		uncache: function () {

			var objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				bindings = this._bindings,
				nBindings = bindings.length;

			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];

				if ( index !== undefined ) {

					delete indicesByUUID[ uuid ];

					if ( index < nCachedObjects ) {

						// object is cached, shrink the CACHED region

						var firstActiveIndex = -- nCachedObjects,
							lastCachedObject = objects[ firstActiveIndex ],
							lastIndex = -- nObjects,
							lastObject = objects[ lastIndex ];

						// last cached object takes this object's place
						indicesByUUID[ lastCachedObject.uuid ] = index;
						objects[ index ] = lastCachedObject;

						// last object goes to the activated slot and pop
						indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
						objects[ firstActiveIndex ] = lastObject;
						objects.pop();

						// accounting is done, now do the same for all bindings

						for ( var j = 0, m = nBindings; j !== m; ++ j ) {

							var bindingsForPath = bindings[ j ],
								lastCached = bindingsForPath[ firstActiveIndex ],
								last = bindingsForPath[ lastIndex ];

							bindingsForPath[ index ] = lastCached;
							bindingsForPath[ firstActiveIndex ] = last;
							bindingsForPath.pop();

						}

					} else {

						// object is active, just swap with the last and pop

						var lastIndex = -- nObjects,
							lastObject = objects[ lastIndex ];

						indicesByUUID[ lastObject.uuid ] = index;
						objects[ index ] = lastObject;
						objects.pop();

						// accounting is done, now do the same for all bindings

						for ( var j = 0, m = nBindings; j !== m; ++ j ) {

							var bindingsForPath = bindings[ j ];

							bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
							bindingsForPath.pop();

						}

					} // cached or active

				} // if object is known

			} // for arguments

			this.nCachedObjects_ = nCachedObjects;

		},

		// Internal interface used by befriended PropertyBinding.Composite:

		subscribe_: function ( path, parsedPath ) {

			// returns an array of bindings for the given path that is changed
			// according to the contained objects in the group

			var indicesByPath = this._bindingsIndicesByPath,
				index = indicesByPath[ path ],
				bindings = this._bindings;

			if ( index !== undefined ) return bindings[ index ];

			var paths = this._paths,
				parsedPaths = this._parsedPaths,
				objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				bindingsForPath = new Array( nObjects );

			index = bindings.length;

			indicesByPath[ path ] = index;

			paths.push( path );
			parsedPaths.push( parsedPath );
			bindings.push( bindingsForPath );

			for ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) {

				var object = objects[ i ];
				bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );

			}

			return bindingsForPath;

		},

		unsubscribe_: function ( path ) {

			// tells the group to forget about a property path and no longer
			// update the array previously obtained with 'subscribe_'

			var indicesByPath = this._bindingsIndicesByPath,
				index = indicesByPath[ path ];

			if ( index !== undefined ) {

				var paths = this._paths,
					parsedPaths = this._parsedPaths,
					bindings = this._bindings,
					lastBindingsIndex = bindings.length - 1,
					lastBindings = bindings[ lastBindingsIndex ],
					lastBindingsPath = path[ lastBindingsIndex ];

				indicesByPath[ lastBindingsPath ] = index;

				bindings[ index ] = lastBindings;
				bindings.pop();

				parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
				parsedPaths.pop();

				paths[ index ] = paths[ lastBindingsIndex ];
				paths.pop();

			}

		}

	} );

	/**
	 *
	 * Action provided by AnimationMixer for scheduling clip playback on specific
	 * objects.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 *
	 */

	function AnimationAction( mixer, clip, localRoot ) {

		this._mixer = mixer;
		this._clip = clip;
		this._localRoot = localRoot || null;

		var tracks = clip.tracks,
			nTracks = tracks.length,
			interpolants = new Array( nTracks );

		var interpolantSettings = {
			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding
		};

		for ( var i = 0; i !== nTracks; ++ i ) {

			var interpolant = tracks[ i ].createInterpolant( null );
			interpolants[ i ] = interpolant;
			interpolant.settings = interpolantSettings;

		}

		this._interpolantSettings = interpolantSettings;

		this._interpolants = interpolants; // bound by the mixer

		// inside: PropertyMixer (managed by the mixer)
		this._propertyBindings = new Array( nTracks );

		this._cacheIndex = null; // for the memory manager
		this._byClipCacheIndex = null; // for the memory manager

		this._timeScaleInterpolant = null;
		this._weightInterpolant = null;

		this.loop = LoopRepeat;
		this._loopCount = - 1;

		// global mixer time when the action is to be started
		// it's set back to 'null' upon start of the action
		this._startTime = null;

		// scaled local time of the action
		// gets clamped or wrapped to 0..clip.duration according to loop
		this.time = 0;

		this.timeScale = 1;
		this._effectiveTimeScale = 1;

		this.weight = 1;
		this._effectiveWeight = 1;

		this.repetitions = Infinity; // no. of repetitions when looping

		this.paused = false; // true -> zero effective time scale
		this.enabled = true; // false -> zero effective weight

		this.clampWhenFinished = false;// keep feeding the last frame?

		this.zeroSlopeAtStart = true;// for smooth interpolation w/o separate
		this.zeroSlopeAtEnd = true;// clips for start, loop and end

	}

	Object.assign( AnimationAction.prototype, {

		// State & Scheduling

		play: function () {

			this._mixer._activateAction( this );

			return this;

		},

		stop: function () {

			this._mixer._deactivateAction( this );

			return this.reset();

		},

		reset: function () {

			this.paused = false;
			this.enabled = true;

			this.time = 0; // restart clip
			this._loopCount = - 1;// forget previous loops
			this._startTime = null;// forget scheduling

			return this.stopFading().stopWarping();

		},

		isRunning: function () {

			return this.enabled && ! this.paused && this.timeScale !== 0 &&
				this._startTime === null && this._mixer._isActiveAction( this );

		},

		// return true when play has been called
		isScheduled: function () {

			return this._mixer._isActiveAction( this );

		},

		startAt: function ( time ) {

			this._startTime = time;

			return this;

		},

		setLoop: function ( mode, repetitions ) {

			this.loop = mode;
			this.repetitions = repetitions;

			return this;

		},

		// Weight

		// set the weight stopping any scheduled fading
		// although .enabled = false yields an effective weight of zero, this
		// method does *not* change .enabled, because it would be confusing
		setEffectiveWeight: function ( weight ) {

			this.weight = weight;

			// note: same logic as when updated at runtime
			this._effectiveWeight = this.enabled ? weight : 0;

			return this.stopFading();

		},

		// return the weight considering fading and .enabled
		getEffectiveWeight: function () {

			return this._effectiveWeight;

		},

		fadeIn: function ( duration ) {

			return this._scheduleFading( duration, 0, 1 );

		},

		fadeOut: function ( duration ) {

			return this._scheduleFading( duration, 1, 0 );

		},

		crossFadeFrom: function ( fadeOutAction, duration, warp ) {

			fadeOutAction.fadeOut( duration );
			this.fadeIn( duration );

			if ( warp ) {

				var fadeInDuration = this._clip.duration,
					fadeOutDuration = fadeOutAction._clip.duration,

					startEndRatio = fadeOutDuration / fadeInDuration,
					endStartRatio = fadeInDuration / fadeOutDuration;

				fadeOutAction.warp( 1.0, startEndRatio, duration );
				this.warp( endStartRatio, 1.0, duration );

			}

			return this;

		},

		crossFadeTo: function ( fadeInAction, duration, warp ) {

			return fadeInAction.crossFadeFrom( this, duration, warp );

		},

		stopFading: function () {

			var weightInterpolant = this._weightInterpolant;

			if ( weightInterpolant !== null ) {

				this._weightInterpolant = null;
				this._mixer._takeBackControlInterpolant( weightInterpolant );

			}

			return this;

		},

		// Time Scale Control

		// set the time scale stopping any scheduled warping
		// although .paused = true yields an effective time scale of zero, this
		// method does *not* change .paused, because it would be confusing
		setEffectiveTimeScale: function ( timeScale ) {

			this.timeScale = timeScale;
			this._effectiveTimeScale = this.paused ? 0 : timeScale;

			return this.stopWarping();

		},

		// return the time scale considering warping and .paused
		getEffectiveTimeScale: function () {

			return this._effectiveTimeScale;

		},

		setDuration: function ( duration ) {

			this.timeScale = this._clip.duration / duration;

			return this.stopWarping();

		},

		syncWith: function ( action ) {

			this.time = action.time;
			this.timeScale = action.timeScale;

			return this.stopWarping();

		},

		halt: function ( duration ) {

			return this.warp( this._effectiveTimeScale, 0, duration );

		},

		warp: function ( startTimeScale, endTimeScale, duration ) {

			var mixer = this._mixer, now = mixer.time,
				interpolant = this._timeScaleInterpolant,

				timeScale = this.timeScale;

			if ( interpolant === null ) {

				interpolant = mixer._lendControlInterpolant();
				this._timeScaleInterpolant = interpolant;

			}

			var times = interpolant.parameterPositions,
				values = interpolant.sampleValues;

			times[ 0 ] = now;
			times[ 1 ] = now + duration;

			values[ 0 ] = startTimeScale / timeScale;
			values[ 1 ] = endTimeScale / timeScale;

			return this;

		},

		stopWarping: function () {

			var timeScaleInterpolant = this._timeScaleInterpolant;

			if ( timeScaleInterpolant !== null ) {

				this._timeScaleInterpolant = null;
				this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

			}

			return this;

		},

		// Object Accessors

		getMixer: function () {

			return this._mixer;

		},

		getClip: function () {

			return this._clip;

		},

		getRoot: function () {

			return this._localRoot || this._mixer._root;

		},

		// Interna

		_update: function ( time, deltaTime, timeDirection, accuIndex ) {

			// called by the mixer

			if ( ! this.enabled ) {

				// call ._updateWeight() to update ._effectiveWeight

				this._updateWeight( time );
				return;

			}

			var startTime = this._startTime;

			if ( startTime !== null ) {

				// check for scheduled start of action

				var timeRunning = ( time - startTime ) * timeDirection;
				if ( timeRunning < 0 || timeDirection === 0 ) {

					return; // yet to come / don't decide when delta = 0

				}

				// start

				this._startTime = null; // unschedule
				deltaTime = timeDirection * timeRunning;

			}

			// apply time scale and advance time

			deltaTime *= this._updateTimeScale( time );
			var clipTime = this._updateTime( deltaTime );

			// note: _updateTime may disable the action resulting in
			// an effective weight of 0

			var weight = this._updateWeight( time );

			if ( weight > 0 ) {

				var interpolants = this._interpolants;
				var propertyMixers = this._propertyBindings;

				for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {

					interpolants[ j ].evaluate( clipTime );
					propertyMixers[ j ].accumulate( accuIndex, weight );

				}

			}

		},

		_updateWeight: function ( time ) {

			var weight = 0;

			if ( this.enabled ) {

				weight = this.weight;
				var interpolant = this._weightInterpolant;

				if ( interpolant !== null ) {

					var interpolantValue = interpolant.evaluate( time )[ 0 ];

					weight *= interpolantValue;

					if ( time > interpolant.parameterPositions[ 1 ] ) {

						this.stopFading();

						if ( interpolantValue === 0 ) {

							// faded out, disable
							this.enabled = false;

						}

					}

				}

			}

			this._effectiveWeight = weight;
			return weight;

		},

		_updateTimeScale: function ( time ) {

			var timeScale = 0;

			if ( ! this.paused ) {

				timeScale = this.timeScale;

				var interpolant = this._timeScaleInterpolant;

				if ( interpolant !== null ) {

					var interpolantValue = interpolant.evaluate( time )[ 0 ];

					timeScale *= interpolantValue;

					if ( time > interpolant.parameterPositions[ 1 ] ) {

						this.stopWarping();

						if ( timeScale === 0 ) {

							// motion has halted, pause
							this.paused = true;

						} else {

							// warp done - apply final time scale
							this.timeScale = timeScale;

						}

					}

				}

			}

			this._effectiveTimeScale = timeScale;
			return timeScale;

		},

		_updateTime: function ( deltaTime ) {

			var time = this.time + deltaTime;
			var duration = this._clip.duration;
			var loop = this.loop;
			var loopCount = this._loopCount;

			var pingPong = ( loop === LoopPingPong );

			if ( deltaTime === 0 ) {

				if ( loopCount === - 1 ) return time;

				return ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;

			}

			if ( loop === LoopOnce ) {

				if ( loopCount === - 1 ) {

					// just started

					this._loopCount = 0;
					this._setEndings( true, true, false );

				}

				handle_stop: {

					if ( time >= duration ) {

						time = duration;

					} else if ( time < 0 ) {

						time = 0;

					} else break handle_stop;

					if ( this.clampWhenFinished ) this.paused = true;
					else this.enabled = false;

					this._mixer.dispatchEvent( {
						type: 'finished', action: this,
						direction: deltaTime < 0 ? - 1 : 1
					} );

				}

			} else { // repetitive Repeat or PingPong

				if ( loopCount === - 1 ) {

					// just started

					if ( deltaTime >= 0 ) {

						loopCount = 0;

						this._setEndings( true, this.repetitions === 0, pingPong );

					} else {

						// when looping in reverse direction, the initial
						// transition through zero counts as a repetition,
						// so leave loopCount at -1

						this._setEndings( this.repetitions === 0, true, pingPong );

					}

				}

				if ( time >= duration || time < 0 ) {

					// wrap around

					var loopDelta = Math.floor( time / duration ); // signed
					time -= duration * loopDelta;

					loopCount += Math.abs( loopDelta );

					var pending = this.repetitions - loopCount;

					if ( pending <= 0 ) {

						// have to stop (switch state, clamp time, fire event)

						if ( this.clampWhenFinished ) this.paused = true;
						else this.enabled = false;

						time = deltaTime > 0 ? duration : 0;

						this._mixer.dispatchEvent( {
							type: 'finished', action: this,
							direction: deltaTime > 0 ? 1 : - 1
						} );

					} else {

						// keep running

						if ( pending === 1 ) {

							// entering the last round

							var atStart = deltaTime < 0;
							this._setEndings( atStart, ! atStart, pingPong );

						} else {

							this._setEndings( false, false, pingPong );

						}

						this._loopCount = loopCount;

						this._mixer.dispatchEvent( {
							type: 'loop', action: this, loopDelta: loopDelta
						} );

					}

				}

				if ( pingPong && ( loopCount & 1 ) === 1 ) {

					// invert time for the "pong round"

					this.time = time;
					return duration - time;

				}

			}

			this.time = time;
			return time;

		},

		_setEndings: function ( atStart, atEnd, pingPong ) {

			var settings = this._interpolantSettings;

			if ( pingPong ) {

				settings.endingStart = ZeroSlopeEnding;
				settings.endingEnd = ZeroSlopeEnding;

			} else {

				// assuming for LoopOnce atStart == atEnd == true

				if ( atStart ) {

					settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;

				} else {

					settings.endingStart = WrapAroundEnding;

				}

				if ( atEnd ) {

					settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;

				} else {

					settings.endingEnd 	 = WrapAroundEnding;

				}

			}

		},

		_scheduleFading: function ( duration, weightNow, weightThen ) {

			var mixer = this._mixer, now = mixer.time,
				interpolant = this._weightInterpolant;

			if ( interpolant === null ) {

				interpolant = mixer._lendControlInterpolant();
				this._weightInterpolant = interpolant;

			}

			var times = interpolant.parameterPositions,
				values = interpolant.sampleValues;

			times[ 0 ] = now;
			values[ 0 ] = weightNow;
			times[ 1 ] = now + duration;
			values[ 1 ] = weightThen;

			return this;

		}

	} );

	/**
	 *
	 * Player for AnimationClips.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function AnimationMixer( root ) {

		this._root = root;
		this._initMemoryManager();
		this._accuIndex = 0;

		this.time = 0;

		this.timeScale = 1.0;

	}

	AnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: AnimationMixer,

		_bindAction: function ( action, prototypeAction ) {

			var root = action._localRoot || this._root,
				tracks = action._clip.tracks,
				nTracks = tracks.length,
				bindings = action._propertyBindings,
				interpolants = action._interpolants,
				rootUuid = root.uuid,
				bindingsByRoot = this._bindingsByRootAndName,
				bindingsByName = bindingsByRoot[ rootUuid ];

			if ( bindingsByName === undefined ) {

				bindingsByName = {};
				bindingsByRoot[ rootUuid ] = bindingsByName;

			}

			for ( var i = 0; i !== nTracks; ++ i ) {

				var track = tracks[ i ],
					trackName = track.name,
					binding = bindingsByName[ trackName ];

				if ( binding !== undefined ) {

					bindings[ i ] = binding;

				} else {

					binding = bindings[ i ];

					if ( binding !== undefined ) {

						// existing binding, make sure the cache knows

						if ( binding._cacheIndex === null ) {

							++ binding.referenceCount;
							this._addInactiveBinding( binding, rootUuid, trackName );

						}

						continue;

					}

					var path = prototypeAction && prototypeAction.
						_propertyBindings[ i ].binding.parsedPath;

					binding = new PropertyMixer(
						PropertyBinding.create( root, trackName, path ),
						track.ValueTypeName, track.getValueSize() );

					++ binding.referenceCount;
					this._addInactiveBinding( binding, rootUuid, trackName );

					bindings[ i ] = binding;

				}

				interpolants[ i ].resultBuffer = binding.buffer;

			}

		},

		_activateAction: function ( action ) {

			if ( ! this._isActiveAction( action ) ) {

				if ( action._cacheIndex === null ) {

					// this action has been forgotten by the cache, but the user
					// appears to be still using it -> rebind

					var rootUuid = ( action._localRoot || this._root ).uuid,
						clipUuid = action._clip.uuid,
						actionsForClip = this._actionsByClip[ clipUuid ];

					this._bindAction( action,
						actionsForClip && actionsForClip.knownActions[ 0 ] );

					this._addInactiveAction( action, clipUuid, rootUuid );

				}

				var bindings = action._propertyBindings;

				// increment reference counts / sort out state
				for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

					var binding = bindings[ i ];

					if ( binding.useCount ++ === 0 ) {

						this._lendBinding( binding );
						binding.saveOriginalState();

					}

				}

				this._lendAction( action );

			}

		},

		_deactivateAction: function ( action ) {

			if ( this._isActiveAction( action ) ) {

				var bindings = action._propertyBindings;

				// decrement reference counts / sort out state
				for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

					var binding = bindings[ i ];

					if ( -- binding.useCount === 0 ) {

						binding.restoreOriginalState();
						this._takeBackBinding( binding );

					}

				}

				this._takeBackAction( action );

			}

		},

		// Memory manager

		_initMemoryManager: function () {

			this._actions = []; // 'nActiveActions' followed by inactive ones
			this._nActiveActions = 0;

			this._actionsByClip = {};
			// inside:
			// {
			// 	knownActions: Array< AnimationAction > - used as prototypes
			// 	actionByRoot: AnimationAction - lookup
			// }


			this._bindings = []; // 'nActiveBindings' followed by inactive ones
			this._nActiveBindings = 0;

			this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


			this._controlInterpolants = []; // same game as above
			this._nActiveControlInterpolants = 0;

			var scope = this;

			this.stats = {

				actions: {
					get total() {

						return scope._actions.length;

					},
					get inUse() {

						return scope._nActiveActions;

					}
				},
				bindings: {
					get total() {

						return scope._bindings.length;

					},
					get inUse() {

						return scope._nActiveBindings;

					}
				},
				controlInterpolants: {
					get total() {

						return scope._controlInterpolants.length;

					},
					get inUse() {

						return scope._nActiveControlInterpolants;

					}
				}

			};

		},

		// Memory management for AnimationAction objects

		_isActiveAction: function ( action ) {

			var index = action._cacheIndex;
			return index !== null && index < this._nActiveActions;

		},

		_addInactiveAction: function ( action, clipUuid, rootUuid ) {

			var actions = this._actions,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ];

			if ( actionsForClip === undefined ) {

				actionsForClip = {

					knownActions: [ action ],
					actionByRoot: {}

				};

				action._byClipCacheIndex = 0;

				actionsByClip[ clipUuid ] = actionsForClip;

			} else {

				var knownActions = actionsForClip.knownActions;

				action._byClipCacheIndex = knownActions.length;
				knownActions.push( action );

			}

			action._cacheIndex = actions.length;
			actions.push( action );

			actionsForClip.actionByRoot[ rootUuid ] = action;

		},

		_removeInactiveAction: function ( action ) {

			var actions = this._actions,
				lastInactiveAction = actions[ actions.length - 1 ],
				cacheIndex = action._cacheIndex;

			lastInactiveAction._cacheIndex = cacheIndex;
			actions[ cacheIndex ] = lastInactiveAction;
			actions.pop();

			action._cacheIndex = null;


			var clipUuid = action._clip.uuid,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ],
				knownActionsForClip = actionsForClip.knownActions,

				lastKnownAction =
					knownActionsForClip[ knownActionsForClip.length - 1 ],

				byClipCacheIndex = action._byClipCacheIndex;

			lastKnownAction._byClipCacheIndex = byClipCacheIndex;
			knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
			knownActionsForClip.pop();

			action._byClipCacheIndex = null;


			var actionByRoot = actionsForClip.actionByRoot,
				rootUuid = ( action._localRoot || this._root ).uuid;

			delete actionByRoot[ rootUuid ];

			if ( knownActionsForClip.length === 0 ) {

				delete actionsByClip[ clipUuid ];

			}

			this._removeInactiveBindingsForAction( action );

		},

		_removeInactiveBindingsForAction: function ( action ) {

			var bindings = action._propertyBindings;
			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

				var binding = bindings[ i ];

				if ( -- binding.referenceCount === 0 ) {

					this._removeInactiveBinding( binding );

				}

			}

		},

		_lendAction: function ( action ) {

			// [ active actions |  inactive actions  ]
			// [  active actions >| inactive actions ]
			//                 s        a
			//                  <-swap->
			//                 a        s

			var actions = this._actions,
				prevIndex = action._cacheIndex,

				lastActiveIndex = this._nActiveActions ++,

				firstInactiveAction = actions[ lastActiveIndex ];

			action._cacheIndex = lastActiveIndex;
			actions[ lastActiveIndex ] = action;

			firstInactiveAction._cacheIndex = prevIndex;
			actions[ prevIndex ] = firstInactiveAction;

		},

		_takeBackAction: function ( action ) {

			// [  active actions  | inactive actions ]
			// [ active actions |< inactive actions  ]
			//        a        s
			//         <-swap->
			//        s        a

			var actions = this._actions,
				prevIndex = action._cacheIndex,

				firstInactiveIndex = -- this._nActiveActions,

				lastActiveAction = actions[ firstInactiveIndex ];

			action._cacheIndex = firstInactiveIndex;
			actions[ firstInactiveIndex ] = action;

			lastActiveAction._cacheIndex = prevIndex;
			actions[ prevIndex ] = lastActiveAction;

		},

		// Memory management for PropertyMixer objects

		_addInactiveBinding: function ( binding, rootUuid, trackName ) {

			var bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ],

				bindings = this._bindings;

			if ( bindingByName === undefined ) {

				bindingByName = {};
				bindingsByRoot[ rootUuid ] = bindingByName;

			}

			bindingByName[ trackName ] = binding;

			binding._cacheIndex = bindings.length;
			bindings.push( binding );

		},

		_removeInactiveBinding: function ( binding ) {

			var bindings = this._bindings,
				propBinding = binding.binding,
				rootUuid = propBinding.rootNode.uuid,
				trackName = propBinding.path,
				bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ],

				lastInactiveBinding = bindings[ bindings.length - 1 ],
				cacheIndex = binding._cacheIndex;

			lastInactiveBinding._cacheIndex = cacheIndex;
			bindings[ cacheIndex ] = lastInactiveBinding;
			bindings.pop();

			delete bindingByName[ trackName ];

			remove_empty_map: {

				for ( var _ in bindingByName ) break remove_empty_map; // eslint-disable-line no-unused-vars

				delete bindingsByRoot[ rootUuid ];

			}

		},

		_lendBinding: function ( binding ) {

			var bindings = this._bindings,
				prevIndex = binding._cacheIndex,

				lastActiveIndex = this._nActiveBindings ++,

				firstInactiveBinding = bindings[ lastActiveIndex ];

			binding._cacheIndex = lastActiveIndex;
			bindings[ lastActiveIndex ] = binding;

			firstInactiveBinding._cacheIndex = prevIndex;
			bindings[ prevIndex ] = firstInactiveBinding;

		},

		_takeBackBinding: function ( binding ) {

			var bindings = this._bindings,
				prevIndex = binding._cacheIndex,

				firstInactiveIndex = -- this._nActiveBindings,

				lastActiveBinding = bindings[ firstInactiveIndex ];

			binding._cacheIndex = firstInactiveIndex;
			bindings[ firstInactiveIndex ] = binding;

			lastActiveBinding._cacheIndex = prevIndex;
			bindings[ prevIndex ] = lastActiveBinding;

		},


		// Memory management of Interpolants for weight and time scale

		_lendControlInterpolant: function () {

			var interpolants = this._controlInterpolants,
				lastActiveIndex = this._nActiveControlInterpolants ++,
				interpolant = interpolants[ lastActiveIndex ];

			if ( interpolant === undefined ) {

				interpolant = new LinearInterpolant(
					new Float32Array( 2 ), new Float32Array( 2 ),
					1, this._controlInterpolantsResultBuffer );

				interpolant.__cacheIndex = lastActiveIndex;
				interpolants[ lastActiveIndex ] = interpolant;

			}

			return interpolant;

		},

		_takeBackControlInterpolant: function ( interpolant ) {

			var interpolants = this._controlInterpolants,
				prevIndex = interpolant.__cacheIndex,

				firstInactiveIndex = -- this._nActiveControlInterpolants,

				lastActiveInterpolant = interpolants[ firstInactiveIndex ];

			interpolant.__cacheIndex = firstInactiveIndex;
			interpolants[ firstInactiveIndex ] = interpolant;

			lastActiveInterpolant.__cacheIndex = prevIndex;
			interpolants[ prevIndex ] = lastActiveInterpolant;

		},

		_controlInterpolantsResultBuffer: new Float32Array( 1 ),

		// return an action for a clip optionally using a custom root target
		// object (this method allocates a lot of dynamic memory in case a
		// previously unknown clip/root combination is specified)
		clipAction: function ( clip, optionalRoot ) {

			var root = optionalRoot || this._root,
				rootUuid = root.uuid,

				clipObject = typeof clip === 'string' ?
					AnimationClip.findByName( root, clip ) : clip,

				clipUuid = clipObject !== null ? clipObject.uuid : clip,

				actionsForClip = this._actionsByClip[ clipUuid ],
				prototypeAction = null;

			if ( actionsForClip !== undefined ) {

				var existingAction =
						actionsForClip.actionByRoot[ rootUuid ];

				if ( existingAction !== undefined ) {

					return existingAction;

				}

				// we know the clip, so we don't have to parse all
				// the bindings again but can just copy
				prototypeAction = actionsForClip.knownActions[ 0 ];

				// also, take the clip from the prototype action
				if ( clipObject === null )
					clipObject = prototypeAction._clip;

			}

			// clip must be known when specified via string
			if ( clipObject === null ) return null;

			// allocate all resources required to run it
			var newAction = new AnimationAction( this, clipObject, optionalRoot );

			this._bindAction( newAction, prototypeAction );

			// and make the action known to the memory manager
			this._addInactiveAction( newAction, clipUuid, rootUuid );

			return newAction;

		},

		// get an existing action
		existingAction: function ( clip, optionalRoot ) {

			var root = optionalRoot || this._root,
				rootUuid = root.uuid,

				clipObject = typeof clip === 'string' ?
					AnimationClip.findByName( root, clip ) : clip,

				clipUuid = clipObject ? clipObject.uuid : clip,

				actionsForClip = this._actionsByClip[ clipUuid ];

			if ( actionsForClip !== undefined ) {

				return actionsForClip.actionByRoot[ rootUuid ] || null;

			}

			return null;

		},

		// deactivates all previously scheduled actions
		stopAllAction: function () {

			var actions = this._actions,
				nActions = this._nActiveActions,
				bindings = this._bindings,
				nBindings = this._nActiveBindings;

			this._nActiveActions = 0;
			this._nActiveBindings = 0;

			for ( var i = 0; i !== nActions; ++ i ) {

				actions[ i ].reset();

			}

			for ( var i = 0; i !== nBindings; ++ i ) {

				bindings[ i ].useCount = 0;

			}

			return this;

		},

		// advance the time and update apply the animation
		update: function ( deltaTime ) {

			deltaTime *= this.timeScale;

			var actions = this._actions,
				nActions = this._nActiveActions,

				time = this.time += deltaTime,
				timeDirection = Math.sign( deltaTime ),

				accuIndex = this._accuIndex ^= 1;

			// run active actions

			for ( var i = 0; i !== nActions; ++ i ) {

				var action = actions[ i ];

				action._update( time, deltaTime, timeDirection, accuIndex );

			}

			// update scene graph

			var bindings = this._bindings,
				nBindings = this._nActiveBindings;

			for ( var i = 0; i !== nBindings; ++ i ) {

				bindings[ i ].apply( accuIndex );

			}

			return this;

		},

		// return this mixer's root target object
		getRoot: function () {

			return this._root;

		},

		// free all resources specific to a particular clip
		uncacheClip: function ( clip ) {

			var actions = this._actions,
				clipUuid = clip.uuid,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ];

			if ( actionsForClip !== undefined ) {

				// note: just calling _removeInactiveAction would mess up the
				// iteration state and also require updating the state we can
				// just throw away

				var actionsToRemove = actionsForClip.knownActions;

				for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

					var action = actionsToRemove[ i ];

					this._deactivateAction( action );

					var cacheIndex = action._cacheIndex,
						lastInactiveAction = actions[ actions.length - 1 ];

					action._cacheIndex = null;
					action._byClipCacheIndex = null;

					lastInactiveAction._cacheIndex = cacheIndex;
					actions[ cacheIndex ] = lastInactiveAction;
					actions.pop();

					this._removeInactiveBindingsForAction( action );

				}

				delete actionsByClip[ clipUuid ];

			}

		},

		// free all resources specific to a particular root target object
		uncacheRoot: function ( root ) {

			var rootUuid = root.uuid,
				actionsByClip = this._actionsByClip;

			for ( var clipUuid in actionsByClip ) {

				var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
					action = actionByRoot[ rootUuid ];

				if ( action !== undefined ) {

					this._deactivateAction( action );
					this._removeInactiveAction( action );

				}

			}

			var bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ];

			if ( bindingByName !== undefined ) {

				for ( var trackName in bindingByName ) {

					var binding = bindingByName[ trackName ];
					binding.restoreOriginalState();
					this._removeInactiveBinding( binding );

				}

			}

		},

		// remove a targeted clip from the cache
		uncacheAction: function ( clip, optionalRoot ) {

			var action = this.existingAction( clip, optionalRoot );

			if ( action !== null ) {

				this._deactivateAction( action );
				this._removeInactiveAction( action );

			}

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Uniform( value ) {

		if ( typeof value === 'string' ) {

			console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
			value = arguments[ 1 ];

		}

		this.value = value;

	}

	Uniform.prototype.clone = function () {

		return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );

	};

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InstancedBufferGeometry() {

		BufferGeometry.call( this );

		this.type = 'InstancedBufferGeometry';
		this.maxInstancedCount = undefined;

	}

	InstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {

		constructor: InstancedBufferGeometry,

		isInstancedBufferGeometry: true,

		copy: function ( source ) {

			BufferGeometry.prototype.copy.call( this, source );

			this.maxInstancedCount = source.maxInstancedCount;

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		}

	} );

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {

		InterleavedBuffer.call( this, array, stride );

		this.meshPerAttribute = meshPerAttribute || 1;

	}

	InstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {

		constructor: InstancedInterleavedBuffer,

		isInstancedInterleavedBuffer: true,

		copy: function ( source ) {

			InterleavedBuffer.prototype.copy.call( this, source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		}

	} );

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InstancedBufferAttribute( array, itemSize, normalized, meshPerAttribute ) {

		if ( typeof ( normalized ) === 'number' ) {

			meshPerAttribute = normalized;

			normalized = false;

			console.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );

		}

		BufferAttribute.call( this, array, itemSize, normalized );

		this.meshPerAttribute = meshPerAttribute || 1;

	}

	InstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {

		constructor: InstancedBufferAttribute,

		isInstancedBufferAttribute: true,

		copy: function ( source ) {

			BufferAttribute.prototype.copy.call( this, source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author bhouston / http://clara.io/
	 * @author stephomi / http://stephaneginier.com/
	 */

	function Raycaster( origin, direction, near, far ) {

		this.ray = new Ray( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near || 0;
		this.far = far || Infinity;

		this.params = {
			Mesh: {},
			Line: {},
			LOD: {},
			Points: { threshold: 1 },
			Sprite: {}
		};

		Object.defineProperties( this.params, {
			PointCloud: {
				get: function () {

					console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
					return this.Points;

				}
			}
		} );

	}

	function ascSort( a, b ) {

		return a.distance - b.distance;

	}

	function intersectObject( object, raycaster, intersects, recursive ) {

		if ( object.visible === false ) return;

		object.raycast( raycaster, intersects );

		if ( recursive === true ) {

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				intersectObject( children[ i ], raycaster, intersects, true );

			}

		}

	}

	Object.assign( Raycaster.prototype, {

		linePrecision: 1,

		set: function ( origin, direction ) {

			// direction is assumed to be normalized (for accurate distance calculations)

			this.ray.set( origin, direction );

		},

		setFromCamera: function ( coords, camera ) {

			if ( ( camera && camera.isPerspectiveCamera ) ) {

				this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
				this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

			} else if ( ( camera && camera.isOrthographicCamera ) ) {

				this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
				this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

			} else {

				console.error( 'THREE.Raycaster: Unsupported camera type.' );

			}

		},

		intersectObject: function ( object, recursive, optionalTarget ) {

			var intersects = optionalTarget || [];

			intersectObject( object, this, intersects, recursive );

			intersects.sort( ascSort );

			return intersects;

		},

		intersectObjects: function ( objects, recursive, optionalTarget ) {

			var intersects = optionalTarget || [];

			if ( Array.isArray( objects ) === false ) {

				console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
				return intersects;

			}

			for ( var i = 0, l = objects.length; i < l; i ++ ) {

				intersectObject( objects[ i ], this, intersects, recursive );

			}

			intersects.sort( ascSort );

			return intersects;

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
	 *
	 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
	 * The azimuthal angle (theta) is measured from the positive z-axiz.
	 */

	function Spherical( radius, phi, theta ) {

		this.radius = ( radius !== undefined ) ? radius : 1.0;
		this.phi = ( phi !== undefined ) ? phi : 0; // polar angle
		this.theta = ( theta !== undefined ) ? theta : 0; // azimuthal angle

		return this;

	}

	Object.assign( Spherical.prototype, {

		set: function ( radius, phi, theta ) {

			this.radius = radius;
			this.phi = phi;
			this.theta = theta;

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( other ) {

			this.radius = other.radius;
			this.phi = other.phi;
			this.theta = other.theta;

			return this;

		},

		// restrict phi to be betwee EPS and PI-EPS
		makeSafe: function () {

			var EPS = 0.000001;
			this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

			return this;

		},

		setFromVector3: function ( v ) {

			return this.setFromCartesianCoords( v.x, v.y, v.z );

		},

		setFromCartesianCoords: function ( x, y, z ) {

			this.radius = Math.sqrt( x * x + y * y + z * z );

			if ( this.radius === 0 ) {

				this.theta = 0;
				this.phi = 0;

			} else {

				this.theta = Math.atan2( x, z );
				this.phi = Math.acos( _Math.clamp( y / this.radius, - 1, 1 ) );

			}

			return this;

		}

	} );

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
	 *
	 */

	function Cylindrical( radius, theta, y ) {

		this.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane
		this.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
		this.y = ( y !== undefined ) ? y : 0; // height above the x-z plane

		return this;

	}

	Object.assign( Cylindrical.prototype, {

		set: function ( radius, theta, y ) {

			this.radius = radius;
			this.theta = theta;
			this.y = y;

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( other ) {

			this.radius = other.radius;
			this.theta = other.theta;
			this.y = other.y;

			return this;

		},

		setFromVector3: function ( v ) {

			return this.setFromCartesianCoords( v.x, v.y, v.z );

		},

		setFromCartesianCoords: function ( x, y, z ) {

			this.radius = Math.sqrt( x * x + z * z );
			this.theta = Math.atan2( x, z );
			this.y = y;

			return this;

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 */

	function Box2( min, max ) {

		this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
		this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );

	}

	Object.assign( Box2.prototype, {

		set: function ( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		},

		setFromPoints: function ( points ) {

			this.makeEmpty();

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] );

			}

			return this;

		},

		setFromCenterAndSize: function () {

			var v1 = new Vector2();

			return function setFromCenterAndSize( center, size ) {

				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );

				return this;

			};

		}(),

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		},

		makeEmpty: function () {

			this.min.x = this.min.y = + Infinity;
			this.max.x = this.max.y = - Infinity;

			return this;

		},

		isEmpty: function () {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

		},

		getCenter: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box2: .getCenter() target is now required' );
				target = new Vector2();

			}

			return this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		},

		getSize: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box2: .getSize() target is now required' );
				target = new Vector2();

			}

			return this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );

		},

		expandByPoint: function ( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		},

		expandByVector: function ( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		},

		expandByScalar: function ( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		},

		containsPoint: function ( point ) {

			return point.x < this.min.x || point.x > this.max.x ||
				point.y < this.min.y || point.y > this.max.y ? false : true;

		},

		containsBox: function ( box ) {

			return this.min.x <= box.min.x && box.max.x <= this.max.x &&
				this.min.y <= box.min.y && box.max.y <= this.max.y;

		},

		getParameter: function ( point, target ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			if ( target === undefined ) {

				console.warn( 'THREE.Box2: .getParameter() target is now required' );
				target = new Vector2();

			}

			return target.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y )
			);

		},

		intersectsBox: function ( box ) {

			// using 4 splitting planes to rule out intersections

			return box.max.x < this.min.x || box.min.x > this.max.x ||
				box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

		},

		clampPoint: function ( point, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box2: .clampPoint() target is now required' );
				target = new Vector2();

			}

			return target.copy( point ).clamp( this.min, this.max );

		},

		distanceToPoint: function () {

			var v1 = new Vector2();

			return function distanceToPoint( point ) {

				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();

			};

		}(),

		intersect: function ( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			return this;

		},

		union: function ( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		},

		translate: function ( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		},

		equals: function ( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 */

	function Line3( start, end ) {

		this.start = ( start !== undefined ) ? start : new Vector3();
		this.end = ( end !== undefined ) ? end : new Vector3();

	}

	Object.assign( Line3.prototype, {

		set: function ( start, end ) {

			this.start.copy( start );
			this.end.copy( end );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( line ) {

			this.start.copy( line.start );
			this.end.copy( line.end );

			return this;

		},

		getCenter: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Line3: .getCenter() target is now required' );
				target = new Vector3();

			}

			return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

		},

		delta: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Line3: .delta() target is now required' );
				target = new Vector3();

			}

			return target.subVectors( this.end, this.start );

		},

		distanceSq: function () {

			return this.start.distanceToSquared( this.end );

		},

		distance: function () {

			return this.start.distanceTo( this.end );

		},

		at: function ( t, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Line3: .at() target is now required' );
				target = new Vector3();

			}

			return this.delta( target ).multiplyScalar( t ).add( this.start );

		},

		closestPointToPointParameter: function () {

			var startP = new Vector3();
			var startEnd = new Vector3();

			return function closestPointToPointParameter( point, clampToLine ) {

				startP.subVectors( point, this.start );
				startEnd.subVectors( this.end, this.start );

				var startEnd2 = startEnd.dot( startEnd );
				var startEnd_startP = startEnd.dot( startP );

				var t = startEnd_startP / startEnd2;

				if ( clampToLine ) {

					t = _Math.clamp( t, 0, 1 );

				}

				return t;

			};

		}(),

		closestPointToPoint: function ( point, clampToLine, target ) {

			var t = this.closestPointToPointParameter( point, clampToLine );

			if ( target === undefined ) {

				console.warn( 'THREE.Line3: .closestPointToPoint() target is now required' );
				target = new Vector3();

			}

			return this.delta( target ).multiplyScalar( t ).add( this.start );

		},

		applyMatrix4: function ( matrix ) {

			this.start.applyMatrix4( matrix );
			this.end.applyMatrix4( matrix );

			return this;

		},

		equals: function ( line ) {

			return line.start.equals( this.start ) && line.end.equals( this.end );

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function ImmediateRenderObject( material ) {

		Object3D.call( this );

		this.material = material;
		this.render = function ( /* renderCallback */ ) {};

	}

	ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
	ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

	ImmediateRenderObject.prototype.isImmediateRenderObject = true;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function VertexNormalsHelper( object, size, hex, linewidth ) {

		this.object = object;

		this.size = ( size !== undefined ) ? size : 1;

		var color = ( hex !== undefined ) ? hex : 0xff0000;

		var width = ( linewidth !== undefined ) ? linewidth : 1;

		//

		var nNormals = 0;

		var objGeometry = this.object.geometry;

		if ( objGeometry && objGeometry.isGeometry ) {

			nNormals = objGeometry.faces.length * 3;

		} else if ( objGeometry && objGeometry.isBufferGeometry ) {

			nNormals = objGeometry.attributes.normal.count;

		}

		//

		var geometry = new BufferGeometry();

		var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );

		geometry.addAttribute( 'position', positions );

		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

		//

		this.matrixAutoUpdate = false;

		this.update();

	}

	VertexNormalsHelper.prototype = Object.create( LineSegments.prototype );
	VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;

	VertexNormalsHelper.prototype.update = ( function () {

		var v1 = new Vector3();
		var v2 = new Vector3();
		var normalMatrix = new Matrix3();

		return function update() {

			var keys = [ 'a', 'b', 'c' ];

			this.object.updateMatrixWorld( true );

			normalMatrix.getNormalMatrix( this.object.matrixWorld );

			var matrixWorld = this.object.matrixWorld;

			var position = this.geometry.attributes.position;

			//

			var objGeometry = this.object.geometry;

			if ( objGeometry && objGeometry.isGeometry ) {

				var vertices = objGeometry.vertices;

				var faces = objGeometry.faces;

				var idx = 0;

				for ( var i = 0, l = faces.length; i < l; i ++ ) {

					var face = faces[ i ];

					for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

						var vertex = vertices[ face[ keys[ j ] ] ];

						var normal = face.vertexNormals[ j ];

						v1.copy( vertex ).applyMatrix4( matrixWorld );

						v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

						position.setXYZ( idx, v1.x, v1.y, v1.z );

						idx = idx + 1;

						position.setXYZ( idx, v2.x, v2.y, v2.z );

						idx = idx + 1;

					}

				}

			} else if ( objGeometry && objGeometry.isBufferGeometry ) {

				var objPos = objGeometry.attributes.position;

				var objNorm = objGeometry.attributes.normal;

				var idx = 0;

				// for simplicity, ignore index and drawcalls, and render every normal

				for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

					v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

					v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

					v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

					position.setXYZ( idx, v1.x, v1.y, v1.z );

					idx = idx + 1;

					position.setXYZ( idx, v2.x, v2.y, v2.z );

					idx = idx + 1;

				}

			}

			position.needsUpdate = true;

		};

	}() );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function SpotLightHelper( light, color ) {

		Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		var geometry = new BufferGeometry();

		var positions = [
			0, 0, 0, 	0, 0, 1,
			0, 0, 0, 	1, 0, 1,
			0, 0, 0,	- 1, 0, 1,
			0, 0, 0, 	0, 1, 1,
			0, 0, 0, 	0, - 1, 1
		];

		for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

			var p1 = ( i / l ) * Math.PI * 2;
			var p2 = ( j / l ) * Math.PI * 2;

			positions.push(
				Math.cos( p1 ), Math.sin( p1 ), 1,
				Math.cos( p2 ), Math.sin( p2 ), 1
			);

		}

		geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

		var material = new LineBasicMaterial( { fog: false } );

		this.cone = new LineSegments( geometry, material );
		this.add( this.cone );

		this.update();

	}

	SpotLightHelper.prototype = Object.create( Object3D.prototype );
	SpotLightHelper.prototype.constructor = SpotLightHelper;

	SpotLightHelper.prototype.dispose = function () {

		this.cone.geometry.dispose();
		this.cone.material.dispose();

	};

	SpotLightHelper.prototype.update = function () {

		var vector = new Vector3();

		return function update() {

			this.light.updateMatrixWorld();

			var coneLength = this.light.distance ? this.light.distance : 1000;
			var coneWidth = coneLength * Math.tan( this.light.angle );

			this.cone.scale.set( coneWidth, coneWidth, coneLength );

			vector.setFromMatrixPosition( this.light.target.matrixWorld );

			this.cone.lookAt( vector );

			if ( this.color !== undefined ) {

				this.cone.material.color.set( this.color );

			} else {

				this.cone.material.color.copy( this.light.color );

			}

		};

	}();

	/**
	 * @author Sean Griffin / http://twitter.com/sgrif
	 * @author Michael Guerrero / http://realitymeltdown.com
	 * @author mrdoob / http://mrdoob.com/
	 * @author ikerr / http://verold.com
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function getBoneList( object ) {

		var boneList = [];

		if ( object && object.isBone ) {

			boneList.push( object );

		}

		for ( var i = 0; i < object.children.length; i ++ ) {

			boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );

		}

		return boneList;

	}

	function SkeletonHelper( object ) {

		var bones = getBoneList( object );

		var geometry = new BufferGeometry();

		var vertices = [];
		var colors = [];

		var color1 = new Color( 0, 0, 1 );
		var color2 = new Color( 0, 1, 0 );

		for ( var i = 0; i < bones.length; i ++ ) {

			var bone = bones[ i ];

			if ( bone.parent && bone.parent.isBone ) {

				vertices.push( 0, 0, 0 );
				vertices.push( 0, 0, 0 );
				colors.push( color1.r, color1.g, color1.b );
				colors.push( color2.r, color2.g, color2.b );

			}

		}

		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		var material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );

		LineSegments.call( this, geometry, material );

		this.root = object;
		this.bones = bones;

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	}

	SkeletonHelper.prototype = Object.create( LineSegments.prototype );
	SkeletonHelper.prototype.constructor = SkeletonHelper;

	SkeletonHelper.prototype.updateMatrixWorld = function () {

		var vector = new Vector3();

		var boneMatrix = new Matrix4();
		var matrixWorldInv = new Matrix4();

		return function updateMatrixWorld( force ) {

			var bones = this.bones;

			var geometry = this.geometry;
			var position = geometry.getAttribute( 'position' );

			matrixWorldInv.getInverse( this.root.matrixWorld );

			for ( var i = 0, j = 0; i < bones.length; i ++ ) {

				var bone = bones[ i ];

				if ( bone.parent && bone.parent.isBone ) {

					boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
					vector.setFromMatrixPosition( boneMatrix );
					position.setXYZ( j, vector.x, vector.y, vector.z );

					boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
					vector.setFromMatrixPosition( boneMatrix );
					position.setXYZ( j + 1, vector.x, vector.y, vector.z );

					j += 2;

				}

			}

			geometry.getAttribute( 'position' ).needsUpdate = true;

			Object3D.prototype.updateMatrixWorld.call( this, force );

		};

	}();

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	function PointLightHelper( light, sphereSize, color ) {

		this.light = light;
		this.light.updateMatrixWorld();

		this.color = color;

		var geometry = new SphereBufferGeometry( sphereSize, 4, 2 );
		var material = new MeshBasicMaterial( { wireframe: true, fog: false } );

		Mesh.call( this, geometry, material );

		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.update();


		/*
		var distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
		var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

		var d = light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.scale.set( d, d, d );

		}

		this.add( this.lightDistance );
		*/

	}

	PointLightHelper.prototype = Object.create( Mesh.prototype );
	PointLightHelper.prototype.constructor = PointLightHelper;

	PointLightHelper.prototype.dispose = function () {

		this.geometry.dispose();
		this.material.dispose();

	};

	PointLightHelper.prototype.update = function () {

		if ( this.color !== undefined ) {

			this.material.color.set( this.color );

		} else {

			this.material.color.copy( this.light.color );

		}

		/*
		var d = this.light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );

		}
		*/

	};

	/**
	 * @author abelnation / http://github.com/abelnation
	 * @author Mugen87 / http://github.com/Mugen87
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 *  This helper must be added as a child of the light
	 */

	function RectAreaLightHelper( light, color ) {

		this.type = 'RectAreaLightHelper';

		this.light = light;

		this.color = color; // optional hardwired color for the helper

		var positions = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, - 1, 0, 1, 1, 0 ];

		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
		geometry.computeBoundingSphere();

		var material = new LineBasicMaterial( { fog: false } );

		Line.call( this, geometry, material );

		//

		var positions2 = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, - 1, 0, 1, - 1, 0 ];

		var geometry2 = new BufferGeometry();
		geometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
		geometry2.computeBoundingSphere();

		this.add( new Mesh( geometry2, new MeshBasicMaterial( { side: BackSide, fog: false } ) ) );

		this.update();

	}

	RectAreaLightHelper.prototype = Object.create( Line.prototype );
	RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;

	RectAreaLightHelper.prototype.update = function () {

		this.scale.set( 0.5 * this.light.width, 0.5 * this.light.height, 1 );

		if ( this.color !== undefined ) {

			this.material.color.set( this.color );
			this.children[ 0 ].material.color.set( this.color );

		} else {

			this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

			// prevent hue shift
			var c = this.material.color;
			var max = Math.max( c.r, c.g, c.b );
			if ( max > 1 ) c.multiplyScalar( 1 / max );

			this.children[ 0 ].material.color.copy( this.material.color );

		}

	};

	RectAreaLightHelper.prototype.dispose = function () {

		this.geometry.dispose();
		this.material.dispose();
		this.children[ 0 ].geometry.dispose();
		this.children[ 0 ].material.dispose();

	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function HemisphereLightHelper( light, size, color ) {

		Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		var geometry = new OctahedronBufferGeometry( size );
		geometry.rotateY( Math.PI * 0.5 );

		this.material = new MeshBasicMaterial( { wireframe: true, fog: false } );
		if ( this.color === undefined ) this.material.vertexColors = VertexColors;

		var position = geometry.getAttribute( 'position' );
		var colors = new Float32Array( position.count * 3 );

		geometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );

		this.add( new Mesh( geometry, this.material ) );

		this.update();

	}

	HemisphereLightHelper.prototype = Object.create( Object3D.prototype );
	HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;

	HemisphereLightHelper.prototype.dispose = function () {

		this.children[ 0 ].geometry.dispose();
		this.children[ 0 ].material.dispose();

	};

	HemisphereLightHelper.prototype.update = function () {

		var vector = new Vector3();

		var color1 = new Color();
		var color2 = new Color();

		return function update() {

			var mesh = this.children[ 0 ];

			if ( this.color !== undefined ) {

				this.material.color.set( this.color );

			} else {

				var colors = mesh.geometry.getAttribute( 'color' );

				color1.copy( this.light.color );
				color2.copy( this.light.groundColor );

				for ( var i = 0, l = colors.count; i < l; i ++ ) {

					var color = ( i < ( l / 2 ) ) ? color1 : color2;

					colors.setXYZ( i, color.r, color.g, color.b );

				}

				colors.needsUpdate = true;

			}

			mesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );

		};

	}();

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function GridHelper( size, divisions, color1, color2 ) {

		size = size || 10;
		divisions = divisions || 10;
		color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
		color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

		var center = divisions / 2;
		var step = size / divisions;
		var halfSize = size / 2;

		var vertices = [], colors = [];

		for ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

			vertices.push( - halfSize, 0, k, halfSize, 0, k );
			vertices.push( k, 0, - halfSize, k, 0, halfSize );

			var color = i === center ? color1 : color2;

			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;

		}

		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		var material = new LineBasicMaterial( { vertexColors: VertexColors } );

		LineSegments.call( this, geometry, material );

	}

	GridHelper.prototype = Object.assign( Object.create( LineSegments.prototype ), {

		constructor: GridHelper,

		copy: function ( source ) {

			LineSegments.prototype.copy.call( this, source );

			this.geometry.copy( source.geometry );
			this.material.copy( source.material );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / http://github.com/Mugen87
	 * @author Hectate / http://www.github.com/Hectate
	 */

	function PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {

		radius = radius || 10;
		radials = radials || 16;
		circles = circles || 8;
		divisions = divisions || 64;
		color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
		color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

		var vertices = [];
		var colors = [];

		var x, z;
		var v, i, j, r, color;

		// create the radials

		for ( i = 0; i <= radials; i ++ ) {

			v = ( i / radials ) * ( Math.PI * 2 );

			x = Math.sin( v ) * radius;
			z = Math.cos( v ) * radius;

			vertices.push( 0, 0, 0 );
			vertices.push( x, 0, z );

			color = ( i & 1 ) ? color1 : color2;

			colors.push( color.r, color.g, color.b );
			colors.push( color.r, color.g, color.b );

		}

		// create the circles

		for ( i = 0; i <= circles; i ++ ) {

			color = ( i & 1 ) ? color1 : color2;

			r = radius - ( radius / circles * i );

			for ( j = 0; j < divisions; j ++ ) {

				// first vertex

				v = ( j / divisions ) * ( Math.PI * 2 );

				x = Math.sin( v ) * r;
				z = Math.cos( v ) * r;

				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );

				// second vertex

				v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );

				x = Math.sin( v ) * r;
				z = Math.cos( v ) * r;

				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );

			}

		}

		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		var material = new LineBasicMaterial( { vertexColors: VertexColors } );

		LineSegments.call( this, geometry, material );

	}

	PolarGridHelper.prototype = Object.create( LineSegments.prototype );
	PolarGridHelper.prototype.constructor = PolarGridHelper;

	/**
	 * @author Mugen87 / http://github.com/Mugen87
	 */

	function PositionalAudioHelper( audio, range, divisionsInnerAngle, divisionsOuterAngle ) {

		this.audio = audio;
		this.range = range || 1;
		this.divisionsInnerAngle = divisionsInnerAngle || 16;
		this.divisionsOuterAngle = divisionsOuterAngle || 2;

		var geometry = new BufferGeometry();
		var divisions = this.divisionsInnerAngle + this.divisionsOuterAngle * 2;
		var positions = new Float32Array( ( divisions * 3 + 3 ) * 3 );
		geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );

		var materialInnerAngle = new LineBasicMaterial( { color: 0x00ff00 } );
		var materialOuterAngle = new LineBasicMaterial( { color: 0xffff00 } );

		Line.call( this, geometry, [ materialOuterAngle, materialInnerAngle ] );

		this.update();

	}

	PositionalAudioHelper.prototype = Object.create( Line.prototype );
	PositionalAudioHelper.prototype.constructor = PositionalAudioHelper;

	PositionalAudioHelper.prototype.update = function () {

		var audio = this.audio;
		var range = this.range;
		var divisionsInnerAngle = this.divisionsInnerAngle;
		var divisionsOuterAngle = this.divisionsOuterAngle;

		var coneInnerAngle = _Math.degToRad( audio.panner.coneInnerAngle );
		var coneOuterAngle = _Math.degToRad( audio.panner.coneOuterAngle );

		var halfConeInnerAngle = coneInnerAngle / 2;
		var halfConeOuterAngle = coneOuterAngle / 2;

		var start = 0;
		var count = 0;
		var i, stride;

		var geometry = this.geometry;
		var positionAttribute = geometry.attributes.position;

		geometry.clearGroups();

		//

		function generateSegment( from, to, divisions, materialIndex ) {

			var step = ( to - from ) / divisions;

			positionAttribute.setXYZ( start, 0, 0, 0 );
			count ++;

			for ( i = from; i < to; i += step ) {

				stride = start + count;

				positionAttribute.setXYZ( stride, Math.sin( i ) * range, 0, Math.cos( i ) * range );
				positionAttribute.setXYZ( stride + 1, Math.sin( Math.min( i + step, to ) ) * range, 0, Math.cos( Math.min( i + step, to ) ) * range );
				positionAttribute.setXYZ( stride + 2, 0, 0, 0 );

				count += 3;

			}

			geometry.addGroup( start, count, materialIndex );

			start += count;
			count = 0;

		}

		//

		generateSegment( - halfConeOuterAngle, - halfConeInnerAngle, divisionsOuterAngle, 0 );
		generateSegment( - halfConeInnerAngle, halfConeInnerAngle, divisionsInnerAngle, 1 );
		generateSegment( halfConeInnerAngle, halfConeOuterAngle, divisionsOuterAngle, 0 );

		//

		positionAttribute.needsUpdate = true;

		if ( coneInnerAngle === coneOuterAngle ) this.material[ 0 ].visible = false;

	};

	PositionalAudioHelper.prototype.dispose = function () {

		this.geometry.dispose();
		this.material[ 0 ].dispose();
		this.material[ 1 ].dispose();

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function FaceNormalsHelper( object, size, hex, linewidth ) {

		// FaceNormalsHelper only supports THREE.Geometry

		this.object = object;

		this.size = ( size !== undefined ) ? size : 1;

		var color = ( hex !== undefined ) ? hex : 0xffff00;

		var width = ( linewidth !== undefined ) ? linewidth : 1;

		//

		var nNormals = 0;

		var objGeometry = this.object.geometry;

		if ( objGeometry && objGeometry.isGeometry ) {

			nNormals = objGeometry.faces.length;

		} else {

			console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

		}

		//

		var geometry = new BufferGeometry();

		var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );

		geometry.addAttribute( 'position', positions );

		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

		//

		this.matrixAutoUpdate = false;
		this.update();

	}

	FaceNormalsHelper.prototype = Object.create( LineSegments.prototype );
	FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;

	FaceNormalsHelper.prototype.update = ( function () {

		var v1 = new Vector3();
		var v2 = new Vector3();
		var normalMatrix = new Matrix3();

		return function update() {

			this.object.updateMatrixWorld( true );

			normalMatrix.getNormalMatrix( this.object.matrixWorld );

			var matrixWorld = this.object.matrixWorld;

			var position = this.geometry.attributes.position;

			//

			var objGeometry = this.object.geometry;

			var vertices = objGeometry.vertices;

			var faces = objGeometry.faces;

			var idx = 0;

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				var normal = face.normal;

				v1.copy( vertices[ face.a ] )
					.add( vertices[ face.b ] )
					.add( vertices[ face.c ] )
					.divideScalar( 3 )
					.applyMatrix4( matrixWorld );

				v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

				position.setXYZ( idx, v1.x, v1.y, v1.z );

				idx = idx + 1;

				position.setXYZ( idx, v2.x, v2.y, v2.z );

				idx = idx + 1;

			}

			position.needsUpdate = true;

		};

	}() );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function DirectionalLightHelper( light, size, color ) {

		Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		if ( size === undefined ) size = 1;

		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( [
			- size, size, 0,
			size, size, 0,
			size, - size, 0,
			- size, - size, 0,
			- size, size, 0
		], 3 ) );

		var material = new LineBasicMaterial( { fog: false } );

		this.lightPlane = new Line( geometry, material );
		this.add( this.lightPlane );

		geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

		this.targetLine = new Line( geometry, material );
		this.add( this.targetLine );

		this.update();

	}

	DirectionalLightHelper.prototype = Object.create( Object3D.prototype );
	DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;

	DirectionalLightHelper.prototype.dispose = function () {

		this.lightPlane.geometry.dispose();
		this.lightPlane.material.dispose();
		this.targetLine.geometry.dispose();
		this.targetLine.material.dispose();

	};

	DirectionalLightHelper.prototype.update = function () {

		var v1 = new Vector3();
		var v2 = new Vector3();
		var v3 = new Vector3();

		return function update() {

			v1.setFromMatrixPosition( this.light.matrixWorld );
			v2.setFromMatrixPosition( this.light.target.matrixWorld );
			v3.subVectors( v2, v1 );

			this.lightPlane.lookAt( v2 );

			if ( this.color !== undefined ) {

				this.lightPlane.material.color.set( this.color );
				this.targetLine.material.color.set( this.color );

			} else {

				this.lightPlane.material.color.copy( this.light.color );
				this.targetLine.material.color.copy( this.light.color );

			}

			this.targetLine.lookAt( v2 );
			this.targetLine.scale.z = v3.length();

		};

	}();

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */

	function CameraHelper( camera ) {

		var geometry = new BufferGeometry();
		var material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );

		var vertices = [];
		var colors = [];

		var pointMap = {};

		// colors

		var colorFrustum = new Color( 0xffaa00 );
		var colorCone = new Color( 0xff0000 );
		var colorUp = new Color( 0x00aaff );
		var colorTarget = new Color( 0xffffff );
		var colorCross = new Color( 0x333333 );

		// near

		addLine( 'n1', 'n2', colorFrustum );
		addLine( 'n2', 'n4', colorFrustum );
		addLine( 'n4', 'n3', colorFrustum );
		addLine( 'n3', 'n1', colorFrustum );

		// far

		addLine( 'f1', 'f2', colorFrustum );
		addLine( 'f2', 'f4', colorFrustum );
		addLine( 'f4', 'f3', colorFrustum );
		addLine( 'f3', 'f1', colorFrustum );

		// sides

		addLine( 'n1', 'f1', colorFrustum );
		addLine( 'n2', 'f2', colorFrustum );
		addLine( 'n3', 'f3', colorFrustum );
		addLine( 'n4', 'f4', colorFrustum );

		// cone

		addLine( 'p', 'n1', colorCone );
		addLine( 'p', 'n2', colorCone );
		addLine( 'p', 'n3', colorCone );
		addLine( 'p', 'n4', colorCone );

		// up

		addLine( 'u1', 'u2', colorUp );
		addLine( 'u2', 'u3', colorUp );
		addLine( 'u3', 'u1', colorUp );

		// target

		addLine( 'c', 't', colorTarget );
		addLine( 'p', 'c', colorCross );

		// cross

		addLine( 'cn1', 'cn2', colorCross );
		addLine( 'cn3', 'cn4', colorCross );

		addLine( 'cf1', 'cf2', colorCross );
		addLine( 'cf3', 'cf4', colorCross );

		function addLine( a, b, color ) {

			addPoint( a, color );
			addPoint( b, color );

		}

		function addPoint( id, color ) {

			vertices.push( 0, 0, 0 );
			colors.push( color.r, color.g, color.b );

			if ( pointMap[ id ] === undefined ) {

				pointMap[ id ] = [];

			}

			pointMap[ id ].push( ( vertices.length / 3 ) - 1 );

		}

		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		LineSegments.call( this, geometry, material );

		this.camera = camera;
		if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

		this.matrix = camera.matrixWorld;
		this.matrixAutoUpdate = false;

		this.pointMap = pointMap;

		this.update();

	}

	CameraHelper.prototype = Object.create( LineSegments.prototype );
	CameraHelper.prototype.constructor = CameraHelper;

	CameraHelper.prototype.update = function () {

		var geometry, pointMap;

		var vector = new Vector3();
		var camera = new Camera();

		function setPoint( point, x, y, z ) {

			vector.set( x, y, z ).unproject( camera );

			var points = pointMap[ point ];

			if ( points !== undefined ) {

				var position = geometry.getAttribute( 'position' );

				for ( var i = 0, l = points.length; i < l; i ++ ) {

					position.setXYZ( points[ i ], vector.x, vector.y, vector.z );

				}

			}

		}

		return function update() {

			geometry = this.geometry;
			pointMap = this.pointMap;

			var w = 1, h = 1;

			// we need just camera projection matrix inverse
			// world matrix must be identity

			camera.projectionMatrixInverse.copy( this.camera.projectionMatrixInverse );

			// center / target

			setPoint( 'c', 0, 0, - 1 );
			setPoint( 't', 0, 0, 1 );

			// near

			setPoint( 'n1', - w, - h, - 1 );
			setPoint( 'n2', w, - h, - 1 );
			setPoint( 'n3', - w, h, - 1 );
			setPoint( 'n4', w, h, - 1 );

			// far

			setPoint( 'f1', - w, - h, 1 );
			setPoint( 'f2', w, - h, 1 );
			setPoint( 'f3', - w, h, 1 );
			setPoint( 'f4', w, h, 1 );

			// up

			setPoint( 'u1', w * 0.7, h * 1.1, - 1 );
			setPoint( 'u2', - w * 0.7, h * 1.1, - 1 );
			setPoint( 'u3', 0, h * 2, - 1 );

			// cross

			setPoint( 'cf1', - w, 0, 1 );
			setPoint( 'cf2', w, 0, 1 );
			setPoint( 'cf3', 0, - h, 1 );
			setPoint( 'cf4', 0, h, 1 );

			setPoint( 'cn1', - w, 0, - 1 );
			setPoint( 'cn2', w, 0, - 1 );
			setPoint( 'cn3', 0, - h, - 1 );
			setPoint( 'cn4', 0, h, - 1 );

			geometry.getAttribute( 'position' ).needsUpdate = true;

		};

	}();

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / http://github.com/Mugen87
	 */

	function BoxHelper( object, color ) {

		this.object = object;

		if ( color === undefined ) color = 0xffff00;

		var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
		var positions = new Float32Array( 8 * 3 );

		var geometry = new BufferGeometry();
		geometry.setIndex( new BufferAttribute( indices, 1 ) );
		geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );

		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );

		this.matrixAutoUpdate = false;

		this.update();

	}

	BoxHelper.prototype = Object.create( LineSegments.prototype );
	BoxHelper.prototype.constructor = BoxHelper;

	BoxHelper.prototype.update = ( function () {

		var box = new Box3();

		return function update( object ) {

			if ( object !== undefined ) {

				console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );

			}

			if ( this.object !== undefined ) {

				box.setFromObject( this.object );

			}

			if ( box.isEmpty() ) return;

			var min = box.min;
			var max = box.max;

			/*
			  5____4
			1/___0/|
			| 6__|_7
			2/___3/

			0: max.x, max.y, max.z
			1: min.x, max.y, max.z
			2: min.x, min.y, max.z
			3: max.x, min.y, max.z
			4: max.x, max.y, min.z
			5: min.x, max.y, min.z
			6: min.x, min.y, min.z
			7: max.x, min.y, min.z
			*/

			var position = this.geometry.attributes.position;
			var array = position.array;

			array[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;
			array[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;
			array[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;
			array[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
			array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
			array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
			array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
			array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

			position.needsUpdate = true;

			this.geometry.computeBoundingSphere();

		};

	} )();

	BoxHelper.prototype.setFromObject = function ( object ) {

		this.object = object;
		this.update();

		return this;

	};

	BoxHelper.prototype.copy = function ( source ) {

		LineSegments.prototype.copy.call( this, source );

		this.object = source.object;

		return this;

	};

	BoxHelper.prototype.clone = function () {

		return new this.constructor().copy( this );

	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Box3Helper( box, hex ) {

		this.type = 'Box3Helper';

		this.box = box;

		var color = ( hex !== undefined ) ? hex : 0xffff00;

		var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );

		var positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];

		var geometry = new BufferGeometry();

		geometry.setIndex( new BufferAttribute( indices, 1 ) );

		geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );

		this.geometry.computeBoundingSphere();

	}

	Box3Helper.prototype = Object.create( LineSegments.prototype );
	Box3Helper.prototype.constructor = Box3Helper;

	Box3Helper.prototype.updateMatrixWorld = function ( force ) {

		var box = this.box;

		if ( box.isEmpty() ) return;

		box.getCenter( this.position );

		box.getSize( this.scale );

		this.scale.multiplyScalar( 0.5 );

		Object3D.prototype.updateMatrixWorld.call( this, force );

	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function PlaneHelper( plane, size, hex ) {

		this.type = 'PlaneHelper';

		this.plane = plane;

		this.size = ( size === undefined ) ? 1 : size;

		var color = ( hex !== undefined ) ? hex : 0xffff00;

		var positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];

		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
		geometry.computeBoundingSphere();

		Line.call( this, geometry, new LineBasicMaterial( { color: color } ) );

		//

		var positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];

		var geometry2 = new BufferGeometry();
		geometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
		geometry2.computeBoundingSphere();

		this.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false } ) ) );

	}

	PlaneHelper.prototype = Object.create( Line.prototype );
	PlaneHelper.prototype.constructor = PlaneHelper;

	PlaneHelper.prototype.updateMatrixWorld = function ( force ) {

		var scale = - this.plane.constant;

		if ( Math.abs( scale ) < 1e-8 ) scale = 1e-8; // sign does not matter

		this.scale.set( 0.5 * this.size, 0.5 * this.size, scale );

		this.children[ 0 ].material.side = ( scale < 0 ) ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here

		this.lookAt( this.plane.normal );

		Object3D.prototype.updateMatrixWorld.call( this, force );

	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author zz85 / http://github.com/zz85
	 * @author bhouston / http://clara.io
	 *
	 * Creates an arrow for visualizing directions
	 *
	 * Parameters:
	 *  dir - Vector3
	 *  origin - Vector3
	 *  length - Number
	 *  color - color in hex value
	 *  headLength - Number
	 *  headWidth - Number
	 */

	var lineGeometry, coneGeometry;

	function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

		// dir is assumed to be normalized

		Object3D.call( this );

		if ( dir === undefined ) dir = new Vector3( 0, 0, 1 );
		if ( origin === undefined ) origin = new Vector3( 0, 0, 0 );
		if ( length === undefined ) length = 1;
		if ( color === undefined ) color = 0xffff00;
		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;

		if ( lineGeometry === undefined ) {

			lineGeometry = new BufferGeometry();
			lineGeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

			coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
			coneGeometry.translate( 0, - 0.5, 0 );

		}

		this.position.copy( origin );

		this.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );
		this.line.matrixAutoUpdate = false;
		this.add( this.line );

		this.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );
		this.cone.matrixAutoUpdate = false;
		this.add( this.cone );

		this.setDirection( dir );
		this.setLength( length, headLength, headWidth );

	}

	ArrowHelper.prototype = Object.create( Object3D.prototype );
	ArrowHelper.prototype.constructor = ArrowHelper;

	ArrowHelper.prototype.setDirection = ( function () {

		var axis = new Vector3();
		var radians;

		return function setDirection( dir ) {

			// dir is assumed to be normalized

			if ( dir.y > 0.99999 ) {

				this.quaternion.set( 0, 0, 0, 1 );

			} else if ( dir.y < - 0.99999 ) {

				this.quaternion.set( 1, 0, 0, 0 );

			} else {

				axis.set( dir.z, 0, - dir.x ).normalize();

				radians = Math.acos( dir.y );

				this.quaternion.setFromAxisAngle( axis, radians );

			}

		};

	}() );

	ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;

		this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
		this.line.updateMatrix();

		this.cone.scale.set( headWidth, headLength, headWidth );
		this.cone.position.y = length;
		this.cone.updateMatrix();

	};

	ArrowHelper.prototype.setColor = function ( color ) {

		this.line.material.color.copy( color );
		this.cone.material.color.copy( color );

	};

	ArrowHelper.prototype.copy = function ( source ) {

		Object3D.prototype.copy.call( this, source, false );

		this.line.copy( source.line );
		this.cone.copy( source.cone );

		return this;

	};

	ArrowHelper.prototype.clone = function () {

		return new this.constructor().copy( this );

	};

	/**
	 * @author sroucheray / http://sroucheray.org/
	 * @author mrdoob / http://mrdoob.com/
	 */

	function AxesHelper( size ) {

		size = size || 1;

		var vertices = [
			0, 0, 0,	size, 0, 0,
			0, 0, 0,	0, size, 0,
			0, 0, 0,	0, 0, size
		];

		var colors = [
			1, 0, 0,	1, 0.6, 0,
			0, 1, 0,	0.6, 1, 0,
			0, 0, 1,	0, 0.6, 1
		];

		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		var material = new LineBasicMaterial( { vertexColors: VertexColors } );

		LineSegments.call( this, geometry, material );

	}

	AxesHelper.prototype = Object.create( LineSegments.prototype );
	AxesHelper.prototype.constructor = AxesHelper;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Face4( a, b, c, d, normal, color, materialIndex ) {

		console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
		return new Face3( a, b, c, normal, color, materialIndex );

	}

	var LineStrip = 0;

	var LinePieces = 1;

	function MeshFaceMaterial( materials ) {

		console.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );
		return materials;

	}

	function MultiMaterial( materials ) {

		if ( materials === undefined ) materials = [];

		console.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );
		materials.isMultiMaterial = true;
		materials.materials = materials;
		materials.clone = function () {

			return materials.slice();

		};
		return materials;

	}

	function PointCloud( geometry, material ) {

		console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
		return new Points( geometry, material );

	}

	function Particle( material ) {

		console.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );
		return new Sprite( material );

	}

	function ParticleSystem( geometry, material ) {

		console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
		return new Points( geometry, material );

	}

	function PointCloudMaterial( parameters ) {

		console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
		return new PointsMaterial( parameters );

	}

	function ParticleBasicMaterial( parameters ) {

		console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
		return new PointsMaterial( parameters );

	}

	function ParticleSystemMaterial( parameters ) {

		console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
		return new PointsMaterial( parameters );

	}

	function Vertex( x, y, z ) {

		console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
		return new Vector3( x, y, z );

	}

	//

	function DynamicBufferAttribute( array, itemSize ) {

		console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
		return new BufferAttribute( array, itemSize ).setDynamic( true );

	}

	function Int8Attribute( array, itemSize ) {

		console.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );
		return new Int8BufferAttribute( array, itemSize );

	}

	function Uint8Attribute( array, itemSize ) {

		console.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );
		return new Uint8BufferAttribute( array, itemSize );

	}

	function Uint8ClampedAttribute( array, itemSize ) {

		console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );
		return new Uint8ClampedBufferAttribute( array, itemSize );

	}

	function Int16Attribute( array, itemSize ) {

		console.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );
		return new Int16BufferAttribute( array, itemSize );

	}

	function Uint16Attribute( array, itemSize ) {

		console.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );
		return new Uint16BufferAttribute( array, itemSize );

	}

	function Int32Attribute( array, itemSize ) {

		console.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );
		return new Int32BufferAttribute( array, itemSize );

	}

	function Uint32Attribute( array, itemSize ) {

		console.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );
		return new Uint32BufferAttribute( array, itemSize );

	}

	function Float32Attribute( array, itemSize ) {

		console.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );
		return new Float32BufferAttribute( array, itemSize );

	}

	function Float64Attribute( array, itemSize ) {

		console.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );
		return new Float64BufferAttribute( array, itemSize );

	}

	//

	Curve.create = function ( construct, getPoint ) {

		console.log( 'THREE.Curve.create() has been deprecated' );

		construct.prototype = Object.create( Curve.prototype );
		construct.prototype.constructor = construct;
		construct.prototype.getPoint = getPoint;

		return construct;

	};

	//

	Object.assign( CurvePath.prototype, {

		createPointsGeometry: function ( divisions ) {

			console.warn( 'THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

			// generate geometry from path points (for Line or Points objects)

			var pts = this.getPoints( divisions );
			return this.createGeometry( pts );

		},

		createSpacedPointsGeometry: function ( divisions ) {

			console.warn( 'THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

			// generate geometry from equidistant sampling along the path

			var pts = this.getSpacedPoints( divisions );
			return this.createGeometry( pts );

		},

		createGeometry: function ( points ) {

			console.warn( 'THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

			var geometry = new Geometry();

			for ( var i = 0, l = points.length; i < l; i ++ ) {

				var point = points[ i ];
				geometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

			}

			return geometry;

		}

	} );

	//

	Object.assign( Path.prototype, {

		fromPoints: function ( points ) {

			console.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );
			this.setFromPoints( points );

		}

	} );

	//

	function ClosedSplineCurve3( points ) {

		console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

		CatmullRomCurve3.call( this, points );
		this.type = 'catmullrom';
		this.closed = true;

	}

	ClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

	//

	function SplineCurve3( points ) {

		console.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

		CatmullRomCurve3.call( this, points );
		this.type = 'catmullrom';

	}

	SplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

	//

	function Spline( points ) {

		console.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );

		CatmullRomCurve3.call( this, points );
		this.type = 'catmullrom';

	}

	Spline.prototype = Object.create( CatmullRomCurve3.prototype );

	Object.assign( Spline.prototype, {

		initFromArray: function ( /* a */ ) {

			console.error( 'THREE.Spline: .initFromArray() has been removed.' );

		},
		getControlPointsArray: function ( /* optionalTarget */ ) {

			console.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );

		},
		reparametrizeByArcLength: function ( /* samplingCoef */ ) {

			console.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );

		}

	} );

	//

	function AxisHelper( size ) {

		console.warn( 'THREE.AxisHelper has been renamed to THREE.AxesHelper.' );
		return new AxesHelper( size );

	}

	function BoundingBoxHelper( object, color ) {

		console.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );
		return new BoxHelper( object, color );

	}

	function EdgesHelper( object, hex ) {

		console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
		return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

	}

	GridHelper.prototype.setColors = function () {

		console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

	};

	SkeletonHelper.prototype.update = function () {

		console.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );

	};

	function WireframeHelper( object, hex ) {

		console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
		return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

	}

	//

	Object.assign( Loader.prototype, {

		extractUrlBase: function ( url ) {

			console.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );
			return LoaderUtils.extractUrlBase( url );

		}

	} );

	function XHRLoader( manager ) {

		console.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );
		return new FileLoader( manager );

	}

	function BinaryTextureLoader( manager ) {

		console.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );
		return new DataTextureLoader( manager );

	}

	Object.assign( ObjectLoader.prototype, {

		setTexturePath: function ( value ) {

			console.warn( 'THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().' );
			return this.setResourcePath( value );

		}

	} );

	//

	Object.assign( Box2.prototype, {

		center: function ( optionalTarget ) {

			console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
			return this.getCenter( optionalTarget );

		},
		empty: function () {

			console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
			return this.isEmpty();

		},
		isIntersectionBox: function ( box ) {

			console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox( box );

		},
		size: function ( optionalTarget ) {

			console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
			return this.getSize( optionalTarget );

		}
	} );

	Object.assign( Box3.prototype, {

		center: function ( optionalTarget ) {

			console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
			return this.getCenter( optionalTarget );

		},
		empty: function () {

			console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
			return this.isEmpty();

		},
		isIntersectionBox: function ( box ) {

			console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox( box );

		},
		isIntersectionSphere: function ( sphere ) {

			console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
			return this.intersectsSphere( sphere );

		},
		size: function ( optionalTarget ) {

			console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
			return this.getSize( optionalTarget );

		}
	} );

	Line3.prototype.center = function ( optionalTarget ) {

		console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
		return this.getCenter( optionalTarget );

	};

	Object.assign( _Math, {

		random16: function () {

			console.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' );
			return Math.random();

		},

		nearestPowerOfTwo: function ( value ) {

			console.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );
			return _Math.floorPowerOfTwo( value );

		},

		nextPowerOfTwo: function ( value ) {

			console.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );
			return _Math.ceilPowerOfTwo( value );

		}

	} );

	Object.assign( Matrix3.prototype, {

		flattenToArrayOffset: function ( array, offset ) {

			console.warn( "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
			return this.toArray( array, offset );

		},
		multiplyVector3: function ( vector ) {

			console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
			return vector.applyMatrix3( this );

		},
		multiplyVector3Array: function ( /* a */ ) {

			console.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );

		},
		applyToBuffer: function ( buffer /*, offset, length */ ) {

			console.warn( 'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
			return this.applyToBufferAttribute( buffer );

		},
		applyToVector3Array: function ( /* array, offset, length */ ) {

			console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );

		}

	} );

	Object.assign( Matrix4.prototype, {

		extractPosition: function ( m ) {

			console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
			return this.copyPosition( m );

		},
		flattenToArrayOffset: function ( array, offset ) {

			console.warn( "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
			return this.toArray( array, offset );

		},
		getPosition: function () {

			var v1;

			return function getPosition() {

				if ( v1 === undefined ) v1 = new Vector3();
				console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
				return v1.setFromMatrixColumn( this, 3 );

			};

		}(),
		setRotationFromQuaternion: function ( q ) {

			console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
			return this.makeRotationFromQuaternion( q );

		},
		multiplyToArray: function () {

			console.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );

		},
		multiplyVector3: function ( vector ) {

			console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},
		multiplyVector4: function ( vector ) {

			console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},
		multiplyVector3Array: function ( /* a */ ) {

			console.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );

		},
		rotateAxis: function ( v ) {

			console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
			v.transformDirection( this );

		},
		crossVector: function ( vector ) {

			console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},
		translate: function () {

			console.error( 'THREE.Matrix4: .translate() has been removed.' );

		},
		rotateX: function () {

			console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

		},
		rotateY: function () {

			console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

		},
		rotateZ: function () {

			console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

		},
		rotateByAxis: function () {

			console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

		},
		applyToBuffer: function ( buffer /*, offset, length */ ) {

			console.warn( 'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
			return this.applyToBufferAttribute( buffer );

		},
		applyToVector3Array: function ( /* array, offset, length */ ) {

			console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );

		},
		makeFrustum: function ( left, right, bottom, top, near, far ) {

			console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
			return this.makePerspective( left, right, top, bottom, near, far );

		}

	} );

	Plane.prototype.isIntersectionLine = function ( line ) {

		console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
		return this.intersectsLine( line );

	};

	Quaternion.prototype.multiplyVector3 = function ( vector ) {

		console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
		return vector.applyQuaternion( this );

	};

	Object.assign( Ray.prototype, {

		isIntersectionBox: function ( box ) {

			console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox( box );

		},
		isIntersectionPlane: function ( plane ) {

			console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
			return this.intersectsPlane( plane );

		},
		isIntersectionSphere: function ( sphere ) {

			console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
			return this.intersectsSphere( sphere );

		}

	} );

	Object.assign( Triangle.prototype, {

		area: function () {

			console.warn( 'THREE.Triangle: .area() has been renamed to .getArea().' );
			return this.getArea();

		},
		barycoordFromPoint: function ( point, target ) {

			console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
			return this.getBarycoord( point, target );

		},
		midpoint: function ( target ) {

			console.warn( 'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().' );
			return this.getMidpoint( target );

		},
		normal: function ( target ) {

			console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
			return this.getNormal( target );

		},
		plane: function ( target ) {

			console.warn( 'THREE.Triangle: .plane() has been renamed to .getPlane().' );
			return this.getPlane( target );

		}

	} );

	Object.assign( Triangle, {

		barycoordFromPoint: function ( point, a, b, c, target ) {

			console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
			return Triangle.getBarycoord( point, a, b, c, target );

		},
		normal: function ( a, b, c, target ) {

			console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
			return Triangle.getNormal( a, b, c, target );

		}

	} );

	Object.assign( Shape.prototype, {

		extractAllPoints: function ( divisions ) {

			console.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );
			return this.extractPoints( divisions );

		},
		extrude: function ( options ) {

			console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
			return new ExtrudeGeometry( this, options );

		},
		makeGeometry: function ( options ) {

			console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
			return new ShapeGeometry( this, options );

		}

	} );

	Object.assign( Vector2.prototype, {

		fromAttribute: function ( attribute, index, offset ) {

			console.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
			return this.fromBufferAttribute( attribute, index, offset );

		},
		distanceToManhattan: function ( v ) {

			console.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
			return this.manhattanDistanceTo( v );

		},
		lengthManhattan: function () {

			console.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );
			return this.manhattanLength();

		}

	} );

	Object.assign( Vector3.prototype, {

		setEulerFromRotationMatrix: function () {

			console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

		},
		setEulerFromQuaternion: function () {

			console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

		},
		getPositionFromMatrix: function ( m ) {

			console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
			return this.setFromMatrixPosition( m );

		},
		getScaleFromMatrix: function ( m ) {

			console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
			return this.setFromMatrixScale( m );

		},
		getColumnFromMatrix: function ( index, matrix ) {

			console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
			return this.setFromMatrixColumn( matrix, index );

		},
		applyProjection: function ( m ) {

			console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
			return this.applyMatrix4( m );

		},
		fromAttribute: function ( attribute, index, offset ) {

			console.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
			return this.fromBufferAttribute( attribute, index, offset );

		},
		distanceToManhattan: function ( v ) {

			console.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
			return this.manhattanDistanceTo( v );

		},
		lengthManhattan: function () {

			console.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );
			return this.manhattanLength();

		}

	} );

	Object.assign( Vector4.prototype, {

		fromAttribute: function ( attribute, index, offset ) {

			console.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
			return this.fromBufferAttribute( attribute, index, offset );

		},
		lengthManhattan: function () {

			console.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );
			return this.manhattanLength();

		}

	} );

	//

	Object.assign( Geometry.prototype, {

		computeTangents: function () {

			console.error( 'THREE.Geometry: .computeTangents() has been removed.' );

		},
		computeLineDistances: function () {

			console.error( 'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.' );

		}

	} );

	Object.assign( Object3D.prototype, {

		getChildByName: function ( name ) {

			console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
			return this.getObjectByName( name );

		},
		renderDepth: function () {

			console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

		},
		translate: function ( distance, axis ) {

			console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
			return this.translateOnAxis( axis, distance );

		},
		getWorldRotation: function () {

			console.error( 'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.' );

		}

	} );

	Object.defineProperties( Object3D.prototype, {

		eulerOrder: {
			get: function () {

				console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
				return this.rotation.order;

			},
			set: function ( value ) {

				console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
				this.rotation.order = value;

			}
		},
		useQuaternion: {
			get: function () {

				console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

			},
			set: function () {

				console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

			}
		}

	} );

	Object.defineProperties( LOD.prototype, {

		objects: {
			get: function () {

				console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
				return this.levels;

			}
		}

	} );

	Object.defineProperty( Skeleton.prototype, 'useVertexTexture', {

		get: function () {

			console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

		},
		set: function () {

			console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

		}

	} );

	SkinnedMesh.prototype.initBones = function () {

		console.error( 'THREE.SkinnedMesh: initBones() has been removed.' );

	};

	Object.defineProperty( Curve.prototype, '__arcLengthDivisions', {

		get: function () {

			console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
			return this.arcLengthDivisions;

		},
		set: function ( value ) {

			console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
			this.arcLengthDivisions = value;

		}

	} );

	//

	PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {

		console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
				"Use .setFocalLength and .filmGauge for a photographic setup." );

		if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
		this.setFocalLength( focalLength );

	};

	//

	Object.defineProperties( Light.prototype, {
		onlyShadow: {
			set: function () {

				console.warn( 'THREE.Light: .onlyShadow has been removed.' );

			}
		},
		shadowCameraFov: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
				this.shadow.camera.fov = value;

			}
		},
		shadowCameraLeft: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
				this.shadow.camera.left = value;

			}
		},
		shadowCameraRight: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
				this.shadow.camera.right = value;

			}
		},
		shadowCameraTop: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
				this.shadow.camera.top = value;

			}
		},
		shadowCameraBottom: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
				this.shadow.camera.bottom = value;

			}
		},
		shadowCameraNear: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
				this.shadow.camera.near = value;

			}
		},
		shadowCameraFar: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
				this.shadow.camera.far = value;

			}
		},
		shadowCameraVisible: {
			set: function () {

				console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );

			}
		},
		shadowBias: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
				this.shadow.bias = value;

			}
		},
		shadowDarkness: {
			set: function () {

				console.warn( 'THREE.Light: .shadowDarkness has been removed.' );

			}
		},
		shadowMapWidth: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
				this.shadow.mapSize.width = value;

			}
		},
		shadowMapHeight: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
				this.shadow.mapSize.height = value;

			}
		}
	} );

	//

	Object.defineProperties( BufferAttribute.prototype, {

		length: {
			get: function () {

				console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
				return this.array.length;

			}
		},
		copyIndicesArray: function ( /* indices */ ) {

			console.error( 'THREE.BufferAttribute: .copyIndicesArray() has been removed.' );

		}

	} );

	Object.assign( BufferGeometry.prototype, {

		addIndex: function ( index ) {

			console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
			this.setIndex( index );

		},
		addDrawCall: function ( start, count, indexOffset ) {

			if ( indexOffset !== undefined ) {

				console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

			}
			console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
			this.addGroup( start, count );

		},
		clearDrawCalls: function () {

			console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
			this.clearGroups();

		},
		computeTangents: function () {

			console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );

		},
		computeOffsets: function () {

			console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );

		}

	} );

	Object.defineProperties( BufferGeometry.prototype, {

		drawcalls: {
			get: function () {

				console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
				return this.groups;

			}
		},
		offsets: {
			get: function () {

				console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
				return this.groups;

			}
		}

	} );

	//

	Object.assign( ExtrudeBufferGeometry.prototype, {

		getArrays: function () {

			console.error( 'THREE.ExtrudeBufferGeometry: .getArrays() has been removed.' );

		},

		addShapeList: function () {

			console.error( 'THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.' );

		},

		addShape: function () {

			console.error( 'THREE.ExtrudeBufferGeometry: .addShape() has been removed.' );

		}

	} );

	//

	Object.defineProperties( Uniform.prototype, {

		dynamic: {
			set: function () {

				console.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );

			}
		},
		onUpdate: {
			value: function () {

				console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
				return this;

			}
		}

	} );

	//

	Object.defineProperties( Material.prototype, {

		wrapAround: {
			get: function () {

				console.warn( 'THREE.Material: .wrapAround has been removed.' );

			},
			set: function () {

				console.warn( 'THREE.Material: .wrapAround has been removed.' );

			}
		},

		overdraw: {
			get: function () {

				console.warn( 'THREE.Material: .overdraw has been removed.' );

			},
			set: function () {

				console.warn( 'THREE.Material: .overdraw has been removed.' );

			}
		},

		wrapRGB: {
			get: function () {

				console.warn( 'THREE.Material: .wrapRGB has been removed.' );
				return new Color();

			}
		},

		shading: {
			get: function () {

				console.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );

			},
			set: function ( value ) {

				console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
				this.flatShading = ( value === FlatShading );

			}
		}

	} );

	Object.defineProperties( MeshPhongMaterial.prototype, {

		metal: {
			get: function () {

				console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
				return false;

			},
			set: function () {

				console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );

			}
		}

	} );

	Object.defineProperties( ShaderMaterial.prototype, {

		derivatives: {
			get: function () {

				console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
				return this.extensions.derivatives;

			},
			set: function ( value ) {

				console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
				this.extensions.derivatives = value;

			}
		}

	} );

	//

	Object.assign( WebGLRenderer.prototype, {

		clearTarget: function ( renderTarget, color, depth, stencil ) {

			console.warn( 'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.' );
			this.setRenderTarget( renderTarget );
			this.clear( color, depth, stencil );

		},
		animate: function ( callback ) {

			console.warn( 'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().' );
			this.setAnimationLoop( callback );

		},
		getCurrentRenderTarget: function () {

			console.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );
			return this.getRenderTarget();

		},
		getMaxAnisotropy: function () {

			console.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );
			return this.capabilities.getMaxAnisotropy();

		},
		getPrecision: function () {

			console.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );
			return this.capabilities.precision;

		},
		resetGLState: function () {

			console.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );
			return this.state.reset();

		},
		supportsFloatTextures: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
			return this.extensions.get( 'OES_texture_float' );

		},
		supportsHalfFloatTextures: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
			return this.extensions.get( 'OES_texture_half_float' );

		},
		supportsStandardDerivatives: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
			return this.extensions.get( 'OES_standard_derivatives' );

		},
		supportsCompressedTextureS3TC: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
			return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );

		},
		supportsCompressedTexturePVRTC: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
			return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );

		},
		supportsBlendMinMax: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
			return this.extensions.get( 'EXT_blend_minmax' );

		},
		supportsVertexTextures: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
			return this.capabilities.vertexTextures;

		},
		supportsInstancedArrays: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
			return this.extensions.get( 'ANGLE_instanced_arrays' );

		},
		enableScissorTest: function ( boolean ) {

			console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
			this.setScissorTest( boolean );

		},
		initMaterial: function () {

			console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

		},
		addPrePlugin: function () {

			console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

		},
		addPostPlugin: function () {

			console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

		},
		updateShadowMap: function () {

			console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

		},
		setFaceCulling: function () {

			console.warn( 'THREE.WebGLRenderer: .setFaceCulling() has been removed.' );

		},
		allocTextureUnit: function () {

			console.warn( 'THREE.WebGLRenderer: .allocTextureUnit() has been removed.' );

		},
		setTexture: function () {

			console.warn( 'THREE.WebGLRenderer: .setTexture() has been removed.' );

		},
		setTexture2D: function () {

			console.warn( 'THREE.WebGLRenderer: .setTexture2D() has been removed.' );

		},
		setTextureCube: function () {

			console.warn( 'THREE.WebGLRenderer: .setTextureCube() has been removed.' );

		}

	} );

	Object.defineProperties( WebGLRenderer.prototype, {

		shadowMapEnabled: {
			get: function () {

				return this.shadowMap.enabled;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
				this.shadowMap.enabled = value;

			}
		},
		shadowMapType: {
			get: function () {

				return this.shadowMap.type;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
				this.shadowMap.type = value;

			}
		},
		shadowMapCullFace: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );
				return undefined;

			},
			set: function ( /* value */ ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );

			}
		}
	} );

	Object.defineProperties( WebGLShadowMap.prototype, {

		cullFace: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );
				return undefined;

			},
			set: function ( /* cullFace */ ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );

			}
		},
		renderReverseSided: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );
				return undefined;

			},
			set: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );

			}
		},
		renderSingleSided: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );
				return undefined;

			},
			set: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );

			}
		}

	} );

	//

	Object.defineProperties( WebGLRenderTargetCube.prototype, {

		activeCubeFace: {
			set: function ( /* value */ ) {

				console.warn( 'THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().' );

			}
		},
		activeMipMapLevel: {
			set: function ( /* value */ ) {

				console.warn( 'THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().' );

			}
		}

	} );

	//

	Object.defineProperties( WebGLRenderTarget.prototype, {

		wrapS: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
				return this.texture.wrapS;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
				this.texture.wrapS = value;

			}
		},
		wrapT: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
				return this.texture.wrapT;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
				this.texture.wrapT = value;

			}
		},
		magFilter: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
				return this.texture.magFilter;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
				this.texture.magFilter = value;

			}
		},
		minFilter: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
				return this.texture.minFilter;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
				this.texture.minFilter = value;

			}
		},
		anisotropy: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
				return this.texture.anisotropy;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
				this.texture.anisotropy = value;

			}
		},
		offset: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
				return this.texture.offset;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
				this.texture.offset = value;

			}
		},
		repeat: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
				return this.texture.repeat;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
				this.texture.repeat = value;

			}
		},
		format: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
				return this.texture.format;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
				this.texture.format = value;

			}
		},
		type: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
				return this.texture.type;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
				this.texture.type = value;

			}
		},
		generateMipmaps: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
				return this.texture.generateMipmaps;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
				this.texture.generateMipmaps = value;

			}
		}

	} );

	//

	Object.defineProperties( WebVRManager.prototype, {

		standing: {
			set: function ( /* value */ ) {

				console.warn( 'THREE.WebVRManager: .standing has been removed.' );

			}
		},
		userHeight: {
			set: function ( /* value */ ) {

				console.warn( 'THREE.WebVRManager: .userHeight has been removed.' );

			}
		}

	} );

	//

	Audio.prototype.load = function ( file ) {

		console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
		var scope = this;
		var audioLoader = new AudioLoader();
		audioLoader.load( file, function ( buffer ) {

			scope.setBuffer( buffer );

		} );
		return this;

	};

	AudioAnalyser.prototype.getData = function () {

		console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
		return this.getFrequencyData();

	};

	//

	CubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {

		console.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );
		return this.update( renderer, scene );

	};

	//

	var GeometryUtils = {

		merge: function ( geometry1, geometry2, materialIndexOffset ) {

			console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );
			var matrix;

			if ( geometry2.isMesh ) {

				geometry2.matrixAutoUpdate && geometry2.updateMatrix();

				matrix = geometry2.matrix;
				geometry2 = geometry2.geometry;

			}

			geometry1.merge( geometry2, matrix, materialIndexOffset );

		},

		center: function ( geometry ) {

			console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
			return geometry.center();

		}

	};

	ImageUtils.crossOrigin = undefined;

	ImageUtils.loadTexture = function ( url, mapping, onLoad, onError ) {

		console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

		var loader = new TextureLoader();
		loader.setCrossOrigin( this.crossOrigin );

		var texture = loader.load( url, onLoad, undefined, onError );

		if ( mapping ) texture.mapping = mapping;

		return texture;

	};

	ImageUtils.loadTextureCube = function ( urls, mapping, onLoad, onError ) {

		console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

		var loader = new CubeTextureLoader();
		loader.setCrossOrigin( this.crossOrigin );

		var texture = loader.load( urls, onLoad, undefined, onError );

		if ( mapping ) texture.mapping = mapping;

		return texture;

	};

	ImageUtils.loadCompressedTexture = function () {

		console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

	};

	ImageUtils.loadCompressedTextureCube = function () {

		console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

	};

	//

	function Projector() {

		console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

		this.projectVector = function ( vector, camera ) {

			console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
			vector.project( camera );

		};

		this.unprojectVector = function ( vector, camera ) {

			console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
			vector.unproject( camera );

		};

		this.pickingRay = function () {

			console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

		};

	}

	//

	function CanvasRenderer() {

		console.error( 'THREE.CanvasRenderer has been removed' );

	}

	//

	function JSONLoader() {

		console.error( 'THREE.JSONLoader has been removed.' );

	}

	//

	var SceneUtils = {

		createMultiMaterialObject: function ( /* geometry, materials */ ) {

			console.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );

		},

		detach: function ( /* child, parent, scene */ ) {

			console.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );

		},

		attach: function ( /* child, scene, parent */ ) {

			console.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );

		}

	};

	//

	function LensFlare() {

		console.error( 'THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js' );

	}

	exports.WebGLMultisampleRenderTarget = WebGLMultisampleRenderTarget;
	exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
	exports.WebGLRenderTarget = WebGLRenderTarget;
	exports.WebGLRenderer = WebGLRenderer;
	exports.ShaderLib = ShaderLib;
	exports.UniformsLib = UniformsLib;
	exports.UniformsUtils = UniformsUtils;
	exports.ShaderChunk = ShaderChunk;
	exports.FogExp2 = FogExp2;
	exports.Fog = Fog;
	exports.Scene = Scene;
	exports.Sprite = Sprite;
	exports.LOD = LOD;
	exports.SkinnedMesh = SkinnedMesh;
	exports.Skeleton = Skeleton;
	exports.Bone = Bone;
	exports.Mesh = Mesh;
	exports.LineSegments = LineSegments;
	exports.LineLoop = LineLoop;
	exports.Line = Line;
	exports.Points = Points;
	exports.Group = Group;
	exports.VideoTexture = VideoTexture;
	exports.DataTexture = DataTexture;
	exports.DataTexture2DArray = DataTexture2DArray;
	exports.DataTexture3D = DataTexture3D;
	exports.CompressedTexture = CompressedTexture;
	exports.CubeTexture = CubeTexture;
	exports.CanvasTexture = CanvasTexture;
	exports.DepthTexture = DepthTexture;
	exports.Texture = Texture;
	exports.AnimationLoader = AnimationLoader;
	exports.CompressedTextureLoader = CompressedTextureLoader;
	exports.DataTextureLoader = DataTextureLoader;
	exports.CubeTextureLoader = CubeTextureLoader;
	exports.TextureLoader = TextureLoader;
	exports.ObjectLoader = ObjectLoader;
	exports.MaterialLoader = MaterialLoader;
	exports.BufferGeometryLoader = BufferGeometryLoader;
	exports.DefaultLoadingManager = DefaultLoadingManager;
	exports.LoadingManager = LoadingManager;
	exports.ImageLoader = ImageLoader;
	exports.ImageBitmapLoader = ImageBitmapLoader;
	exports.FontLoader = FontLoader;
	exports.FileLoader = FileLoader;
	exports.Loader = Loader;
	exports.LoaderUtils = LoaderUtils;
	exports.Cache = Cache;
	exports.AudioLoader = AudioLoader;
	exports.SpotLightShadow = SpotLightShadow;
	exports.SpotLight = SpotLight;
	exports.PointLight = PointLight;
	exports.RectAreaLight = RectAreaLight;
	exports.HemisphereLight = HemisphereLight;
	exports.DirectionalLightShadow = DirectionalLightShadow;
	exports.DirectionalLight = DirectionalLight;
	exports.AmbientLight = AmbientLight;
	exports.LightShadow = LightShadow;
	exports.Light = Light;
	exports.StereoCamera = StereoCamera;
	exports.PerspectiveCamera = PerspectiveCamera;
	exports.OrthographicCamera = OrthographicCamera;
	exports.CubeCamera = CubeCamera;
	exports.ArrayCamera = ArrayCamera;
	exports.Camera = Camera;
	exports.AudioListener = AudioListener;
	exports.PositionalAudio = PositionalAudio;
	exports.AudioContext = AudioContext;
	exports.AudioAnalyser = AudioAnalyser;
	exports.Audio = Audio;
	exports.VectorKeyframeTrack = VectorKeyframeTrack;
	exports.StringKeyframeTrack = StringKeyframeTrack;
	exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
	exports.NumberKeyframeTrack = NumberKeyframeTrack;
	exports.ColorKeyframeTrack = ColorKeyframeTrack;
	exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
	exports.PropertyMixer = PropertyMixer;
	exports.PropertyBinding = PropertyBinding;
	exports.KeyframeTrack = KeyframeTrack;
	exports.AnimationUtils = AnimationUtils;
	exports.AnimationObjectGroup = AnimationObjectGroup;
	exports.AnimationMixer = AnimationMixer;
	exports.AnimationClip = AnimationClip;
	exports.Uniform = Uniform;
	exports.InstancedBufferGeometry = InstancedBufferGeometry;
	exports.BufferGeometry = BufferGeometry;
	exports.Geometry = Geometry;
	exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
	exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
	exports.InterleavedBuffer = InterleavedBuffer;
	exports.InstancedBufferAttribute = InstancedBufferAttribute;
	exports.Face3 = Face3;
	exports.Object3D = Object3D;
	exports.Raycaster = Raycaster;
	exports.Layers = Layers;
	exports.EventDispatcher = EventDispatcher;
	exports.Clock = Clock;
	exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
	exports.LinearInterpolant = LinearInterpolant;
	exports.DiscreteInterpolant = DiscreteInterpolant;
	exports.CubicInterpolant = CubicInterpolant;
	exports.Interpolant = Interpolant;
	exports.Triangle = Triangle;
	exports.Math = _Math;
	exports.Spherical = Spherical;
	exports.Cylindrical = Cylindrical;
	exports.Plane = Plane;
	exports.Frustum = Frustum;
	exports.Sphere = Sphere;
	exports.Ray = Ray;
	exports.Matrix4 = Matrix4;
	exports.Matrix3 = Matrix3;
	exports.Box3 = Box3;
	exports.Box2 = Box2;
	exports.Line3 = Line3;
	exports.Euler = Euler;
	exports.Vector4 = Vector4;
	exports.Vector3 = Vector3;
	exports.Vector2 = Vector2;
	exports.Quaternion = Quaternion;
	exports.Color = Color;
	exports.ImmediateRenderObject = ImmediateRenderObject;
	exports.VertexNormalsHelper = VertexNormalsHelper;
	exports.SpotLightHelper = SpotLightHelper;
	exports.SkeletonHelper = SkeletonHelper;
	exports.PointLightHelper = PointLightHelper;
	exports.RectAreaLightHelper = RectAreaLightHelper;
	exports.HemisphereLightHelper = HemisphereLightHelper;
	exports.GridHelper = GridHelper;
	exports.PolarGridHelper = PolarGridHelper;
	exports.PositionalAudioHelper = PositionalAudioHelper;
	exports.FaceNormalsHelper = FaceNormalsHelper;
	exports.DirectionalLightHelper = DirectionalLightHelper;
	exports.CameraHelper = CameraHelper;
	exports.BoxHelper = BoxHelper;
	exports.Box3Helper = Box3Helper;
	exports.PlaneHelper = PlaneHelper;
	exports.ArrowHelper = ArrowHelper;
	exports.AxesHelper = AxesHelper;
	exports.Shape = Shape;
	exports.Path = Path;
	exports.ShapePath = ShapePath;
	exports.Font = Font;
	exports.CurvePath = CurvePath;
	exports.Curve = Curve;
	exports.ImageUtils = ImageUtils;
	exports.ShapeUtils = ShapeUtils;
	exports.WebGLUtils = WebGLUtils;
	exports.WireframeGeometry = WireframeGeometry;
	exports.ParametricGeometry = ParametricGeometry;
	exports.ParametricBufferGeometry = ParametricBufferGeometry;
	exports.TetrahedronGeometry = TetrahedronGeometry;
	exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;
	exports.OctahedronGeometry = OctahedronGeometry;
	exports.OctahedronBufferGeometry = OctahedronBufferGeometry;
	exports.IcosahedronGeometry = IcosahedronGeometry;
	exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;
	exports.DodecahedronGeometry = DodecahedronGeometry;
	exports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;
	exports.PolyhedronGeometry = PolyhedronGeometry;
	exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;
	exports.TubeGeometry = TubeGeometry;
	exports.TubeBufferGeometry = TubeBufferGeometry;
	exports.TorusKnotGeometry = TorusKnotGeometry;
	exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
	exports.TorusGeometry = TorusGeometry;
	exports.TorusBufferGeometry = TorusBufferGeometry;
	exports.TextGeometry = TextGeometry;
	exports.TextBufferGeometry = TextBufferGeometry;
	exports.SphereGeometry = SphereGeometry;
	exports.SphereBufferGeometry = SphereBufferGeometry;
	exports.RingGeometry = RingGeometry;
	exports.RingBufferGeometry = RingBufferGeometry;
	exports.PlaneGeometry = PlaneGeometry;
	exports.PlaneBufferGeometry = PlaneBufferGeometry;
	exports.LatheGeometry = LatheGeometry;
	exports.LatheBufferGeometry = LatheBufferGeometry;
	exports.ShapeGeometry = ShapeGeometry;
	exports.ShapeBufferGeometry = ShapeBufferGeometry;
	exports.ExtrudeGeometry = ExtrudeGeometry;
	exports.ExtrudeBufferGeometry = ExtrudeBufferGeometry;
	exports.EdgesGeometry = EdgesGeometry;
	exports.ConeGeometry = ConeGeometry;
	exports.ConeBufferGeometry = ConeBufferGeometry;
	exports.CylinderGeometry = CylinderGeometry;
	exports.CylinderBufferGeometry = CylinderBufferGeometry;
	exports.CircleGeometry = CircleGeometry;
	exports.CircleBufferGeometry = CircleBufferGeometry;
	exports.BoxGeometry = BoxGeometry;
	exports.CubeGeometry = BoxGeometry;
	exports.BoxBufferGeometry = BoxBufferGeometry;
	exports.ShadowMaterial = ShadowMaterial;
	exports.SpriteMaterial = SpriteMaterial;
	exports.RawShaderMaterial = RawShaderMaterial;
	exports.ShaderMaterial = ShaderMaterial;
	exports.PointsMaterial = PointsMaterial;
	exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
	exports.MeshStandardMaterial = MeshStandardMaterial;
	exports.MeshPhongMaterial = MeshPhongMaterial;
	exports.MeshToonMaterial = MeshToonMaterial;
	exports.MeshNormalMaterial = MeshNormalMaterial;
	exports.MeshLambertMaterial = MeshLambertMaterial;
	exports.MeshDepthMaterial = MeshDepthMaterial;
	exports.MeshDistanceMaterial = MeshDistanceMaterial;
	exports.MeshBasicMaterial = MeshBasicMaterial;
	exports.MeshMatcapMaterial = MeshMatcapMaterial;
	exports.LineDashedMaterial = LineDashedMaterial;
	exports.LineBasicMaterial = LineBasicMaterial;
	exports.Material = Material;
	exports.Float64BufferAttribute = Float64BufferAttribute;
	exports.Float32BufferAttribute = Float32BufferAttribute;
	exports.Uint32BufferAttribute = Uint32BufferAttribute;
	exports.Int32BufferAttribute = Int32BufferAttribute;
	exports.Uint16BufferAttribute = Uint16BufferAttribute;
	exports.Int16BufferAttribute = Int16BufferAttribute;
	exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
	exports.Uint8BufferAttribute = Uint8BufferAttribute;
	exports.Int8BufferAttribute = Int8BufferAttribute;
	exports.BufferAttribute = BufferAttribute;
	exports.ArcCurve = ArcCurve;
	exports.CatmullRomCurve3 = CatmullRomCurve3;
	exports.CubicBezierCurve = CubicBezierCurve;
	exports.CubicBezierCurve3 = CubicBezierCurve3;
	exports.EllipseCurve = EllipseCurve;
	exports.LineCurve = LineCurve;
	exports.LineCurve3 = LineCurve3;
	exports.QuadraticBezierCurve = QuadraticBezierCurve;
	exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
	exports.SplineCurve = SplineCurve;
	exports.REVISION = REVISION;
	exports.MOUSE = MOUSE;
	exports.CullFaceNone = CullFaceNone;
	exports.CullFaceBack = CullFaceBack;
	exports.CullFaceFront = CullFaceFront;
	exports.CullFaceFrontBack = CullFaceFrontBack;
	exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
	exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
	exports.BasicShadowMap = BasicShadowMap;
	exports.PCFShadowMap = PCFShadowMap;
	exports.PCFSoftShadowMap = PCFSoftShadowMap;
	exports.FrontSide = FrontSide;
	exports.BackSide = BackSide;
	exports.DoubleSide = DoubleSide;
	exports.FlatShading = FlatShading;
	exports.SmoothShading = SmoothShading;
	exports.NoColors = NoColors;
	exports.FaceColors = FaceColors;
	exports.VertexColors = VertexColors;
	exports.NoBlending = NoBlending;
	exports.NormalBlending = NormalBlending;
	exports.AdditiveBlending = AdditiveBlending;
	exports.SubtractiveBlending = SubtractiveBlending;
	exports.MultiplyBlending = MultiplyBlending;
	exports.CustomBlending = CustomBlending;
	exports.AddEquation = AddEquation;
	exports.SubtractEquation = SubtractEquation;
	exports.ReverseSubtractEquation = ReverseSubtractEquation;
	exports.MinEquation = MinEquation;
	exports.MaxEquation = MaxEquation;
	exports.ZeroFactor = ZeroFactor;
	exports.OneFactor = OneFactor;
	exports.SrcColorFactor = SrcColorFactor;
	exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
	exports.SrcAlphaFactor = SrcAlphaFactor;
	exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
	exports.DstAlphaFactor = DstAlphaFactor;
	exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
	exports.DstColorFactor = DstColorFactor;
	exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
	exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
	exports.NeverDepth = NeverDepth;
	exports.AlwaysDepth = AlwaysDepth;
	exports.LessDepth = LessDepth;
	exports.LessEqualDepth = LessEqualDepth;
	exports.EqualDepth = EqualDepth;
	exports.GreaterEqualDepth = GreaterEqualDepth;
	exports.GreaterDepth = GreaterDepth;
	exports.NotEqualDepth = NotEqualDepth;
	exports.MultiplyOperation = MultiplyOperation;
	exports.MixOperation = MixOperation;
	exports.AddOperation = AddOperation;
	exports.NoToneMapping = NoToneMapping;
	exports.LinearToneMapping = LinearToneMapping;
	exports.ReinhardToneMapping = ReinhardToneMapping;
	exports.Uncharted2ToneMapping = Uncharted2ToneMapping;
	exports.CineonToneMapping = CineonToneMapping;
	exports.ACESFilmicToneMapping = ACESFilmicToneMapping;
	exports.UVMapping = UVMapping;
	exports.CubeReflectionMapping = CubeReflectionMapping;
	exports.CubeRefractionMapping = CubeRefractionMapping;
	exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
	exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
	exports.SphericalReflectionMapping = SphericalReflectionMapping;
	exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
	exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
	exports.RepeatWrapping = RepeatWrapping;
	exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
	exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
	exports.NearestFilter = NearestFilter;
	exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
	exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
	exports.LinearFilter = LinearFilter;
	exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
	exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
	exports.UnsignedByteType = UnsignedByteType;
	exports.ByteType = ByteType;
	exports.ShortType = ShortType;
	exports.UnsignedShortType = UnsignedShortType;
	exports.IntType = IntType;
	exports.UnsignedIntType = UnsignedIntType;
	exports.FloatType = FloatType;
	exports.HalfFloatType = HalfFloatType;
	exports.UnsignedShort4444Type = UnsignedShort4444Type;
	exports.UnsignedShort5551Type = UnsignedShort5551Type;
	exports.UnsignedShort565Type = UnsignedShort565Type;
	exports.UnsignedInt248Type = UnsignedInt248Type;
	exports.AlphaFormat = AlphaFormat;
	exports.RGBFormat = RGBFormat;
	exports.RGBAFormat = RGBAFormat;
	exports.LuminanceFormat = LuminanceFormat;
	exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
	exports.RGBEFormat = RGBEFormat;
	exports.DepthFormat = DepthFormat;
	exports.DepthStencilFormat = DepthStencilFormat;
	exports.RedFormat = RedFormat;
	exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
	exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
	exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
	exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
	exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
	exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
	exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
	exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
	exports.RGB_ETC1_Format = RGB_ETC1_Format;
	exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
	exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
	exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
	exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
	exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
	exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
	exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
	exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
	exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
	exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
	exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
	exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
	exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
	exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
	exports.LoopOnce = LoopOnce;
	exports.LoopRepeat = LoopRepeat;
	exports.LoopPingPong = LoopPingPong;
	exports.InterpolateDiscrete = InterpolateDiscrete;
	exports.InterpolateLinear = InterpolateLinear;
	exports.InterpolateSmooth = InterpolateSmooth;
	exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
	exports.ZeroSlopeEnding = ZeroSlopeEnding;
	exports.WrapAroundEnding = WrapAroundEnding;
	exports.TrianglesDrawMode = TrianglesDrawMode;
	exports.TriangleStripDrawMode = TriangleStripDrawMode;
	exports.TriangleFanDrawMode = TriangleFanDrawMode;
	exports.LinearEncoding = LinearEncoding;
	exports.sRGBEncoding = sRGBEncoding;
	exports.GammaEncoding = GammaEncoding;
	exports.RGBEEncoding = RGBEEncoding;
	exports.LogLuvEncoding = LogLuvEncoding;
	exports.RGBM7Encoding = RGBM7Encoding;
	exports.RGBM16Encoding = RGBM16Encoding;
	exports.RGBDEncoding = RGBDEncoding;
	exports.BasicDepthPacking = BasicDepthPacking;
	exports.RGBADepthPacking = RGBADepthPacking;
	exports.TangentSpaceNormalMap = TangentSpaceNormalMap;
	exports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
	exports.Face4 = Face4;
	exports.LineStrip = LineStrip;
	exports.LinePieces = LinePieces;
	exports.MeshFaceMaterial = MeshFaceMaterial;
	exports.MultiMaterial = MultiMaterial;
	exports.PointCloud = PointCloud;
	exports.Particle = Particle;
	exports.ParticleSystem = ParticleSystem;
	exports.PointCloudMaterial = PointCloudMaterial;
	exports.ParticleBasicMaterial = ParticleBasicMaterial;
	exports.ParticleSystemMaterial = ParticleSystemMaterial;
	exports.Vertex = Vertex;
	exports.DynamicBufferAttribute = DynamicBufferAttribute;
	exports.Int8Attribute = Int8Attribute;
	exports.Uint8Attribute = Uint8Attribute;
	exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
	exports.Int16Attribute = Int16Attribute;
	exports.Uint16Attribute = Uint16Attribute;
	exports.Int32Attribute = Int32Attribute;
	exports.Uint32Attribute = Uint32Attribute;
	exports.Float32Attribute = Float32Attribute;
	exports.Float64Attribute = Float64Attribute;
	exports.ClosedSplineCurve3 = ClosedSplineCurve3;
	exports.SplineCurve3 = SplineCurve3;
	exports.Spline = Spline;
	exports.AxisHelper = AxisHelper;
	exports.BoundingBoxHelper = BoundingBoxHelper;
	exports.EdgesHelper = EdgesHelper;
	exports.WireframeHelper = WireframeHelper;
	exports.XHRLoader = XHRLoader;
	exports.BinaryTextureLoader = BinaryTextureLoader;
	exports.GeometryUtils = GeometryUtils;
	exports.Projector = Projector;
	exports.CanvasRenderer = CanvasRenderer;
	exports.JSONLoader = JSONLoader;
	exports.SceneUtils = SceneUtils;
	exports.LensFlare = LensFlare;

	Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}]},{},[2]);
